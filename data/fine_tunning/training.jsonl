{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7779835\n    - Instructions: 14403928\n    - Cache References: 100196\n    - Cache Misses: 21805\n    - Branch Instructions: 2152463\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array11_14.c\n#include \"array11_14.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array11_14.h\n#ifndef array11_14\n#define array11_14\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array11_14.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array11_14.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1757515\n    - Instructions: 1416594\n    - Cache References: 78085\n    - Cache Misses: 30023\n    - Branch Instructions: 266771\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist14_17.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist14_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist14_17.c\n#include \"sortedlist14_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist14_17.h\n#ifndef sortedlist14_17\n#define sortedlist14_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1718738\n    - Instructions: 1697370\n    - Cache References: 80366\n    - Cache Misses: 17550\n    - Branch Instructions: 323956\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist12_10.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist12_10.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist12_10.c\n#include \"sortedlist12_10.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist12_10.h\n#ifndef sortedlist12_10\n#define sortedlist12_10\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2299540\n    - Instructions: 3055599\n    - Cache References: 73196\n    - Cache Misses: 18802\n    - Branch Instructions: 585162\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist8_15.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: func1.c\n#include \"sortedlist8_15.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist3 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist3->id);\n   free(params0.data);\n   return sortedlist3;\n}\n\n### File: func2.c\n#include \"sortedlist8_15.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist4 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist4->id);\n      free(params0.data);\n      sortedlist4->refC--;\n      if(sortedlist4->refC == 0){\n           cell_t* cell2 = sortedlist4->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist4);\n           DEBUG_FREE(sortedlist4->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist6 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist6->id);\n      free(params0.data);\n      sortedlist6->refC--;\n      if(sortedlist6->refC == 0){\n           cell_t* cell3 = sortedlist6->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist6);\n           DEBUG_FREE(sortedlist6->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func3.c\n#include \"sortedlist8_15.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist5;\n   if (pCounter > 0) {\n      sortedlist5 = vars->data[--pCounter];\n      sortedlist5->refC++;\n      DEBUG_COPY(sortedlist5->id);\n   } else {\n      sortedlist5 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist5->refC = 1;\n      sortedlist5->id = 5;\n      sortedlist5->n = 0;\n      sortedlist5->root = NULL;\n      DEBUG_NEW(sortedlist5->id);\n   }\n   return sortedlist5;\n}\n\n### File: func4.c\n#include \"sortedlist8_15.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: rng.c\n#include \"sortedlist8_15.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist8_15.c\n#include \"sortedlist8_15.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist_t_param params1;\n      params1.size = 1;\n      params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n      params1.data[0] = sortedlist0;\n      sortedlist_t* sortedlist2 = func1(&params1, loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params1.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell4 = sortedlist2->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell5 = sortedlist0->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist8_15.h\n#ifndef sortedlist8_15\n#define sortedlist8_15\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 9929782\n    - Instructions: 14456099\n    - Cache References: 145006\n    - Cache Misses: 58418\n    - Branch Instructions: 2161624\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array12_3.c\n#include \"array12_3.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array12_3.h\n#ifndef array12_3\n#define array12_3\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array12_3.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array12_3.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2941271\n    - Instructions: 3108089\n    - Cache References: 98939\n    - Cache Misses: 31063\n    - Branch Instructions: 594485\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist7_15.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: func1.c\n#include \"sortedlist7_15.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist3 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist3->id);\n   free(params0.data);\n   return sortedlist3;\n}\n\n### File: func2.c\n#include \"sortedlist7_15.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist4 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist4->id);\n      free(params0.data);\n      sortedlist4->refC--;\n      if(sortedlist4->refC == 0){\n           cell_t* cell2 = sortedlist4->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist4);\n           DEBUG_FREE(sortedlist4->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist6 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist6->id);\n      free(params0.data);\n      sortedlist6->refC--;\n      if(sortedlist6->refC == 0){\n           cell_t* cell3 = sortedlist6->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist6);\n           DEBUG_FREE(sortedlist6->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func3.c\n#include \"sortedlist7_15.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist5;\n   if (pCounter > 0) {\n      sortedlist5 = vars->data[--pCounter];\n      sortedlist5->refC++;\n      DEBUG_COPY(sortedlist5->id);\n   } else {\n      sortedlist5 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist5->refC = 1;\n      sortedlist5->id = 5;\n      sortedlist5->n = 0;\n      sortedlist5->root = NULL;\n      DEBUG_NEW(sortedlist5->id);\n   }\n   return sortedlist5;\n}\n\n### File: func4.c\n#include \"sortedlist7_15.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: rng.c\n#include \"sortedlist7_15.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist7_15.c\n#include \"sortedlist7_15.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist_t_param params1;\n      params1.size = 1;\n      params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n      params1.data[0] = sortedlist0;\n      sortedlist_t* sortedlist2 = func1(&params1, loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params1.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell4 = sortedlist2->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell5 = sortedlist0->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist7_15.h\n#ifndef sortedlist7_15\n#define sortedlist7_15\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 15015680\n    - Instructions: 32934729\n    - Cache References: 112807\n    - Cache Misses: 40292\n    - Branch Instructions: 6370251\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist5_6.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist5_6.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist5_6.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist5_6.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist5_6.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist5_6.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist5_6.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist5_6.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist5_6.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist5_6.c\n#include \"sortedlist5_6.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            sortedlist_t_param params0;\n            params0.size = 0;\n            params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n            sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n            DEBUG_RETURN(sortedlist9->id);\n            free(params0.data);\n            sortedlist9->refC--;\n            if(sortedlist9->refC == 0){\n                 cell_t* cell7 = sortedlist9->root;\n                 cell_t* tmp7  = NULL;\n                 while(cell7 != NULL) {\n                     tmp7 = cell7->next;\n                     free(cell7);\n                     cell7 = tmp7;\n                 }\n                 free(sortedlist9);\n                 DEBUG_FREE(sortedlist9->id);\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist5_6.h\n#ifndef sortedlist5_6\n#define sortedlist5_6\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2372491\n    - Instructions: 2406256\n    - Cache References: 89211\n    - Cache Misses: 23783\n    - Branch Instructions: 453880\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist8_4.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist8_4.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist8_4.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist8_4.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist8_4.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist8_4.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist8_4.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist8_4.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist8_4.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist8_4.c\n#include \"sortedlist8_4.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      unsigned int loop0 = 0;\n      unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n      for(; loop0 < loopLimit0; loop0++) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n   }\n   else {\n      unsigned int loop2 = 0;\n      unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n      for(; loop2 < loopLimit2; loop2++) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist9->id);\n         free(params0.data);\n         sortedlist9->refC--;\n         if(sortedlist9->refC == 0){\n              cell_t* cell7 = sortedlist9->root;\n              cell_t* tmp7  = NULL;\n              while(cell7 != NULL) {\n                  tmp7 = cell7->next;\n                  free(cell7);\n                  cell7 = tmp7;\n              }\n              free(sortedlist9);\n              DEBUG_FREE(sortedlist9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist8_4.h\n#ifndef sortedlist8_4\n#define sortedlist8_4\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2450035\n    - Instructions: 2284574\n    - Cache References: 87665\n    - Cache Misses: 32165\n    - Branch Instructions: 433567\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist6_5.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell3 = sortedlist2->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell4 = sortedlist1->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist6_5.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist6_5.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/1 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      if(sortedlist17 != NULL && sortedlist17->n > 0)\n      {\n          cell_t* cell8 = sortedlist17->root;\n          if(cell8->val == 59)\n          {\n              cell8 = cell8->next;\n              sortedlist17->n--;\n          }else{\n              while(cell8->next != NULL && cell8->next->val != 59) cell8 = cell8->next;\n              if(cell8->next != NULL)\n              {\n                  cell8 = cell8->next->next;\n                  sortedlist17->n--;\n              }\n           }\n      }\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist6_5.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell6 = sortedlist11->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell7 = sortedlist13->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist6_5.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist12 != NULL && sortedlist12->n > 0)\n      {\n          cell_t* cell5 = sortedlist12->root;\n          if(cell5->val == 92)\n          {\n              cell5 = cell5->next;\n              sortedlist12->n--;\n          }else{\n              while(cell5->next != NULL && cell5->next->val != 92) cell5 = cell5->next;\n              if(cell5->next != NULL)\n              {\n                  cell5 = cell5->next->next;\n                  sortedlist12->n--;\n              }\n           }\n      }\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist6_5.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist6_5.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell1 = sortedlist3->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell2 = sortedlist5->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist6_5.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist4 != NULL && sortedlist4->n > 0)\n      {\n          cell_t* cell0 = sortedlist4->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist4->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist4->n--;\n              }\n           }\n      }\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist6_5.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist6_5.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist6_5.c\n#include \"sortedlist6_5.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist0->id);\n   free(params0.data);\n   sortedlist_t_param params1;\n   params1.size = 1;\n   params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n   params1.data[0] = sortedlist0;\n   sortedlist_t* sortedlist9 = func1(&params1, loopsFactor);\n   DEBUG_RETURN(sortedlist9->id);\n   free(params1.data);\n   sortedlist_t_param params2;\n   params2.size = 2;\n   params2.data = (sortedlist_t**)malloc(params2.size*sizeof(sortedlist_t*));\n   params2.data[0] = sortedlist0;\n   params2.data[1] = sortedlist9;\n   sortedlist_t* sortedlist16 = func2(&params2, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params2.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell9 = sortedlist16->root;\n        cell_t* tmp9  = NULL;\n        while(cell9 != NULL) {\n            tmp9 = cell9->next;\n            free(cell9);\n            cell9 = tmp9;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   sortedlist9->refC--;\n   if(sortedlist9->refC == 0){\n        cell_t* cell10 = sortedlist9->root;\n        cell_t* tmp10  = NULL;\n        while(cell10 != NULL) {\n            tmp10 = cell10->next;\n            free(cell10);\n            cell10 = tmp10;\n        }\n        free(sortedlist9);\n        DEBUG_FREE(sortedlist9->id);\n   }\n   sortedlist0->refC--;\n   if(sortedlist0->refC == 0){\n        cell_t* cell11 = sortedlist0->root;\n        cell_t* tmp11  = NULL;\n        while(cell11 != NULL) {\n            tmp11 = cell11->next;\n            free(cell11);\n            cell11 = tmp11;\n        }\n        free(sortedlist0);\n        DEBUG_FREE(sortedlist0->id);\n   }\n   return 0;\n}\n\n### File: sortedlist6_5.h\n#ifndef sortedlist6_5\n#define sortedlist6_5\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 749892328\n    - Instructions: 1448384194\n    - Cache References: 1779435\n    - Cache Misses: 172704\n    - Branch Instructions: 245868515\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array8_19.c\n#include \"array8_19.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array66 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(array66->id);\n         free(params0.data);\n         array66->refC--;\n         if(array66->refC == 0) {\n            free(array66->data);\n            free(array66);\n            DEBUG_FREE(array66->id);\n         }\n      }\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array92 = func2(&params0, loopsFactor);\n         DEBUG_RETURN(array92->id);\n         free(params0.data);\n         array92->refC--;\n         if(array92->refC == 0) {\n            free(array92->data);\n            free(array92);\n            DEBUG_FREE(array92->id);\n         }\n      }\n      else {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array94 = func3(&params0, loopsFactor);\n         DEBUG_RETURN(array94->id);\n         free(params0.data);\n         array94->refC--;\n         if(array94->refC == 0) {\n            free(array94->data);\n            free(array94);\n            DEBUG_FREE(array94->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array8_19.h\n#ifndef array8_19\n#define array8_19\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func10(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func11(array_t_param* vars, int loopsFactor);\narray_t* func12(array_t_param* vars, int loopsFactor);\narray_t* func16(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func17(array_t_param* vars, int loopsFactor);\narray_t* func28(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func29(array_t_param* vars, int loopsFactor);\narray_t* func30(array_t_param* vars, int loopsFactor);\narray_t* func34(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func35(array_t_param* vars, int loopsFactor);\narray_t* func46(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func47(array_t_param* vars, int loopsFactor);\narray_t* func48(array_t_param* vars, int loopsFactor);\narray_t* func36(array_t_param* vars, int loopsFactor);\narray_t* func40(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func41(array_t_param* vars, int loopsFactor);\narray_t* func42(array_t_param* vars, int loopsFactor);\narray_t* func49(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func50(array_t_param* vars, int loopsFactor);\narray_t* func51(array_t_param* vars, int loopsFactor);\narray_t* func18(array_t_param* vars, int loopsFactor);\narray_t* func22(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func23(array_t_param* vars, int loopsFactor);\narray_t* func24(array_t_param* vars, int loopsFactor);\narray_t* func31(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func32(array_t_param* vars, int loopsFactor);\narray_t* func33(array_t_param* vars, int loopsFactor);\narray_t* func37(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func38(array_t_param* vars, int loopsFactor);\narray_t* func39(array_t_param* vars, int loopsFactor);\narray_t* func43(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func44(array_t_param* vars, int loopsFactor);\narray_t* func45(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func13(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func14(array_t_param* vars, int loopsFactor);\narray_t* func15(array_t_param* vars, int loopsFactor);\narray_t* func19(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func20(array_t_param* vars, int loopsFactor);\narray_t* func21(array_t_param* vars, int loopsFactor);\narray_t* func25(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func26(array_t_param* vars, int loopsFactor);\narray_t* func27(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func9(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array8_19.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func10(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array65;\n   if (pCounter > 0) {\n      array65 = vars->data[--pCounter];\n      array65->refC++;\n      DEBUG_COPY(array65->id);\n   } else {\n      array65 = (array_t*)malloc(sizeof(array_t));\n      array65->size = 818;\n      array65->refC = 1;\n      array65->id = 65;\n      array65->data = (unsigned int*)malloc(array65->size*sizeof(unsigned int));\n      memset(array65->data, 0, array65->size*sizeof(unsigned int));\n      DEBUG_NEW(array65->id);\n   }\n   return array65;\n}\n\n### File: func1.c\n#include \"array8_19.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array67 = func4(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array67->id);\n   free(params0.data);\n   return array67;\n}\n\n### File: func10.c\n#include \"array8_19.h\" \narray_t* func10(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func11(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func12(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array64;\n   if (pCounter > 0) {\n      array64 = vars->data[--pCounter];\n      array64->refC++;\n      DEBUG_COPY(array64->id);\n   } else {\n      array64 = (array_t*)malloc(sizeof(array_t));\n      array64->size = 840;\n      array64->refC = 1;\n      array64->id = 64;\n      array64->data = (unsigned int*)malloc(array64->size*sizeof(unsigned int));\n      memset(array64->data, 0, array64->size*sizeof(unsigned int));\n      DEBUG_NEW(array64->id);\n   }\n   return array64;\n}\n\n### File: func11.c\n#include \"array8_19.h\" \narray_t* func11(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      for (int i = 0; i < array4->size; i++) {\n         array4->data[i]--;\n      }\n   }\n   return array4;\n}\n\n### File: func12.c\n#include \"array8_19.h\" \narray_t* func12(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array6 = func16(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array6->id);\n   free(params0.data);\n   return array6;\n}\n\n### File: func13.c\n#include \"array8_19.h\" \narray_t* func13(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array72 = func14(&params0, loopsFactor);\n      DEBUG_RETURN(array72->id);\n      free(params0.data);\n      array72->refC--;\n      if(array72->refC == 0) {\n         free(array72->data);\n         free(array72);\n         DEBUG_FREE(array72->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array76 = func15(&params0, loopsFactor);\n      DEBUG_RETURN(array76->id);\n      free(params0.data);\n      array76->refC--;\n      if(array76->refC == 0) {\n         free(array76->data);\n         free(array76);\n         DEBUG_FREE(array76->id);\n      }\n   }\n   array_t* array90;\n   if (pCounter > 0) {\n      array90 = vars->data[--pCounter];\n      array90->refC++;\n      DEBUG_COPY(array90->id);\n   } else {\n      array90 = (array_t*)malloc(sizeof(array_t));\n      array90->size = 899;\n      array90->refC = 1;\n      array90->id = 90;\n      array90->data = (unsigned int*)malloc(array90->size*sizeof(unsigned int));\n      memset(array90->data, 0, array90->size*sizeof(unsigned int));\n      DEBUG_NEW(array90->id);\n   }\n   return array90;\n}\n\n### File: func14.c\n#include \"array8_19.h\" \narray_t* func14(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop12 = 0;\n   unsigned int loopLimit12 = (rand()%loopsFactor)/2 + 1;\n   for(; loop12 < loopLimit12; loop12++) {\n      array_t* array73;\n      if (pCounter > 0) {\n         array73 = vars->data[--pCounter];\n         array73->refC++;\n         DEBUG_COPY(array73->id);\n      } else {\n         array73 = (array_t*)malloc(sizeof(array_t));\n         array73->size = 348;\n         array73->refC = 1;\n         array73->id = 73;\n         array73->data = (unsigned int*)malloc(array73->size*sizeof(unsigned int));\n         memset(array73->data, 0, array73->size*sizeof(unsigned int));\n         DEBUG_NEW(array73->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array73;\n      array_t* array74 = func22(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array74->id);\n      free(params0.data);\n      array74->refC--;\n      if(array74->refC == 0) {\n         free(array74->data);\n         free(array74);\n         DEBUG_FREE(array74->id);\n      }\n      array73->refC--;\n      if(array73->refC == 0) {\n         free(array73->data);\n         free(array73);\n         DEBUG_FREE(array73->id);\n      }\n   }\n   array_t* array75;\n   if (pCounter > 0) {\n      array75 = vars->data[--pCounter];\n      array75->refC++;\n      DEBUG_COPY(array75->id);\n   } else {\n      array75 = (array_t*)malloc(sizeof(array_t));\n      array75->size = 828;\n      array75->refC = 1;\n      array75->id = 75;\n      array75->data = (unsigned int*)malloc(array75->size*sizeof(unsigned int));\n      memset(array75->data, 0, array75->size*sizeof(unsigned int));\n      DEBUG_NEW(array75->id);\n   }\n   return array75;\n}\n\n### File: func15.c\n#include \"array8_19.h\" \narray_t* func15(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array77 = func19(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array77->id);\n   free(params0.data);\n   return array77;\n}\n\n### File: func16.c\n#include \"array8_19.h\" \narray_t* func16(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array7 = func17(&params0, loopsFactor);\n      DEBUG_RETURN(array7->id);\n      free(params0.data);\n      array7->refC--;\n      if(array7->refC == 0) {\n         free(array7->data);\n         free(array7);\n         DEBUG_FREE(array7->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array38 = func18(&params0, loopsFactor);\n      DEBUG_RETURN(array38->id);\n      free(params0.data);\n      array38->refC--;\n      if(array38->refC == 0) {\n         free(array38->data);\n         free(array38);\n         DEBUG_FREE(array38->id);\n      }\n   }\n   array_t* array63;\n   if (pCounter > 0) {\n      array63 = vars->data[--pCounter];\n      array63->refC++;\n      DEBUG_COPY(array63->id);\n   } else {\n      array63 = (array_t*)malloc(sizeof(array_t));\n      array63->size = 613;\n      array63->refC = 1;\n      array63->id = 63;\n      array63->data = (unsigned int*)malloc(array63->size*sizeof(unsigned int));\n      memset(array63->data, 0, array63->size*sizeof(unsigned int));\n      DEBUG_NEW(array63->id);\n   }\n   return array63;\n}\n\n### File: func17.c\n#include \"array8_19.h\" \narray_t* func17(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/3 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      array_t* array8;\n      if (pCounter > 0) {\n         array8 = vars->data[--pCounter];\n         array8->refC++;\n         DEBUG_COPY(array8->id);\n      } else {\n         array8 = (array_t*)malloc(sizeof(array_t));\n         array8->size = 929;\n         array8->refC = 1;\n         array8->id = 8;\n         array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n         memset(array8->data, 0, array8->size*sizeof(unsigned int));\n         DEBUG_NEW(array8->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array8;\n      array_t* array9 = func28(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n      array8->refC--;\n      if(array8->refC == 0) {\n         free(array8->data);\n         free(array8);\n         DEBUG_FREE(array8->id);\n      }\n   }\n   array_t* array37;\n   if (pCounter > 0) {\n      array37 = vars->data[--pCounter];\n      array37->refC++;\n      DEBUG_COPY(array37->id);\n   } else {\n      array37 = (array_t*)malloc(sizeof(array_t));\n      array37->size = 729;\n      array37->refC = 1;\n      array37->id = 37;\n      array37->data = (unsigned int*)malloc(array37->size*sizeof(unsigned int));\n      memset(array37->data, 0, array37->size*sizeof(unsigned int));\n      DEBUG_NEW(array37->id);\n   }\n   return array37;\n}\n\n### File: func18.c\n#include \"array8_19.h\" \narray_t* func18(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array39 = func22(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array39->id);\n   free(params0.data);\n   return array39;\n}\n\n### File: func19.c\n#include \"array8_19.h\" \narray_t* func19(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array78 = func20(&params0, loopsFactor);\n      DEBUG_RETURN(array78->id);\n      free(params0.data);\n      array78->refC--;\n      if(array78->refC == 0) {\n         free(array78->data);\n         free(array78);\n         DEBUG_FREE(array78->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array80 = func21(&params0, loopsFactor);\n      DEBUG_RETURN(array80->id);\n      free(params0.data);\n      array80->refC--;\n      if(array80->refC == 0) {\n         free(array80->data);\n         free(array80);\n         DEBUG_FREE(array80->id);\n      }\n   }\n   array_t* array89;\n   if (pCounter > 0) {\n      array89 = vars->data[--pCounter];\n      array89->refC++;\n      DEBUG_COPY(array89->id);\n   } else {\n      array89 = (array_t*)malloc(sizeof(array_t));\n      array89->size = 163;\n      array89->refC = 1;\n      array89->id = 89;\n      array89->data = (unsigned int*)malloc(array89->size*sizeof(unsigned int));\n      memset(array89->data, 0, array89->size*sizeof(unsigned int));\n      DEBUG_NEW(array89->id);\n   }\n   return array89;\n}\n\n### File: func2.c\n#include \"array8_19.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array93;\n   if (pCounter > 0) {\n      array93 = vars->data[--pCounter];\n      array93->refC++;\n      DEBUG_COPY(array93->id);\n   } else {\n      array93 = (array_t*)malloc(sizeof(array_t));\n      array93->size = 84;\n      array93->refC = 1;\n      array93->id = 93;\n      array93->data = (unsigned int*)malloc(array93->size*sizeof(unsigned int));\n      memset(array93->data, 0, array93->size*sizeof(unsigned int));\n      DEBUG_NEW(array93->id);\n   }\n   unsigned int loop15 = 0;\n   unsigned int loopLimit15 = (rand()%loopsFactor)/2 + 1;\n   for(; loop15 < loopLimit15; loop15++) {\n      for (int i = 0; i < array93->size; i++) {\n         array93->data[i]--;\n      }\n   }\n   return array93;\n}\n\n### File: func20.c\n#include \"array8_19.h\" \narray_t* func20(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array79;\n   if (pCounter > 0) {\n      array79 = vars->data[--pCounter];\n      array79->refC++;\n      DEBUG_COPY(array79->id);\n   } else {\n      array79 = (array_t*)malloc(sizeof(array_t));\n      array79->size = 305;\n      array79->refC = 1;\n      array79->id = 79;\n      array79->data = (unsigned int*)malloc(array79->size*sizeof(unsigned int));\n      memset(array79->data, 0, array79->size*sizeof(unsigned int));\n      DEBUG_NEW(array79->id);\n   }\n   unsigned int loop13 = 0;\n   unsigned int loopLimit13 = (rand()%loopsFactor)/2 + 1;\n   for(; loop13 < loopLimit13; loop13++) {\n      for (int i = 0; i < array79->size; i++) {\n         array79->data[i]--;\n      }\n   }\n   return array79;\n}\n\n### File: func21.c\n#include \"array8_19.h\" \narray_t* func21(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array81 = func25(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array81->id);\n   free(params0.data);\n   return array81;\n}\n\n### File: func22.c\n#include \"array8_19.h\" \narray_t* func22(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array40 = func23(&params0, loopsFactor);\n      DEBUG_RETURN(array40->id);\n      free(params0.data);\n      array40->refC--;\n      if(array40->refC == 0) {\n         free(array40->data);\n         free(array40);\n         DEBUG_FREE(array40->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array42 = func24(&params0, loopsFactor);\n      DEBUG_RETURN(array42->id);\n      free(params0.data);\n      array42->refC--;\n      if(array42->refC == 0) {\n         free(array42->data);\n         free(array42);\n         DEBUG_FREE(array42->id);\n      }\n   }\n   array_t* array62;\n   if (pCounter > 0) {\n      array62 = vars->data[--pCounter];\n      array62->refC++;\n      DEBUG_COPY(array62->id);\n   } else {\n      array62 = (array_t*)malloc(sizeof(array_t));\n      array62->size = 404;\n      array62->refC = 1;\n      array62->id = 62;\n      array62->data = (unsigned int*)malloc(array62->size*sizeof(unsigned int));\n      memset(array62->data, 0, array62->size*sizeof(unsigned int));\n      DEBUG_NEW(array62->id);\n   }\n   return array62;\n}\n\n### File: func23.c\n#include \"array8_19.h\" \narray_t* func23(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array41;\n   if (pCounter > 0) {\n      array41 = vars->data[--pCounter];\n      array41->refC++;\n      DEBUG_COPY(array41->id);\n   } else {\n      array41 = (array_t*)malloc(sizeof(array_t));\n      array41->size = 965;\n      array41->refC = 1;\n      array41->id = 41;\n      array41->data = (unsigned int*)malloc(array41->size*sizeof(unsigned int));\n      memset(array41->data, 0, array41->size*sizeof(unsigned int));\n      DEBUG_NEW(array41->id);\n   }\n   unsigned int loop7 = 0;\n   unsigned int loopLimit7 = (rand()%loopsFactor)/3 + 1;\n   for(; loop7 < loopLimit7; loop7++) {\n      for (int i = 0; i < array41->size; i++) {\n         array41->data[i]--;\n      }\n   }\n   return array41;\n}\n\n### File: func24.c\n#include \"array8_19.h\" \narray_t* func24(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array43 = func31(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array43->id);\n   free(params0.data);\n   return array43;\n}\n\n### File: func25.c\n#include \"array8_19.h\" \narray_t* func25(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array82 = func26(&params0, loopsFactor);\n      DEBUG_RETURN(array82->id);\n      free(params0.data);\n      array82->refC--;\n      if(array82->refC == 0) {\n         free(array82->data);\n         free(array82);\n         DEBUG_FREE(array82->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array86 = func27(&params0, loopsFactor);\n      DEBUG_RETURN(array86->id);\n      free(params0.data);\n      array86->refC--;\n      if(array86->refC == 0) {\n         free(array86->data);\n         free(array86);\n         DEBUG_FREE(array86->id);\n      }\n   }\n   array_t* array88;\n   if (pCounter > 0) {\n      array88 = vars->data[--pCounter];\n      array88->refC++;\n      DEBUG_COPY(array88->id);\n   } else {\n      array88 = (array_t*)malloc(sizeof(array_t));\n      array88->size = 933;\n      array88->refC = 1;\n      array88->id = 88;\n      array88->data = (unsigned int*)malloc(array88->size*sizeof(unsigned int));\n      memset(array88->data, 0, array88->size*sizeof(unsigned int));\n      DEBUG_NEW(array88->id);\n   }\n   return array88;\n}\n\n### File: func26.c\n#include \"array8_19.h\" \narray_t* func26(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop14 = 0;\n   unsigned int loopLimit14 = (rand()%loopsFactor)/2 + 1;\n   for(; loop14 < loopLimit14; loop14++) {\n      array_t* array83;\n      if (pCounter > 0) {\n         array83 = vars->data[--pCounter];\n         array83->refC++;\n         DEBUG_COPY(array83->id);\n      } else {\n         array83 = (array_t*)malloc(sizeof(array_t));\n         array83->size = 600;\n         array83->refC = 1;\n         array83->id = 83;\n         array83->data = (unsigned int*)malloc(array83->size*sizeof(unsigned int));\n         memset(array83->data, 0, array83->size*sizeof(unsigned int));\n         DEBUG_NEW(array83->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array83;\n      array_t* array84 = func37(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array84->id);\n      free(params0.data);\n      array84->refC--;\n      if(array84->refC == 0) {\n         free(array84->data);\n         free(array84);\n         DEBUG_FREE(array84->id);\n      }\n      array83->refC--;\n      if(array83->refC == 0) {\n         free(array83->data);\n         free(array83);\n         DEBUG_FREE(array83->id);\n      }\n   }\n   array_t* array85;\n   if (pCounter > 0) {\n      array85 = vars->data[--pCounter];\n      array85->refC++;\n      DEBUG_COPY(array85->id);\n   } else {\n      array85 = (array_t*)malloc(sizeof(array_t));\n      array85->size = 899;\n      array85->refC = 1;\n      array85->id = 85;\n      array85->data = (unsigned int*)malloc(array85->size*sizeof(unsigned int));\n      memset(array85->data, 0, array85->size*sizeof(unsigned int));\n      DEBUG_NEW(array85->id);\n   }\n   return array85;\n}\n\n### File: func27.c\n#include \"array8_19.h\" \narray_t* func27(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array87 = func28(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array87->id);\n   free(params0.data);\n   return array87;\n}\n\n### File: func28.c\n#include \"array8_19.h\" \narray_t* func28(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array10 = func29(&params0, loopsFactor);\n      DEBUG_RETURN(array10->id);\n      free(params0.data);\n      array10->refC--;\n      if(array10->refC == 0) {\n         free(array10->data);\n         free(array10);\n         DEBUG_FREE(array10->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array12 = func30(&params0, loopsFactor);\n      DEBUG_RETURN(array12->id);\n      free(params0.data);\n      array12->refC--;\n      if(array12->refC == 0) {\n         free(array12->data);\n         free(array12);\n         DEBUG_FREE(array12->id);\n      }\n   }\n   array_t* array36;\n   if (pCounter > 0) {\n      array36 = vars->data[--pCounter];\n      array36->refC++;\n      DEBUG_COPY(array36->id);\n   } else {\n      array36 = (array_t*)malloc(sizeof(array_t));\n      array36->size = 619;\n      array36->refC = 1;\n      array36->id = 36;\n      array36->data = (unsigned int*)malloc(array36->size*sizeof(unsigned int));\n      memset(array36->data, 0, array36->size*sizeof(unsigned int));\n      DEBUG_NEW(array36->id);\n   }\n   return array36;\n}\n\n### File: func29.c\n#include \"array8_19.h\" \narray_t* func29(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array11;\n   if (pCounter > 0) {\n      array11 = vars->data[--pCounter];\n      array11->refC++;\n      DEBUG_COPY(array11->id);\n   } else {\n      array11 = (array_t*)malloc(sizeof(array_t));\n      array11->size = 42;\n      array11->refC = 1;\n      array11->id = 11;\n      array11->data = (unsigned int*)malloc(array11->size*sizeof(unsigned int));\n      memset(array11->data, 0, array11->size*sizeof(unsigned int));\n      DEBUG_NEW(array11->id);\n   }\n   unsigned int loop4 = 0;\n   unsigned int loopLimit4 = (rand()%loopsFactor)/4 + 1;\n   for(; loop4 < loopLimit4; loop4++) {\n      for (int i = 0; i < array11->size; i++) {\n         array11->data[i]--;\n      }\n   }\n   return array11;\n}\n\n### File: func3.c\n#include \"array8_19.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array95 = func7(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array95->id);\n   free(params0.data);\n   return array95;\n}\n\n### File: func30.c\n#include \"array8_19.h\" \narray_t* func30(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array13 = func34(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array13->id);\n   free(params0.data);\n   return array13;\n}\n\n### File: func31.c\n#include \"array8_19.h\" \narray_t* func31(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array44 = func32(&params0, loopsFactor);\n      DEBUG_RETURN(array44->id);\n      free(params0.data);\n      array44->refC--;\n      if(array44->refC == 0) {\n         free(array44->data);\n         free(array44);\n         DEBUG_FREE(array44->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array48 = func33(&params0, loopsFactor);\n      DEBUG_RETURN(array48->id);\n      free(params0.data);\n      array48->refC--;\n      if(array48->refC == 0) {\n         free(array48->data);\n         free(array48);\n         DEBUG_FREE(array48->id);\n      }\n   }\n   array_t* array61;\n   if (pCounter > 0) {\n      array61 = vars->data[--pCounter];\n      array61->refC++;\n      DEBUG_COPY(array61->id);\n   } else {\n      array61 = (array_t*)malloc(sizeof(array_t));\n      array61->size = 928;\n      array61->refC = 1;\n      array61->id = 61;\n      array61->data = (unsigned int*)malloc(array61->size*sizeof(unsigned int));\n      memset(array61->data, 0, array61->size*sizeof(unsigned int));\n      DEBUG_NEW(array61->id);\n   }\n   return array61;\n}\n\n### File: func32.c\n#include \"array8_19.h\" \narray_t* func32(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop8 = 0;\n   unsigned int loopLimit8 = (rand()%loopsFactor)/3 + 1;\n   for(; loop8 < loopLimit8; loop8++) {\n      array_t* array45;\n      if (pCounter > 0) {\n         array45 = vars->data[--pCounter];\n         array45->refC++;\n         DEBUG_COPY(array45->id);\n      } else {\n         array45 = (array_t*)malloc(sizeof(array_t));\n         array45->size = 340;\n         array45->refC = 1;\n         array45->id = 45;\n         array45->data = (unsigned int*)malloc(array45->size*sizeof(unsigned int));\n         memset(array45->data, 0, array45->size*sizeof(unsigned int));\n         DEBUG_NEW(array45->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array45;\n      array_t* array46 = func40(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array46->id);\n      free(params0.data);\n      array46->refC--;\n      if(array46->refC == 0) {\n         free(array46->data);\n         free(array46);\n         DEBUG_FREE(array46->id);\n      }\n      array45->refC--;\n      if(array45->refC == 0) {\n         free(array45->data);\n         free(array45);\n         DEBUG_FREE(array45->id);\n      }\n   }\n   array_t* array47;\n   if (pCounter > 0) {\n      array47 = vars->data[--pCounter];\n      array47->refC++;\n      DEBUG_COPY(array47->id);\n   } else {\n      array47 = (array_t*)malloc(sizeof(array_t));\n      array47->size = 723;\n      array47->refC = 1;\n      array47->id = 47;\n      array47->data = (unsigned int*)malloc(array47->size*sizeof(unsigned int));\n      memset(array47->data, 0, array47->size*sizeof(unsigned int));\n      DEBUG_NEW(array47->id);\n   }\n   return array47;\n}\n\n### File: func33.c\n#include \"array8_19.h\" \narray_t* func33(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array49 = func37(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array49->id);\n   free(params0.data);\n   return array49;\n}\n\n### File: func34.c\n#include \"array8_19.h\" \narray_t* func34(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array14 = func35(&params0, loopsFactor);\n      DEBUG_RETURN(array14->id);\n      free(params0.data);\n      array14->refC--;\n      if(array14->refC == 0) {\n         free(array14->data);\n         free(array14);\n         DEBUG_FREE(array14->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array23 = func36(&params0, loopsFactor);\n      DEBUG_RETURN(array23->id);\n      free(params0.data);\n      array23->refC--;\n      if(array23->refC == 0) {\n         free(array23->data);\n         free(array23);\n         DEBUG_FREE(array23->id);\n      }\n   }\n   array_t* array35;\n   if (pCounter > 0) {\n      array35 = vars->data[--pCounter];\n      array35->refC++;\n      DEBUG_COPY(array35->id);\n   } else {\n      array35 = (array_t*)malloc(sizeof(array_t));\n      array35->size = 865;\n      array35->refC = 1;\n      array35->id = 35;\n      array35->data = (unsigned int*)malloc(array35->size*sizeof(unsigned int));\n      memset(array35->data, 0, array35->size*sizeof(unsigned int));\n      DEBUG_NEW(array35->id);\n   }\n   return array35;\n}\n\n### File: func35.c\n#include \"array8_19.h\" \narray_t* func35(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop5 = 0;\n   unsigned int loopLimit5 = (rand()%loopsFactor)/4 + 1;\n   for(; loop5 < loopLimit5; loop5++) {\n      array_t* array15;\n      if (pCounter > 0) {\n         array15 = vars->data[--pCounter];\n         array15->refC++;\n         DEBUG_COPY(array15->id);\n      } else {\n         array15 = (array_t*)malloc(sizeof(array_t));\n         array15->size = 956;\n         array15->refC = 1;\n         array15->id = 15;\n         array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n         memset(array15->data, 0, array15->size*sizeof(unsigned int));\n         DEBUG_NEW(array15->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array15;\n      array_t* array16 = func46(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array16->id);\n      free(params0.data);\n      array16->refC--;\n      if(array16->refC == 0) {\n         free(array16->data);\n         free(array16);\n         DEBUG_FREE(array16->id);\n      }\n      array15->refC--;\n      if(array15->refC == 0) {\n         free(array15->data);\n         free(array15);\n         DEBUG_FREE(array15->id);\n      }\n   }\n   array_t* array22;\n   if (pCounter > 0) {\n      array22 = vars->data[--pCounter];\n      array22->refC++;\n      DEBUG_COPY(array22->id);\n   } else {\n      array22 = (array_t*)malloc(sizeof(array_t));\n      array22->size = 545;\n      array22->refC = 1;\n      array22->id = 22;\n      array22->data = (unsigned int*)malloc(array22->size*sizeof(unsigned int));\n      memset(array22->data, 0, array22->size*sizeof(unsigned int));\n      DEBUG_NEW(array22->id);\n   }\n   return array22;\n}\n\n### File: func36.c\n#include \"array8_19.h\" \narray_t* func36(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array24 = func40(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array24->id);\n   free(params0.data);\n   return array24;\n}\n\n### File: func37.c\n#include \"array8_19.h\" \narray_t* func37(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array50 = func38(&params0, loopsFactor);\n      DEBUG_RETURN(array50->id);\n      free(params0.data);\n      array50->refC--;\n      if(array50->refC == 0) {\n         free(array50->data);\n         free(array50);\n         DEBUG_FREE(array50->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array52 = func39(&params0, loopsFactor);\n      DEBUG_RETURN(array52->id);\n      free(params0.data);\n      array52->refC--;\n      if(array52->refC == 0) {\n         free(array52->data);\n         free(array52);\n         DEBUG_FREE(array52->id);\n      }\n   }\n   array_t* array60;\n   if (pCounter > 0) {\n      array60 = vars->data[--pCounter];\n      array60->refC++;\n      DEBUG_COPY(array60->id);\n   } else {\n      array60 = (array_t*)malloc(sizeof(array_t));\n      array60->size = 428;\n      array60->refC = 1;\n      array60->id = 60;\n      array60->data = (unsigned int*)malloc(array60->size*sizeof(unsigned int));\n      memset(array60->data, 0, array60->size*sizeof(unsigned int));\n      DEBUG_NEW(array60->id);\n   }\n   return array60;\n}\n\n### File: func38.c\n#include \"array8_19.h\" \narray_t* func38(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array51;\n   if (pCounter > 0) {\n      array51 = vars->data[--pCounter];\n      array51->refC++;\n      DEBUG_COPY(array51->id);\n   } else {\n      array51 = (array_t*)malloc(sizeof(array_t));\n      array51->size = 500;\n      array51->refC = 1;\n      array51->id = 51;\n      array51->data = (unsigned int*)malloc(array51->size*sizeof(unsigned int));\n      memset(array51->data, 0, array51->size*sizeof(unsigned int));\n      DEBUG_NEW(array51->id);\n   }\n   unsigned int loop9 = 0;\n   unsigned int loopLimit9 = (rand()%loopsFactor)/3 + 1;\n   for(; loop9 < loopLimit9; loop9++) {\n      for (int i = 0; i < array51->size; i++) {\n         array51->data[i]--;\n      }\n   }\n   return array51;\n}\n\n### File: func39.c\n#include \"array8_19.h\" \narray_t* func39(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array53 = func43(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array53->id);\n   free(params0.data);\n   return array53;\n}\n\n### File: func4.c\n#include \"array8_19.h\" \narray_t* func4(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array68 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array68->id);\n      free(params0.data);\n      array68->refC--;\n      if(array68->refC == 0) {\n         free(array68->data);\n         free(array68);\n         DEBUG_FREE(array68->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array70 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array70->id);\n      free(params0.data);\n      array70->refC--;\n      if(array70->refC == 0) {\n         free(array70->data);\n         free(array70);\n         DEBUG_FREE(array70->id);\n      }\n   }\n   array_t* array91;\n   if (pCounter > 0) {\n      array91 = vars->data[--pCounter];\n      array91->refC++;\n      DEBUG_COPY(array91->id);\n   } else {\n      array91 = (array_t*)malloc(sizeof(array_t));\n      array91->size = 773;\n      array91->refC = 1;\n      array91->id = 91;\n      array91->data = (unsigned int*)malloc(array91->size*sizeof(unsigned int));\n      memset(array91->data, 0, array91->size*sizeof(unsigned int));\n      DEBUG_NEW(array91->id);\n   }\n   return array91;\n}\n\n### File: func40.c\n#include \"array8_19.h\" \narray_t* func40(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array25 = func41(&params0, loopsFactor);\n      DEBUG_RETURN(array25->id);\n      free(params0.data);\n      array25->refC--;\n      if(array25->refC == 0) {\n         free(array25->data);\n         free(array25);\n         DEBUG_FREE(array25->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array27 = func42(&params0, loopsFactor);\n      DEBUG_RETURN(array27->id);\n      free(params0.data);\n      array27->refC--;\n      if(array27->refC == 0) {\n         free(array27->data);\n         free(array27);\n         DEBUG_FREE(array27->id);\n      }\n   }\n   array_t* array34;\n   if (pCounter > 0) {\n      array34 = vars->data[--pCounter];\n      array34->refC++;\n      DEBUG_COPY(array34->id);\n   } else {\n      array34 = (array_t*)malloc(sizeof(array_t));\n      array34->size = 280;\n      array34->refC = 1;\n      array34->id = 34;\n      array34->data = (unsigned int*)malloc(array34->size*sizeof(unsigned int));\n      memset(array34->data, 0, array34->size*sizeof(unsigned int));\n      DEBUG_NEW(array34->id);\n   }\n   return array34;\n}\n\n### File: func41.c\n#include \"array8_19.h\" \narray_t* func41(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array26;\n   if (pCounter > 0) {\n      array26 = vars->data[--pCounter];\n      array26->refC++;\n      DEBUG_COPY(array26->id);\n   } else {\n      array26 = (array_t*)malloc(sizeof(array_t));\n      array26->size = 651;\n      array26->refC = 1;\n      array26->id = 26;\n      array26->data = (unsigned int*)malloc(array26->size*sizeof(unsigned int));\n      memset(array26->data, 0, array26->size*sizeof(unsigned int));\n      DEBUG_NEW(array26->id);\n   }\n   unsigned int loop6 = 0;\n   unsigned int loopLimit6 = (rand()%loopsFactor)/4 + 1;\n   for(; loop6 < loopLimit6; loop6++) {\n      for (int i = 0; i < array26->size; i++) {\n         array26->data[i]--;\n      }\n   }\n   return array26;\n}\n\n### File: func42.c\n#include \"array8_19.h\" \narray_t* func42(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array28 = func49(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array28->id);\n   free(params0.data);\n   return array28;\n}\n\n### File: func43.c\n#include \"array8_19.h\" \narray_t* func43(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array54 = func44(&params0, loopsFactor);\n      DEBUG_RETURN(array54->id);\n      free(params0.data);\n      array54->refC--;\n      if(array54->refC == 0) {\n         free(array54->data);\n         free(array54);\n         DEBUG_FREE(array54->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array57 = func45(&params0, loopsFactor);\n      DEBUG_RETURN(array57->id);\n      free(params0.data);\n      array57->refC--;\n      if(array57->refC == 0) {\n         free(array57->data);\n         free(array57);\n         DEBUG_FREE(array57->id);\n      }\n   }\n   array_t* array59;\n   if (pCounter > 0) {\n      array59 = vars->data[--pCounter];\n      array59->refC++;\n      DEBUG_COPY(array59->id);\n   } else {\n      array59 = (array_t*)malloc(sizeof(array_t));\n      array59->size = 235;\n      array59->refC = 1;\n      array59->id = 59;\n      array59->data = (unsigned int*)malloc(array59->size*sizeof(unsigned int));\n      memset(array59->data, 0, array59->size*sizeof(unsigned int));\n      DEBUG_NEW(array59->id);\n   }\n   return array59;\n}\n\n### File: func44.c\n#include \"array8_19.h\" \narray_t* func44(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop10 = 0;\n   unsigned int loopLimit10 = (rand()%loopsFactor)/3 + 1;\n   for(; loop10 < loopLimit10; loop10++) {\n      array_t* array55;\n      if (pCounter > 0) {\n         array55 = vars->data[--pCounter];\n         array55->refC++;\n         DEBUG_COPY(array55->id);\n      } else {\n         array55 = (array_t*)malloc(sizeof(array_t));\n         array55->size = 437;\n         array55->refC = 1;\n         array55->id = 55;\n         array55->data = (unsigned int*)malloc(array55->size*sizeof(unsigned int));\n         memset(array55->data, 0, array55->size*sizeof(unsigned int));\n         DEBUG_NEW(array55->id);\n      }\n      array55->refC--;\n      if(array55->refC == 0) {\n         free(array55->data);\n         free(array55);\n         DEBUG_FREE(array55->id);\n      }\n   }\n   array_t* array56;\n   if (pCounter > 0) {\n      array56 = vars->data[--pCounter];\n      array56->refC++;\n      DEBUG_COPY(array56->id);\n   } else {\n      array56 = (array_t*)malloc(sizeof(array_t));\n      array56->size = 228;\n      array56->refC = 1;\n      array56->id = 56;\n      array56->data = (unsigned int*)malloc(array56->size*sizeof(unsigned int));\n      memset(array56->data, 0, array56->size*sizeof(unsigned int));\n      DEBUG_NEW(array56->id);\n   }\n   return array56;\n}\n\n### File: func45.c\n#include \"array8_19.h\" \narray_t* func45(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array58 = func46(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array58->id);\n   free(params0.data);\n   return array58;\n}\n\n### File: func46.c\n#include \"array8_19.h\" \narray_t* func46(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array17 = func47(&params0, loopsFactor);\n      DEBUG_RETURN(array17->id);\n      free(params0.data);\n      array17->refC--;\n      if(array17->refC == 0) {\n         free(array17->data);\n         free(array17);\n         DEBUG_FREE(array17->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array19 = func48(&params0, loopsFactor);\n      DEBUG_RETURN(array19->id);\n      free(params0.data);\n      array19->refC--;\n      if(array19->refC == 0) {\n         free(array19->data);\n         free(array19);\n         DEBUG_FREE(array19->id);\n      }\n   }\n   array_t* array21;\n   if (pCounter > 0) {\n      array21 = vars->data[--pCounter];\n      array21->refC++;\n      DEBUG_COPY(array21->id);\n   } else {\n      array21 = (array_t*)malloc(sizeof(array_t));\n      array21->size = 895;\n      array21->refC = 1;\n      array21->id = 21;\n      array21->data = (unsigned int*)malloc(array21->size*sizeof(unsigned int));\n      memset(array21->data, 0, array21->size*sizeof(unsigned int));\n      DEBUG_NEW(array21->id);\n   }\n   return array21;\n}\n\n### File: func47.c\n#include \"array8_19.h\" \narray_t* func47(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array18;\n   if (pCounter > 0) {\n      array18 = vars->data[--pCounter];\n      array18->refC++;\n      DEBUG_COPY(array18->id);\n   } else {\n      array18 = (array_t*)malloc(sizeof(array_t));\n      array18->size = 327;\n      array18->refC = 1;\n      array18->id = 18;\n      array18->data = (unsigned int*)malloc(array18->size*sizeof(unsigned int));\n      memset(array18->data, 0, array18->size*sizeof(unsigned int));\n      DEBUG_NEW(array18->id);\n   }\n   return array18;\n}\n\n### File: func48.c\n#include \"array8_19.h\" \narray_t* func48(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array20;\n   if (pCounter > 0) {\n      array20 = vars->data[--pCounter];\n      array20->refC++;\n      DEBUG_COPY(array20->id);\n   } else {\n      array20 = (array_t*)malloc(sizeof(array_t));\n      array20->size = 857;\n      array20->refC = 1;\n      array20->id = 20;\n      array20->data = (unsigned int*)malloc(array20->size*sizeof(unsigned int));\n      memset(array20->data, 0, array20->size*sizeof(unsigned int));\n      DEBUG_NEW(array20->id);\n   }\n   return array20;\n}\n\n### File: func49.c\n#include \"array8_19.h\" \narray_t* func49(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array29 = func50(&params0, loopsFactor);\n      DEBUG_RETURN(array29->id);\n      free(params0.data);\n      array29->refC--;\n      if(array29->refC == 0) {\n         free(array29->data);\n         free(array29);\n         DEBUG_FREE(array29->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array31 = func51(&params0, loopsFactor);\n      DEBUG_RETURN(array31->id);\n      free(params0.data);\n      array31->refC--;\n      if(array31->refC == 0) {\n         free(array31->data);\n         free(array31);\n         DEBUG_FREE(array31->id);\n      }\n   }\n   array_t* array33;\n   if (pCounter > 0) {\n      array33 = vars->data[--pCounter];\n      array33->refC++;\n      DEBUG_COPY(array33->id);\n   } else {\n      array33 = (array_t*)malloc(sizeof(array_t));\n      array33->size = 652;\n      array33->refC = 1;\n      array33->id = 33;\n      array33->data = (unsigned int*)malloc(array33->size*sizeof(unsigned int));\n      memset(array33->data, 0, array33->size*sizeof(unsigned int));\n      DEBUG_NEW(array33->id);\n   }\n   return array33;\n}\n\n### File: func5.c\n#include \"array8_19.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array69;\n   if (pCounter > 0) {\n      array69 = vars->data[--pCounter];\n      array69->refC++;\n      DEBUG_COPY(array69->id);\n   } else {\n      array69 = (array_t*)malloc(sizeof(array_t));\n      array69->size = 725;\n      array69->refC = 1;\n      array69->id = 69;\n      array69->data = (unsigned int*)malloc(array69->size*sizeof(unsigned int));\n      memset(array69->data, 0, array69->size*sizeof(unsigned int));\n      DEBUG_NEW(array69->id);\n   }\n   unsigned int loop11 = 0;\n   unsigned int loopLimit11 = (rand()%loopsFactor)/2 + 1;\n   for(; loop11 < loopLimit11; loop11++) {\n      for (int i = 0; i < array69->size; i++) {\n         array69->data[i]--;\n      }\n   }\n   return array69;\n}\n\n### File: func50.c\n#include \"array8_19.h\" \narray_t* func50(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array30;\n   if (pCounter > 0) {\n      array30 = vars->data[--pCounter];\n      array30->refC++;\n      DEBUG_COPY(array30->id);\n   } else {\n      array30 = (array_t*)malloc(sizeof(array_t));\n      array30->size = 434;\n      array30->refC = 1;\n      array30->id = 30;\n      array30->data = (unsigned int*)malloc(array30->size*sizeof(unsigned int));\n      memset(array30->data, 0, array30->size*sizeof(unsigned int));\n      DEBUG_NEW(array30->id);\n   }\n   return array30;\n}\n\n### File: func51.c\n#include \"array8_19.h\" \narray_t* func51(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array32;\n   if (pCounter > 0) {\n      array32 = vars->data[--pCounter];\n      array32->refC++;\n      DEBUG_COPY(array32->id);\n   } else {\n      array32 = (array_t*)malloc(sizeof(array_t));\n      array32->size = 317;\n      array32->refC = 1;\n      array32->id = 32;\n      array32->data = (unsigned int*)malloc(array32->size*sizeof(unsigned int));\n      memset(array32->data, 0, array32->size*sizeof(unsigned int));\n      DEBUG_NEW(array32->id);\n   }\n   return array32;\n}\n\n### File: func6.c\n#include \"array8_19.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array71 = func13(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array71->id);\n   free(params0.data);\n   return array71;\n}\n\n### File: func7.c\n#include \"array8_19.h\" \narray_t* func7(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array96 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array96->id);\n      free(params0.data);\n      array96->refC--;\n      if(array96->refC == 0) {\n         free(array96->data);\n         free(array96);\n         DEBUG_FREE(array96->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array100 = func9(&params0, loopsFactor);\n      DEBUG_RETURN(array100->id);\n      free(params0.data);\n      array100->refC--;\n      if(array100->refC == 0) {\n         free(array100->data);\n         free(array100);\n         DEBUG_FREE(array100->id);\n      }\n   }\n   array_t* array102;\n   if (pCounter > 0) {\n      array102 = vars->data[--pCounter];\n      array102->refC++;\n      DEBUG_COPY(array102->id);\n   } else {\n      array102 = (array_t*)malloc(sizeof(array_t));\n      array102->size = 255;\n      array102->refC = 1;\n      array102->id = 102;\n      array102->data = (unsigned int*)malloc(array102->size*sizeof(unsigned int));\n      memset(array102->data, 0, array102->size*sizeof(unsigned int));\n      DEBUG_NEW(array102->id);\n   }\n   return array102;\n}\n\n### File: func8.c\n#include \"array8_19.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop16 = 0;\n   unsigned int loopLimit16 = (rand()%loopsFactor)/2 + 1;\n   for(; loop16 < loopLimit16; loop16++) {\n      array_t* array97;\n      if (pCounter > 0) {\n         array97 = vars->data[--pCounter];\n         array97->refC++;\n         DEBUG_COPY(array97->id);\n      } else {\n         array97 = (array_t*)malloc(sizeof(array_t));\n         array97->size = 172;\n         array97->refC = 1;\n         array97->id = 97;\n         array97->data = (unsigned int*)malloc(array97->size*sizeof(unsigned int));\n         memset(array97->data, 0, array97->size*sizeof(unsigned int));\n         DEBUG_NEW(array97->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array97;\n      array_t* array98 = func19(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array98->id);\n      free(params0.data);\n      array98->refC--;\n      if(array98->refC == 0) {\n         free(array98->data);\n         free(array98);\n         DEBUG_FREE(array98->id);\n      }\n      array97->refC--;\n      if(array97->refC == 0) {\n         free(array97->data);\n         free(array97);\n         DEBUG_FREE(array97->id);\n      }\n   }\n   array_t* array99;\n   if (pCounter > 0) {\n      array99 = vars->data[--pCounter];\n      array99->refC++;\n      DEBUG_COPY(array99->id);\n   } else {\n      array99 = (array_t*)malloc(sizeof(array_t));\n      array99->size = 336;\n      array99->refC = 1;\n      array99->id = 99;\n      array99->data = (unsigned int*)malloc(array99->size*sizeof(unsigned int));\n      memset(array99->data, 0, array99->size*sizeof(unsigned int));\n      DEBUG_NEW(array99->id);\n   }\n   return array99;\n}\n\n### File: func9.c\n#include \"array8_19.h\" \narray_t* func9(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array101 = func10(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array101->id);\n   free(params0.data);\n   return array101;\n}\n\n### File: rng.c\n#include \"array8_19.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1529369\n    - Instructions: 1129018\n    - Cache References: 79802\n    - Cache Misses: 19128\n    - Branch Instructions: 208767\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist14_2.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist14_2.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist14_2.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist14_2.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist14_2.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist14_2.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist14_2.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist14_2.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist14_2.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist14_2.c\n#include \"sortedlist14_2.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist14_2.h\n#ifndef sortedlist14_2\n#define sortedlist14_2\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 15124242\n    - Instructions: 28285886\n    - Cache References: 140535\n    - Cache Misses: 44789\n    - Branch Instructions: 5459510\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func10(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell5 = sortedlist2->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell6 = sortedlist1->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist13;\n   if (pCounter > 0) {\n      sortedlist13 = vars->data[--pCounter];\n      sortedlist13->refC++;\n      DEBUG_COPY(sortedlist13->id);\n   } else {\n      sortedlist13 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist13->refC = 1;\n      sortedlist13->id = 13;\n      sortedlist13->n = 0;\n      sortedlist13->root = NULL;\n      DEBUG_NEW(sortedlist13->id);\n   }\n   return sortedlist13;\n}\n\n### File: func1.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist15 = func4(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist15->id);\n   free(params0.data);\n   return sortedlist15;\n}\n\n### File: func10.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func10(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func11(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell1 = sortedlist3->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func12(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell4 = sortedlist5->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func11.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func11(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist4 != NULL && sortedlist4->n > 0)\n      {\n          cell_t* cell0 = sortedlist4->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist4->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist4->n--;\n              }\n           }\n      }\n   }\n   return sortedlist4;\n}\n\n### File: func12.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func12(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist6 = func16(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist6->id);\n   free(params0.data);\n   return sortedlist6;\n}\n\n### File: func13.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func13(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist20 = func14(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist20->id);\n      free(params0.data);\n      sortedlist20->refC--;\n      if(sortedlist20->refC == 0){\n           cell_t* cell11 = sortedlist20->root;\n           cell_t* tmp11  = NULL;\n           while(cell11 != NULL) {\n               tmp11 = cell11->next;\n               free(cell11);\n               cell11 = tmp11;\n           }\n           free(sortedlist20);\n           DEBUG_FREE(sortedlist20->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist23 = func15(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist23->id);\n      free(params0.data);\n      sortedlist23->refC--;\n      if(sortedlist23->refC == 0){\n           cell_t* cell14 = sortedlist23->root;\n           cell_t* tmp14  = NULL;\n           while(cell14 != NULL) {\n               tmp14 = cell14->next;\n               free(cell14);\n               cell14 = tmp14;\n           }\n           free(sortedlist23);\n           DEBUG_FREE(sortedlist23->id);\n      }\n   }\n   sortedlist_t* sortedlist30;\n   if (pCounter > 0) {\n      sortedlist30 = vars->data[--pCounter];\n      sortedlist30->refC++;\n      DEBUG_COPY(sortedlist30->id);\n   } else {\n      sortedlist30 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist30->refC = 1;\n      sortedlist30->id = 30;\n      sortedlist30->n = 0;\n      sortedlist30->root = NULL;\n      DEBUG_NEW(sortedlist30->id);\n   }\n   return sortedlist30;\n}\n\n### File: func14.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func14(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop4 = 0;\n   unsigned int loopLimit4 = (rand()%loopsFactor)/2 + 1;\n   for(; loop4 < loopLimit4; loop4++) {\n      sortedlist_t* sortedlist21;\n      if (pCounter > 0) {\n         sortedlist21 = vars->data[--pCounter];\n         sortedlist21->refC++;\n         DEBUG_COPY(sortedlist21->id);\n      } else {\n         sortedlist21 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist21->refC = 1;\n         sortedlist21->id = 21;\n         sortedlist21->n = 0;\n         sortedlist21->root = NULL;\n         DEBUG_NEW(sortedlist21->id);\n      }\n      sortedlist21->refC--;\n      if(sortedlist21->refC == 0){\n           cell_t* cell10 = sortedlist21->root;\n           cell_t* tmp10  = NULL;\n           while(cell10 != NULL) {\n               tmp10 = cell10->next;\n               free(cell10);\n               cell10 = tmp10;\n           }\n           free(sortedlist21);\n           DEBUG_FREE(sortedlist21->id);\n      }\n   }\n   sortedlist_t* sortedlist22;\n   if (pCounter > 0) {\n      sortedlist22 = vars->data[--pCounter];\n      sortedlist22->refC++;\n      DEBUG_COPY(sortedlist22->id);\n   } else {\n      sortedlist22 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist22->refC = 1;\n      sortedlist22->id = 22;\n      sortedlist22->n = 0;\n      sortedlist22->root = NULL;\n      DEBUG_NEW(sortedlist22->id);\n   }\n   return sortedlist22;\n}\n\n### File: func15.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func15(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist24 = func19(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist24->id);\n   free(params0.data);\n   return sortedlist24;\n}\n\n### File: func16.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func16(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist7 = func17(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist7->id);\n      free(params0.data);\n      sortedlist7->refC--;\n      if(sortedlist7->refC == 0){\n           cell_t* cell2 = sortedlist7->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist7);\n           DEBUG_FREE(sortedlist7->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func18(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell3 = sortedlist9->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   sortedlist_t* sortedlist11;\n   if (pCounter > 0) {\n      sortedlist11 = vars->data[--pCounter];\n      sortedlist11->refC++;\n      DEBUG_COPY(sortedlist11->id);\n   } else {\n      sortedlist11 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist11->refC = 1;\n      sortedlist11->id = 11;\n      sortedlist11->n = 0;\n      sortedlist11->root = NULL;\n      DEBUG_NEW(sortedlist11->id);\n   }\n   return sortedlist11;\n}\n\n### File: func17.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func17(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func18.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func18(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist10;\n   if (pCounter > 0) {\n      sortedlist10 = vars->data[--pCounter];\n      sortedlist10->refC++;\n      DEBUG_COPY(sortedlist10->id);\n   } else {\n      sortedlist10 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist10->refC = 1;\n      sortedlist10->id = 10;\n      sortedlist10->n = 0;\n      sortedlist10->root = NULL;\n      DEBUG_NEW(sortedlist10->id);\n   }\n   return sortedlist10;\n}\n\n### File: func19.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func19(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist25 = func20(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist25->id);\n      free(params0.data);\n      sortedlist25->refC--;\n      if(sortedlist25->refC == 0){\n           cell_t* cell12 = sortedlist25->root;\n           cell_t* tmp12  = NULL;\n           while(cell12 != NULL) {\n               tmp12 = cell12->next;\n               free(cell12);\n               cell12 = tmp12;\n           }\n           free(sortedlist25);\n           DEBUG_FREE(sortedlist25->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist27 = func21(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist27->id);\n      free(params0.data);\n      sortedlist27->refC--;\n      if(sortedlist27->refC == 0){\n           cell_t* cell13 = sortedlist27->root;\n           cell_t* tmp13  = NULL;\n           while(cell13 != NULL) {\n               tmp13 = cell13->next;\n               free(cell13);\n               cell13 = tmp13;\n           }\n           free(sortedlist27);\n           DEBUG_FREE(sortedlist27->id);\n      }\n   }\n   sortedlist_t* sortedlist29;\n   if (pCounter > 0) {\n      sortedlist29 = vars->data[--pCounter];\n      sortedlist29->refC++;\n      DEBUG_COPY(sortedlist29->id);\n   } else {\n      sortedlist29 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist29->refC = 1;\n      sortedlist29->id = 29;\n      sortedlist29->n = 0;\n      sortedlist29->root = NULL;\n      DEBUG_NEW(sortedlist29->id);\n   }\n   return sortedlist29;\n}\n\n### File: func2.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist33;\n   if (pCounter > 0) {\n      sortedlist33 = vars->data[--pCounter];\n      sortedlist33->refC++;\n      DEBUG_COPY(sortedlist33->id);\n   } else {\n      sortedlist33 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist33->refC = 1;\n      sortedlist33->id = 33;\n      sortedlist33->n = 0;\n      sortedlist33->root = NULL;\n      DEBUG_NEW(sortedlist33->id);\n   }\n   unsigned int loop5 = 0;\n   unsigned int loopLimit5 = (rand()%loopsFactor)/2 + 1;\n   for(; loop5 < loopLimit5; loop5++) {\n      if(sortedlist33 != NULL && sortedlist33->n > 0)\n      {\n          cell_t* cell17 = sortedlist33->root;\n          if(cell17->val == 67)\n          {\n              cell17 = cell17->next;\n              sortedlist33->n--;\n          }else{\n              while(cell17->next != NULL && cell17->next->val != 67) cell17 = cell17->next;\n              if(cell17->next != NULL)\n              {\n                  cell17 = cell17->next->next;\n                  sortedlist33->n--;\n              }\n           }\n      }\n   }\n   return sortedlist33;\n}\n\n### File: func20.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func20(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist26;\n   if (pCounter > 0) {\n      sortedlist26 = vars->data[--pCounter];\n      sortedlist26->refC++;\n      DEBUG_COPY(sortedlist26->id);\n   } else {\n      sortedlist26 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist26->refC = 1;\n      sortedlist26->id = 26;\n      sortedlist26->n = 0;\n      sortedlist26->root = NULL;\n      DEBUG_NEW(sortedlist26->id);\n   }\n   return sortedlist26;\n}\n\n### File: func21.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func21(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist28;\n   if (pCounter > 0) {\n      sortedlist28 = vars->data[--pCounter];\n      sortedlist28->refC++;\n      DEBUG_COPY(sortedlist28->id);\n   } else {\n      sortedlist28 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist28->refC = 1;\n      sortedlist28->id = 28;\n      sortedlist28->n = 0;\n      sortedlist28->root = NULL;\n      DEBUG_NEW(sortedlist28->id);\n   }\n   return sortedlist28;\n}\n\n### File: func3.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist35 = func7(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist35->id);\n   free(params0.data);\n   return sortedlist35;\n}\n\n### File: func4.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist16 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist16->id);\n      free(params0.data);\n      sortedlist16->refC--;\n      if(sortedlist16->refC == 0){\n           cell_t* cell9 = sortedlist16->root;\n           cell_t* tmp9  = NULL;\n           while(cell9 != NULL) {\n               tmp9 = cell9->next;\n               free(cell9);\n               cell9 = tmp9;\n           }\n           free(sortedlist16);\n           DEBUG_FREE(sortedlist16->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist18 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist18->id);\n      free(params0.data);\n      sortedlist18->refC--;\n      if(sortedlist18->refC == 0){\n           cell_t* cell15 = sortedlist18->root;\n           cell_t* tmp15  = NULL;\n           while(cell15 != NULL) {\n               tmp15 = cell15->next;\n               free(cell15);\n               cell15 = tmp15;\n           }\n           free(sortedlist18);\n           DEBUG_FREE(sortedlist18->id);\n      }\n   }\n   sortedlist_t* sortedlist31;\n   if (pCounter > 0) {\n      sortedlist31 = vars->data[--pCounter];\n      sortedlist31->refC++;\n      DEBUG_COPY(sortedlist31->id);\n   } else {\n      sortedlist31 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist31->refC = 1;\n      sortedlist31->id = 31;\n      sortedlist31->n = 0;\n      sortedlist31->root = NULL;\n      DEBUG_NEW(sortedlist31->id);\n   }\n   return sortedlist31;\n}\n\n### File: func5.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/2 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      if(sortedlist17 != NULL && sortedlist17->n > 0)\n      {\n          cell_t* cell8 = sortedlist17->root;\n          if(cell8->val == 62)\n          {\n              cell8 = cell8->next;\n              sortedlist17->n--;\n          }else{\n              while(cell8->next != NULL && cell8->next->val != 62) cell8 = cell8->next;\n              if(cell8->next != NULL)\n              {\n                  cell8 = cell8->next->next;\n                  sortedlist17->n--;\n              }\n           }\n      }\n   }\n   return sortedlist17;\n}\n\n### File: func6.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist19 = func13(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist19->id);\n   free(params0.data);\n   return sortedlist19;\n}\n\n### File: func7.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist36 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist36->id);\n      free(params0.data);\n      sortedlist36->refC--;\n      if(sortedlist36->refC == 0){\n           cell_t* cell21 = sortedlist36->root;\n           cell_t* tmp21  = NULL;\n           while(cell21 != NULL) {\n               tmp21 = cell21->next;\n               free(cell21);\n               cell21 = tmp21;\n           }\n           free(sortedlist36);\n           DEBUG_FREE(sortedlist36->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist40 = func9(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist40->id);\n      free(params0.data);\n      sortedlist40->refC--;\n      if(sortedlist40->refC == 0){\n           cell_t* cell22 = sortedlist40->root;\n           cell_t* tmp22  = NULL;\n           while(cell22 != NULL) {\n               tmp22 = cell22->next;\n               free(cell22);\n               cell22 = tmp22;\n           }\n           free(sortedlist40);\n           DEBUG_FREE(sortedlist40->id);\n      }\n   }\n   sortedlist_t* sortedlist42;\n   if (pCounter > 0) {\n      sortedlist42 = vars->data[--pCounter];\n      sortedlist42->refC++;\n      DEBUG_COPY(sortedlist42->id);\n   } else {\n      sortedlist42 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist42->refC = 1;\n      sortedlist42->id = 42;\n      sortedlist42->n = 0;\n      sortedlist42->root = NULL;\n      DEBUG_NEW(sortedlist42->id);\n   }\n   return sortedlist42;\n}\n\n### File: func8.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop6 = 0;\n   unsigned int loopLimit6 = (rand()%loopsFactor)/2 + 1;\n   for(; loop6 < loopLimit6; loop6++) {\n      sortedlist_t* sortedlist37;\n      if (pCounter > 0) {\n         sortedlist37 = vars->data[--pCounter];\n         sortedlist37->refC++;\n         DEBUG_COPY(sortedlist37->id);\n      } else {\n         sortedlist37 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist37->refC = 1;\n         sortedlist37->id = 37;\n         sortedlist37->n = 0;\n         sortedlist37->root = NULL;\n         DEBUG_NEW(sortedlist37->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist37;\n      sortedlist_t* sortedlist38 = func19(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist38->id);\n      free(params0.data);\n      sortedlist38->refC--;\n      if(sortedlist38->refC == 0){\n           cell_t* cell19 = sortedlist38->root;\n           cell_t* tmp19  = NULL;\n           while(cell19 != NULL) {\n               tmp19 = cell19->next;\n               free(cell19);\n               cell19 = tmp19;\n           }\n           free(sortedlist38);\n           DEBUG_FREE(sortedlist38->id);\n      }\n      sortedlist37->refC--;\n      if(sortedlist37->refC == 0){\n           cell_t* cell20 = sortedlist37->root;\n           cell_t* tmp20  = NULL;\n           while(cell20 != NULL) {\n               tmp20 = cell20->next;\n               free(cell20);\n               cell20 = tmp20;\n           }\n           free(sortedlist37);\n           DEBUG_FREE(sortedlist37->id);\n      }\n   }\n   sortedlist_t* sortedlist39;\n   if (pCounter > 0) {\n      sortedlist39 = vars->data[--pCounter];\n      sortedlist39->refC++;\n      DEBUG_COPY(sortedlist39->id);\n   } else {\n      sortedlist39 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist39->refC = 1;\n      sortedlist39->id = 39;\n      sortedlist39->n = 0;\n      sortedlist39->root = NULL;\n      DEBUG_NEW(sortedlist39->id);\n   }\n   return sortedlist39;\n}\n\n### File: func9.c\n#include \"sortedlist3_19.h\" \nsortedlist_t* func9(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist41 = func10(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist41->id);\n   free(params0.data);\n   return sortedlist41;\n}\n\n### File: rng.c\n#include \"sortedlist3_19.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist3_19.c\n#include \"sortedlist3_19.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell7 = sortedlist0->root;\n              cell_t* tmp7  = NULL;\n              while(cell7 != NULL) {\n                  tmp7 = cell7->next;\n                  free(cell7);\n                  cell7 = tmp7;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist14 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist14->id);\n         free(params0.data);\n         sortedlist14->refC--;\n         if(sortedlist14->refC == 0){\n              cell_t* cell16 = sortedlist14->root;\n              cell_t* tmp16  = NULL;\n              while(cell16 != NULL) {\n                  tmp16 = cell16->next;\n                  free(cell16);\n                  cell16 = tmp16;\n              }\n              free(sortedlist14);\n              DEBUG_FREE(sortedlist14->id);\n         }\n      }\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist32 = func2(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist32->id);\n         free(params0.data);\n         sortedlist32->refC--;\n         if(sortedlist32->refC == 0){\n              cell_t* cell18 = sortedlist32->root;\n              cell_t* tmp18  = NULL;\n              while(cell18 != NULL) {\n                  tmp18 = cell18->next;\n                  free(cell18);\n                  cell18 = tmp18;\n              }\n              free(sortedlist32);\n              DEBUG_FREE(sortedlist32->id);\n         }\n      }\n      else {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist34 = func3(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist34->id);\n         free(params0.data);\n         sortedlist34->refC--;\n         if(sortedlist34->refC == 0){\n              cell_t* cell23 = sortedlist34->root;\n              cell_t* tmp23  = NULL;\n              while(cell23 != NULL) {\n                  tmp23 = cell23->next;\n                  free(cell23);\n                  cell23 = tmp23;\n              }\n              free(sortedlist34);\n              DEBUG_FREE(sortedlist34->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist3_19.h\n#ifndef sortedlist3_19\n#define sortedlist3_19\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func10(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func11(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func12(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func16(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func17(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func18(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func13(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func14(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func15(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func19(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func20(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func21(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func9(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4308575\n    - Instructions: 6799228\n    - Cache References: 87419\n    - Cache Misses: 31115\n    - Branch Instructions: 1041502\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array3_16.c\n#include \"array3_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array3_16.h\n#ifndef array3_16\n#define array3_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array3_16.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array3_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 15149481\n    - Instructions: 33197380\n    - Cache References: 124488\n    - Cache Misses: 39591\n    - Branch Instructions: 6375929\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist6_6.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist6_6.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist6_6.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist6_6.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist6_6.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist6_6.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist6_6.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist6_6.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist6_6.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist6_6.c\n#include \"sortedlist6_6.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            sortedlist_t_param params0;\n            params0.size = 0;\n            params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n            sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n            DEBUG_RETURN(sortedlist9->id);\n            free(params0.data);\n            sortedlist9->refC--;\n            if(sortedlist9->refC == 0){\n                 cell_t* cell7 = sortedlist9->root;\n                 cell_t* tmp7  = NULL;\n                 while(cell7 != NULL) {\n                     tmp7 = cell7->next;\n                     free(cell7);\n                     cell7 = tmp7;\n                 }\n                 free(sortedlist9);\n                 DEBUG_FREE(sortedlist9->id);\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist6_6.h\n#ifndef sortedlist6_6\n#define sortedlist6_6\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1888095\n    - Instructions: 1691929\n    - Cache References: 78168\n    - Cache Misses: 22380\n    - Branch Instructions: 323195\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist14_7.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist14_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist14_7.c\n#include \"sortedlist14_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist14_7.h\n#ifndef sortedlist14_7\n#define sortedlist14_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2008452\n    - Instructions: 2353308\n    - Cache References: 76223\n    - Cache Misses: 19434\n    - Branch Instructions: 448783\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist4_4.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist4_4.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist4_4.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist4_4.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist4_4.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist4_4.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist4_4.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist4_4.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist4_4.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist4_4.c\n#include \"sortedlist4_4.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      unsigned int loop0 = 0;\n      unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n      for(; loop0 < loopLimit0; loop0++) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n   }\n   else {\n      unsigned int loop2 = 0;\n      unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n      for(; loop2 < loopLimit2; loop2++) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist9->id);\n         free(params0.data);\n         sortedlist9->refC--;\n         if(sortedlist9->refC == 0){\n              cell_t* cell7 = sortedlist9->root;\n              cell_t* tmp7  = NULL;\n              while(cell7 != NULL) {\n                  tmp7 = cell7->next;\n                  free(cell7);\n                  cell7 = tmp7;\n              }\n              free(sortedlist9);\n              DEBUG_FREE(sortedlist9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist4_4.h\n#ifndef sortedlist4_4\n#define sortedlist4_4\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1717646\n    - Instructions: 1152387\n    - Cache References: 75531\n    - Cache Misses: 31270\n    - Branch Instructions: 213026\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist14_11.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist14_11.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist14_11.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist14_11.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist14_11.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist14_11.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist14_11.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist14_11.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist14_11.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist14_11.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist14_11.c\n#include \"sortedlist14_11.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist16 = func2(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params0.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell8 = sortedlist16->root;\n        cell_t* tmp8  = NULL;\n        while(cell8 != NULL) {\n            tmp8 = cell8->next;\n            free(cell8);\n            cell8 = tmp8;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   return 0;\n}\n\n### File: sortedlist14_11.h\n#ifndef sortedlist14_11\n#define sortedlist14_11\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2296287\n    - Instructions: 3061167\n    - Cache References: 74077\n    - Cache Misses: 18008\n    - Branch Instructions: 586107\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist9_15.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: func1.c\n#include \"sortedlist9_15.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist3 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist3->id);\n   free(params0.data);\n   return sortedlist3;\n}\n\n### File: func2.c\n#include \"sortedlist9_15.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist4 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist4->id);\n      free(params0.data);\n      sortedlist4->refC--;\n      if(sortedlist4->refC == 0){\n           cell_t* cell2 = sortedlist4->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist4);\n           DEBUG_FREE(sortedlist4->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist6 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist6->id);\n      free(params0.data);\n      sortedlist6->refC--;\n      if(sortedlist6->refC == 0){\n           cell_t* cell3 = sortedlist6->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist6);\n           DEBUG_FREE(sortedlist6->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func3.c\n#include \"sortedlist9_15.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist5;\n   if (pCounter > 0) {\n      sortedlist5 = vars->data[--pCounter];\n      sortedlist5->refC++;\n      DEBUG_COPY(sortedlist5->id);\n   } else {\n      sortedlist5 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist5->refC = 1;\n      sortedlist5->id = 5;\n      sortedlist5->n = 0;\n      sortedlist5->root = NULL;\n      DEBUG_NEW(sortedlist5->id);\n   }\n   return sortedlist5;\n}\n\n### File: func4.c\n#include \"sortedlist9_15.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: rng.c\n#include \"sortedlist9_15.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist9_15.c\n#include \"sortedlist9_15.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist_t_param params1;\n      params1.size = 1;\n      params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n      params1.data[0] = sortedlist0;\n      sortedlist_t* sortedlist2 = func1(&params1, loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params1.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell4 = sortedlist2->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell5 = sortedlist0->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist9_15.h\n#ifndef sortedlist9_15\n#define sortedlist9_15\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4029915\n    - Instructions: 6763269\n    - Cache References: 74479\n    - Cache Misses: 18104\n    - Branch Instructions: 1036008\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array1_16.c\n#include \"array1_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array1_16.h\n#ifndef array1_16\n#define array1_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array1_16.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array1_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 739370932\n    - Instructions: 1532498006\n    - Cache References: 1609938\n    - Cache Misses: 238726\n    - Branch Instructions: 229129846\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array14_20.c\n#include \"array14_20.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n         unsigned int loop5 = 0;\n         unsigned int loopLimit5 = (rand()%loopsFactor)/2 + 1;\n         for(; loop5 < loopLimit5; loop5++) {\n            if(rng() & 1) {\n               array_t_param params0;\n               params0.size = 0;\n               params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n               array_t* array11 = func1(&params0, loopsFactor);\n               DEBUG_RETURN(array11->id);\n               free(params0.data);\n               array11->refC--;\n               if(array11->refC == 0) {\n                  free(array11->data);\n                  free(array11);\n                  DEBUG_FREE(array11->id);\n               }\n            }\n            else {\n               array_t_param params0;\n               params0.size = 0;\n               params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n               array_t* array20 = func2(&params0, loopsFactor);\n               DEBUG_RETURN(array20->id);\n               free(params0.data);\n               array20->refC--;\n               if(array20->refC == 0) {\n                  free(array20->data);\n                  free(array20);\n                  DEBUG_FREE(array20->id);\n               }\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array14_20.h\n#ifndef array14_20\n#define array14_20\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array14_20.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array10;\n   if (pCounter > 0) {\n      array10 = vars->data[--pCounter];\n      array10->refC++;\n      DEBUG_COPY(array10->id);\n   } else {\n      array10 = (array_t*)malloc(sizeof(array_t));\n      array10->size = 135;\n      array10->refC = 1;\n      array10->id = 10;\n      array10->data = (unsigned int*)malloc(array10->size*sizeof(unsigned int));\n      memset(array10->data, 0, array10->size*sizeof(unsigned int));\n      DEBUG_NEW(array10->id);\n   }\n   return array10;\n}\n\n### File: func1.c\n#include \"array14_20.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array12 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array12->id);\n   free(params0.data);\n   return array12;\n}\n\n### File: func2.c\n#include \"array14_20.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array21;\n   if (pCounter > 0) {\n      array21 = vars->data[--pCounter];\n      array21->refC++;\n      DEBUG_COPY(array21->id);\n   } else {\n      array21 = (array_t*)malloc(sizeof(array_t));\n      array21->size = 84;\n      array21->refC = 1;\n      array21->id = 21;\n      array21->data = (unsigned int*)malloc(array21->size*sizeof(unsigned int));\n      memset(array21->data, 0, array21->size*sizeof(unsigned int));\n      DEBUG_NEW(array21->id);\n   }\n   unsigned int loop9 = 0;\n   unsigned int loopLimit9 = (rand()%loopsFactor)/3 + 1;\n   for(; loop9 < loopLimit9; loop9++) {\n      for (int i = 0; i < array21->size; i++) {\n         array21->data[i]--;\n      }\n   }\n   return array21;\n}\n\n### File: func3.c\n#include \"array14_20.h\" \narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array15 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array15->id);\n      free(params0.data);\n      array15->refC--;\n      if(array15->refC == 0) {\n         free(array15->data);\n         free(array15);\n         DEBUG_FREE(array15->id);\n      }\n   }\n   array_t* array19;\n   if (pCounter > 0) {\n      array19 = vars->data[--pCounter];\n      array19->refC++;\n      DEBUG_COPY(array19->id);\n   } else {\n      array19 = (array_t*)malloc(sizeof(array_t));\n      array19->size = 873;\n      array19->refC = 1;\n      array19->id = 19;\n      array19->data = (unsigned int*)malloc(array19->size*sizeof(unsigned int));\n      memset(array19->data, 0, array19->size*sizeof(unsigned int));\n      DEBUG_NEW(array19->id);\n   }\n   return array19;\n}\n\n### File: func4.c\n#include \"array14_20.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 919;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   unsigned int loop6 = 0;\n   unsigned int loopLimit6 = (rand()%loopsFactor)/3 + 1;\n   for(; loop6 < loopLimit6; loop6++) {\n      for (int i = 0; i < array14->size; i++) {\n         array14->data[i]--;\n      }\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array14_20.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop7 = 0;\n   unsigned int loopLimit7 = (rand()%loopsFactor)/3 + 1;\n   for(; loop7 < loopLimit7; loop7++) {\n      array_t* array16;\n      if (pCounter > 0) {\n         array16 = vars->data[--pCounter];\n         array16->refC++;\n         DEBUG_COPY(array16->id);\n      } else {\n         array16 = (array_t*)malloc(sizeof(array_t));\n         array16->size = 413;\n         array16->refC = 1;\n         array16->id = 16;\n         array16->data = (unsigned int*)malloc(array16->size*sizeof(unsigned int));\n         memset(array16->data, 0, array16->size*sizeof(unsigned int));\n         DEBUG_NEW(array16->id);\n      }\n      array_t* array17;\n      if (pCounter > 0) {\n         array17 = vars->data[--pCounter];\n         array17->refC++;\n         DEBUG_COPY(array17->id);\n      } else {\n         array17 = (array_t*)malloc(sizeof(array_t));\n         array17->size = 526;\n         array17->refC = 1;\n         array17->id = 17;\n         array17->data = (unsigned int*)malloc(array17->size*sizeof(unsigned int));\n         memset(array17->data, 0, array17->size*sizeof(unsigned int));\n         DEBUG_NEW(array17->id);\n      }\n      unsigned int loop8 = 0;\n      unsigned int loopLimit8 = (rand()%loopsFactor)/4 + 1;\n      for(; loop8 < loopLimit8; loop8++) {\n         for (int i = 0; i < array17->size; i++) {\n            array17->data[i]--;\n         }\n      }\n      array17->refC--;\n      if(array17->refC == 0) {\n         free(array17->data);\n         free(array17);\n         DEBUG_FREE(array17->id);\n      }\n      array16->refC--;\n      if(array16->refC == 0) {\n         free(array16->data);\n         free(array16);\n         DEBUG_FREE(array16->id);\n      }\n   }\n   array_t* array18;\n   if (pCounter > 0) {\n      array18 = vars->data[--pCounter];\n      array18->refC++;\n      DEBUG_COPY(array18->id);\n   } else {\n      array18 = (array_t*)malloc(sizeof(array_t));\n      array18->size = 980;\n      array18->refC = 1;\n      array18->id = 18;\n      array18->data = (unsigned int*)malloc(array18->size*sizeof(unsigned int));\n      memset(array18->data, 0, array18->size*sizeof(unsigned int));\n      DEBUG_NEW(array18->id);\n   }\n   return array18;\n}\n\n### File: func6.c\n#include \"array14_20.h\" \narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array9;\n   if (pCounter > 0) {\n      array9 = vars->data[--pCounter];\n      array9->refC++;\n      DEBUG_COPY(array9->id);\n   } else {\n      array9 = (array_t*)malloc(sizeof(array_t));\n      array9->size = 123;\n      array9->refC = 1;\n      array9->id = 9;\n      array9->data = (unsigned int*)malloc(array9->size*sizeof(unsigned int));\n      memset(array9->data, 0, array9->size*sizeof(unsigned int));\n      DEBUG_NEW(array9->id);\n   }\n   return array9;\n}\n\n### File: func7.c\n#include \"array14_20.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      for (int i = 0; i < array4->size; i++) {\n         array4->data[i]--;\n      }\n   }\n   return array4;\n}\n\n### File: func8.c\n#include \"array14_20.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/3 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      array_t* array6;\n      if (pCounter > 0) {\n         array6 = vars->data[--pCounter];\n         array6->refC++;\n         DEBUG_COPY(array6->id);\n      } else {\n         array6 = (array_t*)malloc(sizeof(array_t));\n         array6->size = 567;\n         array6->refC = 1;\n         array6->id = 6;\n         array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n         memset(array6->data, 0, array6->size*sizeof(unsigned int));\n         DEBUG_NEW(array6->id);\n      }\n      array_t* array7;\n      if (pCounter > 0) {\n         array7 = vars->data[--pCounter];\n         array7->refC++;\n         DEBUG_COPY(array7->id);\n      } else {\n         array7 = (array_t*)malloc(sizeof(array_t));\n         array7->size = 429;\n         array7->refC = 1;\n         array7->id = 7;\n         array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n         memset(array7->data, 0, array7->size*sizeof(unsigned int));\n         DEBUG_NEW(array7->id);\n      }\n      unsigned int loop4 = 0;\n      unsigned int loopLimit4 = (rand()%loopsFactor)/4 + 1;\n      for(; loop4 < loopLimit4; loop4++) {\n         for (int i = 0; i < array6->size; i++) {\n            array6->data[i]--;\n         }\n      }\n      array7->refC--;\n      if(array7->refC == 0) {\n         free(array7->data);\n         free(array7);\n         DEBUG_FREE(array7->id);\n      }\n      array6->refC--;\n      if(array6->refC == 0) {\n         free(array6->data);\n         free(array6);\n         DEBUG_FREE(array6->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: rng.c\n#include \"array14_20.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1978209\n    - Instructions: 1692666\n    - Cache References: 89891\n    - Cache Misses: 24659\n    - Branch Instructions: 323821\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist11_14.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist11_14.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist11_14.c\n#include \"sortedlist11_14.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist11_14.h\n#ifndef sortedlist11_14\n#define sortedlist11_14\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1677239\n    - Instructions: 1119347\n    - Cache References: 79411\n    - Cache Misses: 21206\n    - Branch Instructions: 207608\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array2_8.c\n#include \"array2_8.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   return 0;\n}\n\n### File: array2_8.h\n#ifndef array2_8\n#define array2_8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array2_8.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array2_8.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array2_8.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array2_8.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array2_8.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array2_8.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array2_8.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array2_8.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array2_8.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1664500\n    - Instructions: 1160090\n    - Cache References: 79529\n    - Cache Misses: 18336\n    - Branch Instructions: 214730\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist11_11.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist11_11.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist11_11.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist11_11.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist11_11.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist11_11.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist11_11.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist11_11.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist11_11.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist11_11.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist11_11.c\n#include \"sortedlist11_11.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist16 = func2(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params0.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell8 = sortedlist16->root;\n        cell_t* tmp8  = NULL;\n        while(cell8 != NULL) {\n            tmp8 = cell8->next;\n            free(cell8);\n            cell8 = tmp8;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   return 0;\n}\n\n### File: sortedlist11_11.h\n#ifndef sortedlist11_11\n#define sortedlist11_11\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 14845005\n    - Instructions: 33163671\n    - Cache References: 107132\n    - Cache Misses: 24672\n    - Branch Instructions: 6371230\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist15_6.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist15_6.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist15_6.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist15_6.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist15_6.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist15_6.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist15_6.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist15_6.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist15_6.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist15_6.c\n#include \"sortedlist15_6.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            sortedlist_t_param params0;\n            params0.size = 0;\n            params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n            sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n            DEBUG_RETURN(sortedlist9->id);\n            free(params0.data);\n            sortedlist9->refC--;\n            if(sortedlist9->refC == 0){\n                 cell_t* cell7 = sortedlist9->root;\n                 cell_t* tmp7  = NULL;\n                 while(cell7 != NULL) {\n                     tmp7 = cell7->next;\n                     free(cell7);\n                     cell7 = tmp7;\n                 }\n                 free(sortedlist9);\n                 DEBUG_FREE(sortedlist9->id);\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist15_6.h\n#ifndef sortedlist15_6\n#define sortedlist15_6\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4164968\n    - Instructions: 6764044\n    - Cache References: 82452\n    - Cache Misses: 21191\n    - Branch Instructions: 1036660\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array7_16.c\n#include \"array7_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array7_16.h\n#ifndef array7_16\n#define array7_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array7_16.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array7_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 128530387\n    - Instructions: 280306232\n    - Cache References: 486173\n    - Cache Misses: 74123\n    - Branch Instructions: 54244128\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func10(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell27 = sortedlist2->root;\n           cell_t* tmp27  = NULL;\n           while(cell27 != NULL) {\n               tmp27 = cell27->next;\n               free(cell27);\n               cell27 = tmp27;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell28 = sortedlist1->root;\n           cell_t* tmp28  = NULL;\n           while(cell28 != NULL) {\n               tmp28 = cell28->next;\n               free(cell28);\n               cell28 = tmp28;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist53;\n   if (pCounter > 0) {\n      sortedlist53 = vars->data[--pCounter];\n      sortedlist53->refC++;\n      DEBUG_COPY(sortedlist53->id);\n   } else {\n      sortedlist53 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist53->refC = 1;\n      sortedlist53->id = 53;\n      sortedlist53->n = 0;\n      sortedlist53->root = NULL;\n      DEBUG_NEW(sortedlist53->id);\n   }\n   return sortedlist53;\n}\n\n### File: func1.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist55 = func4(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist55->id);\n   free(params0.data);\n   return sortedlist55;\n}\n\n### File: func10.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func10(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func11(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell1 = sortedlist3->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func12(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell26 = sortedlist5->root;\n           cell_t* tmp26  = NULL;\n           while(cell26 != NULL) {\n               tmp26 = cell26->next;\n               free(cell26);\n               cell26 = tmp26;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist52;\n   if (pCounter > 0) {\n      sortedlist52 = vars->data[--pCounter];\n      sortedlist52->refC++;\n      DEBUG_COPY(sortedlist52->id);\n   } else {\n      sortedlist52 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist52->refC = 1;\n      sortedlist52->id = 52;\n      sortedlist52->n = 0;\n      sortedlist52->root = NULL;\n      DEBUG_NEW(sortedlist52->id);\n   }\n   return sortedlist52;\n}\n\n### File: func11.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func11(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist4 != NULL && sortedlist4->n > 0)\n      {\n          cell_t* cell0 = sortedlist4->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist4->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist4->n--;\n              }\n           }\n      }\n   }\n   return sortedlist4;\n}\n\n### File: func12.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func12(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist6 = func16(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist6->id);\n   free(params0.data);\n   return sortedlist6;\n}\n\n### File: func13.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func13(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist60 = func14(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist60->id);\n      free(params0.data);\n      sortedlist60->refC--;\n      if(sortedlist60->refC == 0){\n           cell_t* cell34 = sortedlist60->root;\n           cell_t* tmp34  = NULL;\n           while(cell34 != NULL) {\n               tmp34 = cell34->next;\n               free(cell34);\n               cell34 = tmp34;\n           }\n           free(sortedlist60);\n           DEBUG_FREE(sortedlist60->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist64 = func15(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist64->id);\n      free(params0.data);\n      sortedlist64->refC--;\n      if(sortedlist64->refC == 0){\n           cell_t* cell42 = sortedlist64->root;\n           cell_t* tmp42  = NULL;\n           while(cell42 != NULL) {\n               tmp42 = cell42->next;\n               free(cell42);\n               cell42 = tmp42;\n           }\n           free(sortedlist64);\n           DEBUG_FREE(sortedlist64->id);\n      }\n   }\n   sortedlist_t* sortedlist78;\n   if (pCounter > 0) {\n      sortedlist78 = vars->data[--pCounter];\n      sortedlist78->refC++;\n      DEBUG_COPY(sortedlist78->id);\n   } else {\n      sortedlist78 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist78->refC = 1;\n      sortedlist78->id = 78;\n      sortedlist78->n = 0;\n      sortedlist78->root = NULL;\n      DEBUG_NEW(sortedlist78->id);\n   }\n   return sortedlist78;\n}\n\n### File: func14.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func14(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop10 = 0;\n   unsigned int loopLimit10 = (rand()%loopsFactor)/2 + 1;\n   for(; loop10 < loopLimit10; loop10++) {\n      sortedlist_t* sortedlist61;\n      if (pCounter > 0) {\n         sortedlist61 = vars->data[--pCounter];\n         sortedlist61->refC++;\n         DEBUG_COPY(sortedlist61->id);\n      } else {\n         sortedlist61 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist61->refC = 1;\n         sortedlist61->id = 61;\n         sortedlist61->n = 0;\n         sortedlist61->root = NULL;\n         DEBUG_NEW(sortedlist61->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist61;\n      sortedlist_t* sortedlist62 = func22(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist62->id);\n      free(params0.data);\n      sortedlist62->refC--;\n      if(sortedlist62->refC == 0){\n           cell_t* cell32 = sortedlist62->root;\n           cell_t* tmp32  = NULL;\n           while(cell32 != NULL) {\n               tmp32 = cell32->next;\n               free(cell32);\n               cell32 = tmp32;\n           }\n           free(sortedlist62);\n           DEBUG_FREE(sortedlist62->id);\n      }\n      sortedlist61->refC--;\n      if(sortedlist61->refC == 0){\n           cell_t* cell33 = sortedlist61->root;\n           cell_t* tmp33  = NULL;\n           while(cell33 != NULL) {\n               tmp33 = cell33->next;\n               free(cell33);\n               cell33 = tmp33;\n           }\n           free(sortedlist61);\n           DEBUG_FREE(sortedlist61->id);\n      }\n   }\n   sortedlist_t* sortedlist63;\n   if (pCounter > 0) {\n      sortedlist63 = vars->data[--pCounter];\n      sortedlist63->refC++;\n      DEBUG_COPY(sortedlist63->id);\n   } else {\n      sortedlist63 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist63->refC = 1;\n      sortedlist63->id = 63;\n      sortedlist63->n = 0;\n      sortedlist63->root = NULL;\n      DEBUG_NEW(sortedlist63->id);\n   }\n   return sortedlist63;\n}\n\n### File: func15.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func15(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist65 = func19(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist65->id);\n   free(params0.data);\n   return sortedlist65;\n}\n\n### File: func16.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func16(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist7 = func17(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist7->id);\n      free(params0.data);\n      sortedlist7->refC--;\n      if(sortedlist7->refC == 0){\n           cell_t* cell12 = sortedlist7->root;\n           cell_t* tmp12  = NULL;\n           while(cell12 != NULL) {\n               tmp12 = cell12->next;\n               free(cell12);\n               cell12 = tmp12;\n           }\n           free(sortedlist7);\n           DEBUG_FREE(sortedlist7->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist27 = func18(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist27->id);\n      free(params0.data);\n      sortedlist27->refC--;\n      if(sortedlist27->refC == 0){\n           cell_t* cell25 = sortedlist27->root;\n           cell_t* tmp25  = NULL;\n           while(cell25 != NULL) {\n               tmp25 = cell25->next;\n               free(cell25);\n               cell25 = tmp25;\n           }\n           free(sortedlist27);\n           DEBUG_FREE(sortedlist27->id);\n      }\n   }\n   sortedlist_t* sortedlist51;\n   if (pCounter > 0) {\n      sortedlist51 = vars->data[--pCounter];\n      sortedlist51->refC++;\n      DEBUG_COPY(sortedlist51->id);\n   } else {\n      sortedlist51 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist51->refC = 1;\n      sortedlist51->id = 51;\n      sortedlist51->n = 0;\n      sortedlist51->root = NULL;\n      DEBUG_NEW(sortedlist51->id);\n   }\n   return sortedlist51;\n}\n\n### File: func17.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func17(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/3 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      sortedlist_t* sortedlist8;\n      if (pCounter > 0) {\n         sortedlist8 = vars->data[--pCounter];\n         sortedlist8->refC++;\n         DEBUG_COPY(sortedlist8->id);\n      } else {\n         sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist8->refC = 1;\n         sortedlist8->id = 8;\n         sortedlist8->n = 0;\n         sortedlist8->root = NULL;\n         DEBUG_NEW(sortedlist8->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist8;\n      sortedlist_t* sortedlist9 = func28(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell10 = sortedlist9->root;\n           cell_t* tmp10  = NULL;\n           while(cell10 != NULL) {\n               tmp10 = cell10->next;\n               free(cell10);\n               cell10 = tmp10;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n      sortedlist8->refC--;\n      if(sortedlist8->refC == 0){\n           cell_t* cell11 = sortedlist8->root;\n           cell_t* tmp11  = NULL;\n           while(cell11 != NULL) {\n               tmp11 = cell11->next;\n               free(cell11);\n               cell11 = tmp11;\n           }\n           free(sortedlist8);\n           DEBUG_FREE(sortedlist8->id);\n      }\n   }\n   sortedlist_t* sortedlist26;\n   if (pCounter > 0) {\n      sortedlist26 = vars->data[--pCounter];\n      sortedlist26->refC++;\n      DEBUG_COPY(sortedlist26->id);\n   } else {\n      sortedlist26 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist26->refC = 1;\n      sortedlist26->id = 26;\n      sortedlist26->n = 0;\n      sortedlist26->root = NULL;\n      DEBUG_NEW(sortedlist26->id);\n   }\n   return sortedlist26;\n}\n\n### File: func18.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func18(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist28 = func22(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist28->id);\n   free(params0.data);\n   return sortedlist28;\n}\n\n### File: func19.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func19(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist66 = func20(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist66->id);\n      free(params0.data);\n      sortedlist66->refC--;\n      if(sortedlist66->refC == 0){\n           cell_t* cell36 = sortedlist66->root;\n           cell_t* tmp36  = NULL;\n           while(cell36 != NULL) {\n               tmp36 = cell36->next;\n               free(cell36);\n               cell36 = tmp36;\n           }\n           free(sortedlist66);\n           DEBUG_FREE(sortedlist66->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist68 = func21(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist68->id);\n      free(params0.data);\n      sortedlist68->refC--;\n      if(sortedlist68->refC == 0){\n           cell_t* cell41 = sortedlist68->root;\n           cell_t* tmp41  = NULL;\n           while(cell41 != NULL) {\n               tmp41 = cell41->next;\n               free(cell41);\n               cell41 = tmp41;\n           }\n           free(sortedlist68);\n           DEBUG_FREE(sortedlist68->id);\n      }\n   }\n   sortedlist_t* sortedlist77;\n   if (pCounter > 0) {\n      sortedlist77 = vars->data[--pCounter];\n      sortedlist77->refC++;\n      DEBUG_COPY(sortedlist77->id);\n   } else {\n      sortedlist77 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist77->refC = 1;\n      sortedlist77->id = 77;\n      sortedlist77->n = 0;\n      sortedlist77->root = NULL;\n      DEBUG_NEW(sortedlist77->id);\n   }\n   return sortedlist77;\n}\n\n### File: func2.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist81;\n   if (pCounter > 0) {\n      sortedlist81 = vars->data[--pCounter];\n      sortedlist81->refC++;\n      DEBUG_COPY(sortedlist81->id);\n   } else {\n      sortedlist81 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist81->refC = 1;\n      sortedlist81->id = 81;\n      sortedlist81->n = 0;\n      sortedlist81->root = NULL;\n      DEBUG_NEW(sortedlist81->id);\n   }\n   unsigned int loop13 = 0;\n   unsigned int loopLimit13 = (rand()%loopsFactor)/2 + 1;\n   for(; loop13 < loopLimit13; loop13++) {\n      if(sortedlist81 != NULL && sortedlist81->n > 0)\n      {\n          cell_t* cell45 = sortedlist81->root;\n          if(cell45->val == 56)\n          {\n              cell45 = cell45->next;\n              sortedlist81->n--;\n          }else{\n              while(cell45->next != NULL && cell45->next->val != 56) cell45 = cell45->next;\n              if(cell45->next != NULL)\n              {\n                  cell45 = cell45->next->next;\n                  sortedlist81->n--;\n              }\n           }\n      }\n   }\n   return sortedlist81;\n}\n\n### File: func20.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func20(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist67;\n   if (pCounter > 0) {\n      sortedlist67 = vars->data[--pCounter];\n      sortedlist67->refC++;\n      DEBUG_COPY(sortedlist67->id);\n   } else {\n      sortedlist67 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist67->refC = 1;\n      sortedlist67->id = 67;\n      sortedlist67->n = 0;\n      sortedlist67->root = NULL;\n      DEBUG_NEW(sortedlist67->id);\n   }\n   unsigned int loop11 = 0;\n   unsigned int loopLimit11 = (rand()%loopsFactor)/2 + 1;\n   for(; loop11 < loopLimit11; loop11++) {\n      if(sortedlist67 != NULL && sortedlist67->n > 0)\n      {\n          cell_t* cell35 = sortedlist67->root;\n          if(cell35->val == 73)\n          {\n              cell35 = cell35->next;\n              sortedlist67->n--;\n          }else{\n              while(cell35->next != NULL && cell35->next->val != 73) cell35 = cell35->next;\n              if(cell35->next != NULL)\n              {\n                  cell35 = cell35->next->next;\n                  sortedlist67->n--;\n              }\n           }\n      }\n   }\n   return sortedlist67;\n}\n\n### File: func21.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func21(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist69 = func25(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist69->id);\n   free(params0.data);\n   return sortedlist69;\n}\n\n### File: func22.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func22(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist29 = func23(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist29->id);\n      free(params0.data);\n      sortedlist29->refC--;\n      if(sortedlist29->refC == 0){\n           cell_t* cell14 = sortedlist29->root;\n           cell_t* tmp14  = NULL;\n           while(cell14 != NULL) {\n               tmp14 = cell14->next;\n               free(cell14);\n               cell14 = tmp14;\n           }\n           free(sortedlist29);\n           DEBUG_FREE(sortedlist29->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist31 = func24(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist31->id);\n      free(params0.data);\n      sortedlist31->refC--;\n      if(sortedlist31->refC == 0){\n           cell_t* cell24 = sortedlist31->root;\n           cell_t* tmp24  = NULL;\n           while(cell24 != NULL) {\n               tmp24 = cell24->next;\n               free(cell24);\n               cell24 = tmp24;\n           }\n           free(sortedlist31);\n           DEBUG_FREE(sortedlist31->id);\n      }\n   }\n   sortedlist_t* sortedlist50;\n   if (pCounter > 0) {\n      sortedlist50 = vars->data[--pCounter];\n      sortedlist50->refC++;\n      DEBUG_COPY(sortedlist50->id);\n   } else {\n      sortedlist50 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist50->refC = 1;\n      sortedlist50->id = 50;\n      sortedlist50->n = 0;\n      sortedlist50->root = NULL;\n      DEBUG_NEW(sortedlist50->id);\n   }\n   return sortedlist50;\n}\n\n### File: func23.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func23(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist30;\n   if (pCounter > 0) {\n      sortedlist30 = vars->data[--pCounter];\n      sortedlist30->refC++;\n      DEBUG_COPY(sortedlist30->id);\n   } else {\n      sortedlist30 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist30->refC = 1;\n      sortedlist30->id = 30;\n      sortedlist30->n = 0;\n      sortedlist30->root = NULL;\n      DEBUG_NEW(sortedlist30->id);\n   }\n   unsigned int loop6 = 0;\n   unsigned int loopLimit6 = (rand()%loopsFactor)/3 + 1;\n   for(; loop6 < loopLimit6; loop6++) {\n      if(sortedlist30 != NULL && sortedlist30->n > 0)\n      {\n          cell_t* cell13 = sortedlist30->root;\n          if(cell13->val == 40)\n          {\n              cell13 = cell13->next;\n              sortedlist30->n--;\n          }else{\n              while(cell13->next != NULL && cell13->next->val != 40) cell13 = cell13->next;\n              if(cell13->next != NULL)\n              {\n                  cell13 = cell13->next->next;\n                  sortedlist30->n--;\n              }\n           }\n      }\n   }\n   return sortedlist30;\n}\n\n### File: func24.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func24(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist32 = func31(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist32->id);\n   free(params0.data);\n   return sortedlist32;\n}\n\n### File: func25.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func25(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist70 = func26(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist70->id);\n      free(params0.data);\n      sortedlist70->refC--;\n      if(sortedlist70->refC == 0){\n           cell_t* cell39 = sortedlist70->root;\n           cell_t* tmp39  = NULL;\n           while(cell39 != NULL) {\n               tmp39 = cell39->next;\n               free(cell39);\n               cell39 = tmp39;\n           }\n           free(sortedlist70);\n           DEBUG_FREE(sortedlist70->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist74 = func27(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist74->id);\n      free(params0.data);\n      sortedlist74->refC--;\n      if(sortedlist74->refC == 0){\n           cell_t* cell40 = sortedlist74->root;\n           cell_t* tmp40  = NULL;\n           while(cell40 != NULL) {\n               tmp40 = cell40->next;\n               free(cell40);\n               cell40 = tmp40;\n           }\n           free(sortedlist74);\n           DEBUG_FREE(sortedlist74->id);\n      }\n   }\n   sortedlist_t* sortedlist76;\n   if (pCounter > 0) {\n      sortedlist76 = vars->data[--pCounter];\n      sortedlist76->refC++;\n      DEBUG_COPY(sortedlist76->id);\n   } else {\n      sortedlist76 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist76->refC = 1;\n      sortedlist76->id = 76;\n      sortedlist76->n = 0;\n      sortedlist76->root = NULL;\n      DEBUG_NEW(sortedlist76->id);\n   }\n   return sortedlist76;\n}\n\n### File: func26.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func26(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop12 = 0;\n   unsigned int loopLimit12 = (rand()%loopsFactor)/2 + 1;\n   for(; loop12 < loopLimit12; loop12++) {\n      sortedlist_t* sortedlist71;\n      if (pCounter > 0) {\n         sortedlist71 = vars->data[--pCounter];\n         sortedlist71->refC++;\n         DEBUG_COPY(sortedlist71->id);\n      } else {\n         sortedlist71 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist71->refC = 1;\n         sortedlist71->id = 71;\n         sortedlist71->n = 0;\n         sortedlist71->root = NULL;\n         DEBUG_NEW(sortedlist71->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist71;\n      sortedlist_t* sortedlist72 = func37(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist72->id);\n      free(params0.data);\n      sortedlist72->refC--;\n      if(sortedlist72->refC == 0){\n           cell_t* cell37 = sortedlist72->root;\n           cell_t* tmp37  = NULL;\n           while(cell37 != NULL) {\n               tmp37 = cell37->next;\n               free(cell37);\n               cell37 = tmp37;\n           }\n           free(sortedlist72);\n           DEBUG_FREE(sortedlist72->id);\n      }\n      sortedlist71->refC--;\n      if(sortedlist71->refC == 0){\n           cell_t* cell38 = sortedlist71->root;\n           cell_t* tmp38  = NULL;\n           while(cell38 != NULL) {\n               tmp38 = cell38->next;\n               free(cell38);\n               cell38 = tmp38;\n           }\n           free(sortedlist71);\n           DEBUG_FREE(sortedlist71->id);\n      }\n   }\n   sortedlist_t* sortedlist73;\n   if (pCounter > 0) {\n      sortedlist73 = vars->data[--pCounter];\n      sortedlist73->refC++;\n      DEBUG_COPY(sortedlist73->id);\n   } else {\n      sortedlist73 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist73->refC = 1;\n      sortedlist73->id = 73;\n      sortedlist73->n = 0;\n      sortedlist73->root = NULL;\n      DEBUG_NEW(sortedlist73->id);\n   }\n   return sortedlist73;\n}\n\n### File: func27.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func27(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist75 = func28(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist75->id);\n   free(params0.data);\n   return sortedlist75;\n}\n\n### File: func28.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func28(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist10 = func29(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist10->id);\n      free(params0.data);\n      sortedlist10->refC--;\n      if(sortedlist10->refC == 0){\n           cell_t* cell3 = sortedlist10->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist10);\n           DEBUG_FREE(sortedlist10->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist12 = func30(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist12->id);\n      free(params0.data);\n      sortedlist12->refC--;\n      if(sortedlist12->refC == 0){\n           cell_t* cell9 = sortedlist12->root;\n           cell_t* tmp9  = NULL;\n           while(cell9 != NULL) {\n               tmp9 = cell9->next;\n               free(cell9);\n               cell9 = tmp9;\n           }\n           free(sortedlist12);\n           DEBUG_FREE(sortedlist12->id);\n      }\n   }\n   sortedlist_t* sortedlist25;\n   if (pCounter > 0) {\n      sortedlist25 = vars->data[--pCounter];\n      sortedlist25->refC++;\n      DEBUG_COPY(sortedlist25->id);\n   } else {\n      sortedlist25 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist25->refC = 1;\n      sortedlist25->id = 25;\n      sortedlist25->n = 0;\n      sortedlist25->root = NULL;\n      DEBUG_NEW(sortedlist25->id);\n   }\n   return sortedlist25;\n}\n\n### File: func29.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func29(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist11;\n   if (pCounter > 0) {\n      sortedlist11 = vars->data[--pCounter];\n      sortedlist11->refC++;\n      DEBUG_COPY(sortedlist11->id);\n   } else {\n      sortedlist11 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist11->refC = 1;\n      sortedlist11->id = 11;\n      sortedlist11->n = 0;\n      sortedlist11->root = NULL;\n      DEBUG_NEW(sortedlist11->id);\n   }\n   unsigned int loop4 = 0;\n   unsigned int loopLimit4 = (rand()%loopsFactor)/4 + 1;\n   for(; loop4 < loopLimit4; loop4++) {\n      if(sortedlist11 != NULL && sortedlist11->n > 0)\n      {\n          cell_t* cell2 = sortedlist11->root;\n          if(cell2->val == 93)\n          {\n              cell2 = cell2->next;\n              sortedlist11->n--;\n          }else{\n              while(cell2->next != NULL && cell2->next->val != 93) cell2 = cell2->next;\n              if(cell2->next != NULL)\n              {\n                  cell2 = cell2->next->next;\n                  sortedlist11->n--;\n              }\n           }\n      }\n   }\n   return sortedlist11;\n}\n\n### File: func3.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist83 = func7(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist83->id);\n   free(params0.data);\n   return sortedlist83;\n}\n\n### File: func30.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func30(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist13 = func34(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist13->id);\n   free(params0.data);\n   return sortedlist13;\n}\n\n### File: func31.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func31(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist33 = func32(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist33->id);\n      free(params0.data);\n      sortedlist33->refC--;\n      if(sortedlist33->refC == 0){\n           cell_t* cell17 = sortedlist33->root;\n           cell_t* tmp17  = NULL;\n           while(cell17 != NULL) {\n               tmp17 = cell17->next;\n               free(cell17);\n               cell17 = tmp17;\n           }\n           free(sortedlist33);\n           DEBUG_FREE(sortedlist33->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist37 = func33(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist37->id);\n      free(params0.data);\n      sortedlist37->refC--;\n      if(sortedlist37->refC == 0){\n           cell_t* cell23 = sortedlist37->root;\n           cell_t* tmp23  = NULL;\n           while(cell23 != NULL) {\n               tmp23 = cell23->next;\n               free(cell23);\n               cell23 = tmp23;\n           }\n           free(sortedlist37);\n           DEBUG_FREE(sortedlist37->id);\n      }\n   }\n   sortedlist_t* sortedlist49;\n   if (pCounter > 0) {\n      sortedlist49 = vars->data[--pCounter];\n      sortedlist49->refC++;\n      DEBUG_COPY(sortedlist49->id);\n   } else {\n      sortedlist49 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist49->refC = 1;\n      sortedlist49->id = 49;\n      sortedlist49->n = 0;\n      sortedlist49->root = NULL;\n      DEBUG_NEW(sortedlist49->id);\n   }\n   return sortedlist49;\n}\n\n### File: func32.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func32(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop7 = 0;\n   unsigned int loopLimit7 = (rand()%loopsFactor)/3 + 1;\n   for(; loop7 < loopLimit7; loop7++) {\n      sortedlist_t* sortedlist34;\n      if (pCounter > 0) {\n         sortedlist34 = vars->data[--pCounter];\n         sortedlist34->refC++;\n         DEBUG_COPY(sortedlist34->id);\n      } else {\n         sortedlist34 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist34->refC = 1;\n         sortedlist34->id = 34;\n         sortedlist34->n = 0;\n         sortedlist34->root = NULL;\n         DEBUG_NEW(sortedlist34->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist34;\n      sortedlist_t* sortedlist35 = func40(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist35->id);\n      free(params0.data);\n      sortedlist35->refC--;\n      if(sortedlist35->refC == 0){\n           cell_t* cell15 = sortedlist35->root;\n           cell_t* tmp15  = NULL;\n           while(cell15 != NULL) {\n               tmp15 = cell15->next;\n               free(cell15);\n               cell15 = tmp15;\n           }\n           free(sortedlist35);\n           DEBUG_FREE(sortedlist35->id);\n      }\n      sortedlist34->refC--;\n      if(sortedlist34->refC == 0){\n           cell_t* cell16 = sortedlist34->root;\n           cell_t* tmp16  = NULL;\n           while(cell16 != NULL) {\n               tmp16 = cell16->next;\n               free(cell16);\n               cell16 = tmp16;\n           }\n           free(sortedlist34);\n           DEBUG_FREE(sortedlist34->id);\n      }\n   }\n   sortedlist_t* sortedlist36;\n   if (pCounter > 0) {\n      sortedlist36 = vars->data[--pCounter];\n      sortedlist36->refC++;\n      DEBUG_COPY(sortedlist36->id);\n   } else {\n      sortedlist36 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist36->refC = 1;\n      sortedlist36->id = 36;\n      sortedlist36->n = 0;\n      sortedlist36->root = NULL;\n      DEBUG_NEW(sortedlist36->id);\n   }\n   return sortedlist36;\n}\n\n### File: func33.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func33(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist38 = func37(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist38->id);\n   free(params0.data);\n   return sortedlist38;\n}\n\n### File: func34.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func34(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist14 = func35(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist14->id);\n      free(params0.data);\n      sortedlist14->refC--;\n      if(sortedlist14->refC == 0){\n           cell_t* cell5 = sortedlist14->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist14);\n           DEBUG_FREE(sortedlist14->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist17 = func36(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist17->id);\n      free(params0.data);\n      sortedlist17->refC--;\n      if(sortedlist17->refC == 0){\n           cell_t* cell8 = sortedlist17->root;\n           cell_t* tmp8  = NULL;\n           while(cell8 != NULL) {\n               tmp8 = cell8->next;\n               free(cell8);\n               cell8 = tmp8;\n           }\n           free(sortedlist17);\n           DEBUG_FREE(sortedlist17->id);\n      }\n   }\n   sortedlist_t* sortedlist24;\n   if (pCounter > 0) {\n      sortedlist24 = vars->data[--pCounter];\n      sortedlist24->refC++;\n      DEBUG_COPY(sortedlist24->id);\n   } else {\n      sortedlist24 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist24->refC = 1;\n      sortedlist24->id = 24;\n      sortedlist24->n = 0;\n      sortedlist24->root = NULL;\n      DEBUG_NEW(sortedlist24->id);\n   }\n   return sortedlist24;\n}\n\n### File: func35.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func35(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop5 = 0;\n   unsigned int loopLimit5 = (rand()%loopsFactor)/4 + 1;\n   for(; loop5 < loopLimit5; loop5++) {\n      sortedlist_t* sortedlist15;\n      if (pCounter > 0) {\n         sortedlist15 = vars->data[--pCounter];\n         sortedlist15->refC++;\n         DEBUG_COPY(sortedlist15->id);\n      } else {\n         sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist15->refC = 1;\n         sortedlist15->id = 15;\n         sortedlist15->n = 0;\n         sortedlist15->root = NULL;\n         DEBUG_NEW(sortedlist15->id);\n      }\n      sortedlist15->refC--;\n      if(sortedlist15->refC == 0){\n           cell_t* cell4 = sortedlist15->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist15);\n           DEBUG_FREE(sortedlist15->id);\n      }\n   }\n   sortedlist_t* sortedlist16;\n   if (pCounter > 0) {\n      sortedlist16 = vars->data[--pCounter];\n      sortedlist16->refC++;\n      DEBUG_COPY(sortedlist16->id);\n   } else {\n      sortedlist16 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist16->refC = 1;\n      sortedlist16->id = 16;\n      sortedlist16->n = 0;\n      sortedlist16->root = NULL;\n      DEBUG_NEW(sortedlist16->id);\n   }\n   return sortedlist16;\n}\n\n### File: func36.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func36(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist18 = func40(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist18->id);\n   free(params0.data);\n   return sortedlist18;\n}\n\n### File: func37.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func37(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist39 = func38(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist39->id);\n      free(params0.data);\n      sortedlist39->refC--;\n      if(sortedlist39->refC == 0){\n           cell_t* cell19 = sortedlist39->root;\n           cell_t* tmp19  = NULL;\n           while(cell19 != NULL) {\n               tmp19 = cell19->next;\n               free(cell19);\n               cell19 = tmp19;\n           }\n           free(sortedlist39);\n           DEBUG_FREE(sortedlist39->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist41 = func39(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist41->id);\n      free(params0.data);\n      sortedlist41->refC--;\n      if(sortedlist41->refC == 0){\n           cell_t* cell22 = sortedlist41->root;\n           cell_t* tmp22  = NULL;\n           while(cell22 != NULL) {\n               tmp22 = cell22->next;\n               free(cell22);\n               cell22 = tmp22;\n           }\n           free(sortedlist41);\n           DEBUG_FREE(sortedlist41->id);\n      }\n   }\n   sortedlist_t* sortedlist48;\n   if (pCounter > 0) {\n      sortedlist48 = vars->data[--pCounter];\n      sortedlist48->refC++;\n      DEBUG_COPY(sortedlist48->id);\n   } else {\n      sortedlist48 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist48->refC = 1;\n      sortedlist48->id = 48;\n      sortedlist48->n = 0;\n      sortedlist48->root = NULL;\n      DEBUG_NEW(sortedlist48->id);\n   }\n   return sortedlist48;\n}\n\n### File: func38.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func38(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist40;\n   if (pCounter > 0) {\n      sortedlist40 = vars->data[--pCounter];\n      sortedlist40->refC++;\n      DEBUG_COPY(sortedlist40->id);\n   } else {\n      sortedlist40 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist40->refC = 1;\n      sortedlist40->id = 40;\n      sortedlist40->n = 0;\n      sortedlist40->root = NULL;\n      DEBUG_NEW(sortedlist40->id);\n   }\n   unsigned int loop8 = 0;\n   unsigned int loopLimit8 = (rand()%loopsFactor)/3 + 1;\n   for(; loop8 < loopLimit8; loop8++) {\n      if(sortedlist40 != NULL && sortedlist40->n > 0)\n      {\n          cell_t* cell18 = sortedlist40->root;\n          if(cell18->val == 11)\n          {\n              cell18 = cell18->next;\n              sortedlist40->n--;\n          }else{\n              while(cell18->next != NULL && cell18->next->val != 11) cell18 = cell18->next;\n              if(cell18->next != NULL)\n              {\n                  cell18 = cell18->next->next;\n                  sortedlist40->n--;\n              }\n           }\n      }\n   }\n   return sortedlist40;\n}\n\n### File: func39.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func39(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist42 = func43(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist42->id);\n   free(params0.data);\n   return sortedlist42;\n}\n\n### File: func4.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist56 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist56->id);\n      free(params0.data);\n      sortedlist56->refC--;\n      if(sortedlist56->refC == 0){\n           cell_t* cell31 = sortedlist56->root;\n           cell_t* tmp31  = NULL;\n           while(cell31 != NULL) {\n               tmp31 = cell31->next;\n               free(cell31);\n               cell31 = tmp31;\n           }\n           free(sortedlist56);\n           DEBUG_FREE(sortedlist56->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist58 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist58->id);\n      free(params0.data);\n      sortedlist58->refC--;\n      if(sortedlist58->refC == 0){\n           cell_t* cell43 = sortedlist58->root;\n           cell_t* tmp43  = NULL;\n           while(cell43 != NULL) {\n               tmp43 = cell43->next;\n               free(cell43);\n               cell43 = tmp43;\n           }\n           free(sortedlist58);\n           DEBUG_FREE(sortedlist58->id);\n      }\n   }\n   sortedlist_t* sortedlist79;\n   if (pCounter > 0) {\n      sortedlist79 = vars->data[--pCounter];\n      sortedlist79->refC++;\n      DEBUG_COPY(sortedlist79->id);\n   } else {\n      sortedlist79 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist79->refC = 1;\n      sortedlist79->id = 79;\n      sortedlist79->n = 0;\n      sortedlist79->root = NULL;\n      DEBUG_NEW(sortedlist79->id);\n   }\n   return sortedlist79;\n}\n\n### File: func40.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func40(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist19 = func41(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist19->id);\n      free(params0.data);\n      sortedlist19->refC--;\n      if(sortedlist19->refC == 0){\n           cell_t* cell6 = sortedlist19->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist19);\n           DEBUG_FREE(sortedlist19->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist21 = func42(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist21->id);\n      free(params0.data);\n      sortedlist21->refC--;\n      if(sortedlist21->refC == 0){\n           cell_t* cell7 = sortedlist21->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist21);\n           DEBUG_FREE(sortedlist21->id);\n      }\n   }\n   sortedlist_t* sortedlist23;\n   if (pCounter > 0) {\n      sortedlist23 = vars->data[--pCounter];\n      sortedlist23->refC++;\n      DEBUG_COPY(sortedlist23->id);\n   } else {\n      sortedlist23 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist23->refC = 1;\n      sortedlist23->id = 23;\n      sortedlist23->n = 0;\n      sortedlist23->root = NULL;\n      DEBUG_NEW(sortedlist23->id);\n   }\n   return sortedlist23;\n}\n\n### File: func41.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func41(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist20;\n   if (pCounter > 0) {\n      sortedlist20 = vars->data[--pCounter];\n      sortedlist20->refC++;\n      DEBUG_COPY(sortedlist20->id);\n   } else {\n      sortedlist20 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist20->refC = 1;\n      sortedlist20->id = 20;\n      sortedlist20->n = 0;\n      sortedlist20->root = NULL;\n      DEBUG_NEW(sortedlist20->id);\n   }\n   return sortedlist20;\n}\n\n### File: func42.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func42(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist22;\n   if (pCounter > 0) {\n      sortedlist22 = vars->data[--pCounter];\n      sortedlist22->refC++;\n      DEBUG_COPY(sortedlist22->id);\n   } else {\n      sortedlist22 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist22->refC = 1;\n      sortedlist22->id = 22;\n      sortedlist22->n = 0;\n      sortedlist22->root = NULL;\n      DEBUG_NEW(sortedlist22->id);\n   }\n   return sortedlist22;\n}\n\n### File: func43.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func43(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist43 = func44(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist43->id);\n      free(params0.data);\n      sortedlist43->refC--;\n      if(sortedlist43->refC == 0){\n           cell_t* cell20 = sortedlist43->root;\n           cell_t* tmp20  = NULL;\n           while(cell20 != NULL) {\n               tmp20 = cell20->next;\n               free(cell20);\n               cell20 = tmp20;\n           }\n           free(sortedlist43);\n           DEBUG_FREE(sortedlist43->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist45 = func45(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist45->id);\n      free(params0.data);\n      sortedlist45->refC--;\n      if(sortedlist45->refC == 0){\n           cell_t* cell21 = sortedlist45->root;\n           cell_t* tmp21  = NULL;\n           while(cell21 != NULL) {\n               tmp21 = cell21->next;\n               free(cell21);\n               cell21 = tmp21;\n           }\n           free(sortedlist45);\n           DEBUG_FREE(sortedlist45->id);\n      }\n   }\n   sortedlist_t* sortedlist47;\n   if (pCounter > 0) {\n      sortedlist47 = vars->data[--pCounter];\n      sortedlist47->refC++;\n      DEBUG_COPY(sortedlist47->id);\n   } else {\n      sortedlist47 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist47->refC = 1;\n      sortedlist47->id = 47;\n      sortedlist47->n = 0;\n      sortedlist47->root = NULL;\n      DEBUG_NEW(sortedlist47->id);\n   }\n   return sortedlist47;\n}\n\n### File: func44.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func44(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist44;\n   if (pCounter > 0) {\n      sortedlist44 = vars->data[--pCounter];\n      sortedlist44->refC++;\n      DEBUG_COPY(sortedlist44->id);\n   } else {\n      sortedlist44 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist44->refC = 1;\n      sortedlist44->id = 44;\n      sortedlist44->n = 0;\n      sortedlist44->root = NULL;\n      DEBUG_NEW(sortedlist44->id);\n   }\n   return sortedlist44;\n}\n\n### File: func45.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func45(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist46;\n   if (pCounter > 0) {\n      sortedlist46 = vars->data[--pCounter];\n      sortedlist46->refC++;\n      DEBUG_COPY(sortedlist46->id);\n   } else {\n      sortedlist46 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist46->refC = 1;\n      sortedlist46->id = 46;\n      sortedlist46->n = 0;\n      sortedlist46->root = NULL;\n      DEBUG_NEW(sortedlist46->id);\n   }\n   return sortedlist46;\n}\n\n### File: func5.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist57;\n   if (pCounter > 0) {\n      sortedlist57 = vars->data[--pCounter];\n      sortedlist57->refC++;\n      DEBUG_COPY(sortedlist57->id);\n   } else {\n      sortedlist57 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist57->refC = 1;\n      sortedlist57->id = 57;\n      sortedlist57->n = 0;\n      sortedlist57->root = NULL;\n      DEBUG_NEW(sortedlist57->id);\n   }\n   unsigned int loop9 = 0;\n   unsigned int loopLimit9 = (rand()%loopsFactor)/2 + 1;\n   for(; loop9 < loopLimit9; loop9++) {\n      if(sortedlist57 != NULL && sortedlist57->n > 0)\n      {\n          cell_t* cell30 = sortedlist57->root;\n          if(cell30->val == 56)\n          {\n              cell30 = cell30->next;\n              sortedlist57->n--;\n          }else{\n              while(cell30->next != NULL && cell30->next->val != 56) cell30 = cell30->next;\n              if(cell30->next != NULL)\n              {\n                  cell30 = cell30->next->next;\n                  sortedlist57->n--;\n              }\n           }\n      }\n   }\n   return sortedlist57;\n}\n\n### File: func6.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist59 = func13(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist59->id);\n   free(params0.data);\n   return sortedlist59;\n}\n\n### File: func7.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist84 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist84->id);\n      free(params0.data);\n      sortedlist84->refC--;\n      if(sortedlist84->refC == 0){\n           cell_t* cell49 = sortedlist84->root;\n           cell_t* tmp49  = NULL;\n           while(cell49 != NULL) {\n               tmp49 = cell49->next;\n               free(cell49);\n               cell49 = tmp49;\n           }\n           free(sortedlist84);\n           DEBUG_FREE(sortedlist84->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist88 = func9(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist88->id);\n      free(params0.data);\n      sortedlist88->refC--;\n      if(sortedlist88->refC == 0){\n           cell_t* cell50 = sortedlist88->root;\n           cell_t* tmp50  = NULL;\n           while(cell50 != NULL) {\n               tmp50 = cell50->next;\n               free(cell50);\n               cell50 = tmp50;\n           }\n           free(sortedlist88);\n           DEBUG_FREE(sortedlist88->id);\n      }\n   }\n   sortedlist_t* sortedlist90;\n   if (pCounter > 0) {\n      sortedlist90 = vars->data[--pCounter];\n      sortedlist90->refC++;\n      DEBUG_COPY(sortedlist90->id);\n   } else {\n      sortedlist90 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist90->refC = 1;\n      sortedlist90->id = 90;\n      sortedlist90->n = 0;\n      sortedlist90->root = NULL;\n      DEBUG_NEW(sortedlist90->id);\n   }\n   return sortedlist90;\n}\n\n### File: func8.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop14 = 0;\n   unsigned int loopLimit14 = (rand()%loopsFactor)/2 + 1;\n   for(; loop14 < loopLimit14; loop14++) {\n      sortedlist_t* sortedlist85;\n      if (pCounter > 0) {\n         sortedlist85 = vars->data[--pCounter];\n         sortedlist85->refC++;\n         DEBUG_COPY(sortedlist85->id);\n      } else {\n         sortedlist85 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist85->refC = 1;\n         sortedlist85->id = 85;\n         sortedlist85->n = 0;\n         sortedlist85->root = NULL;\n         DEBUG_NEW(sortedlist85->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist85;\n      sortedlist_t* sortedlist86 = func19(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist86->id);\n      free(params0.data);\n      sortedlist86->refC--;\n      if(sortedlist86->refC == 0){\n           cell_t* cell47 = sortedlist86->root;\n           cell_t* tmp47  = NULL;\n           while(cell47 != NULL) {\n               tmp47 = cell47->next;\n               free(cell47);\n               cell47 = tmp47;\n           }\n           free(sortedlist86);\n           DEBUG_FREE(sortedlist86->id);\n      }\n      sortedlist85->refC--;\n      if(sortedlist85->refC == 0){\n           cell_t* cell48 = sortedlist85->root;\n           cell_t* tmp48  = NULL;\n           while(cell48 != NULL) {\n               tmp48 = cell48->next;\n               free(cell48);\n               cell48 = tmp48;\n           }\n           free(sortedlist85);\n           DEBUG_FREE(sortedlist85->id);\n      }\n   }\n   sortedlist_t* sortedlist87;\n   if (pCounter > 0) {\n      sortedlist87 = vars->data[--pCounter];\n      sortedlist87->refC++;\n      DEBUG_COPY(sortedlist87->id);\n   } else {\n      sortedlist87 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist87->refC = 1;\n      sortedlist87->id = 87;\n      sortedlist87->n = 0;\n      sortedlist87->root = NULL;\n      DEBUG_NEW(sortedlist87->id);\n   }\n   return sortedlist87;\n}\n\n### File: func9.c\n#include \"sortedlist7_19.h\" \nsortedlist_t* func9(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist89 = func10(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist89->id);\n   free(params0.data);\n   return sortedlist89;\n}\n\n### File: rng.c\n#include \"sortedlist7_19.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist7_19.c\n#include \"sortedlist7_19.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell29 = sortedlist0->root;\n              cell_t* tmp29  = NULL;\n              while(cell29 != NULL) {\n                  tmp29 = cell29->next;\n                  free(cell29);\n                  cell29 = tmp29;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist54 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist54->id);\n         free(params0.data);\n         sortedlist54->refC--;\n         if(sortedlist54->refC == 0){\n              cell_t* cell44 = sortedlist54->root;\n              cell_t* tmp44  = NULL;\n              while(cell44 != NULL) {\n                  tmp44 = cell44->next;\n                  free(cell44);\n                  cell44 = tmp44;\n              }\n              free(sortedlist54);\n              DEBUG_FREE(sortedlist54->id);\n         }\n      }\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist80 = func2(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist80->id);\n         free(params0.data);\n         sortedlist80->refC--;\n         if(sortedlist80->refC == 0){\n              cell_t* cell46 = sortedlist80->root;\n              cell_t* tmp46  = NULL;\n              while(cell46 != NULL) {\n                  tmp46 = cell46->next;\n                  free(cell46);\n                  cell46 = tmp46;\n              }\n              free(sortedlist80);\n              DEBUG_FREE(sortedlist80->id);\n         }\n      }\n      else {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist82 = func3(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist82->id);\n         free(params0.data);\n         sortedlist82->refC--;\n         if(sortedlist82->refC == 0){\n              cell_t* cell51 = sortedlist82->root;\n              cell_t* tmp51  = NULL;\n              while(cell51 != NULL) {\n                  tmp51 = cell51->next;\n                  free(cell51);\n                  cell51 = tmp51;\n              }\n              free(sortedlist82);\n              DEBUG_FREE(sortedlist82->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist7_19.h\n#ifndef sortedlist7_19\n#define sortedlist7_19\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func10(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func11(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func12(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func16(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func17(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func28(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func29(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func30(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func34(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func35(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func36(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func40(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func41(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func42(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func18(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func22(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func23(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func24(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func31(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func32(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func33(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func37(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func38(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func39(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func43(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func44(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func45(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func13(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func14(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func15(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func19(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func20(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func21(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func25(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func26(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func27(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func9(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1793033\n    - Instructions: 1700719\n    - Cache References: 79719\n    - Cache Misses: 19300\n    - Branch Instructions: 324577\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist15_14.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist15_14.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist15_14.c\n#include \"sortedlist15_14.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist15_14.h\n#ifndef sortedlist15_14\n#define sortedlist15_14\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4377711\n    - Instructions: 6785569\n    - Cache References: 91412\n    - Cache Misses: 34631\n    - Branch Instructions: 1040321\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array14_17.c\n#include \"array14_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array14_17.h\n#ifndef array14_17\n#define array14_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array14_17.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array14_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1953348\n    - Instructions: 1688621\n    - Cache References: 80883\n    - Cache Misses: 34970\n    - Branch Instructions: 322007\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist6_10.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist6_10.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist6_10.c\n#include \"sortedlist6_10.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist6_10.h\n#ifndef sortedlist6_10\n#define sortedlist6_10\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1699331\n    - Instructions: 1702242\n    - Cache References: 74341\n    - Cache Misses: 15263\n    - Branch Instructions: 324342\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist12_12.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist12_12.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist12_12.c\n#include \"sortedlist12_12.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist12_12.h\n#ifndef sortedlist12_12\n#define sortedlist12_12\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 92077922\n    - Instructions: 200047766\n    - Cache References: 222456\n    - Cache Misses: 54365\n    - Branch Instructions: 29748141\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array3_1.c\n#include \"array3_1.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array3_1.h\n#ifndef array3_1\n#define array3_1\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array3_1.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array1 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array1->id);\n      free(params0.data);\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array3;\n   if (pCounter > 0) {\n      array3 = vars->data[--pCounter];\n      array3->refC++;\n      DEBUG_COPY(array3->id);\n   } else {\n      array3 = (array_t*)malloc(sizeof(array_t));\n      array3->size = 59;\n      array3->refC = 1;\n      array3->id = 3;\n      array3->data = (unsigned int*)malloc(array3->size*sizeof(unsigned int));\n      memset(array3->data, 0, array3->size*sizeof(unsigned int));\n      DEBUG_NEW(array3->id);\n   }\n   return array3;\n}\n\n### File: func1.c\n#include \"array3_1.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array2;\n   if (pCounter > 0) {\n      array2 = vars->data[--pCounter];\n      array2->refC++;\n      DEBUG_COPY(array2->id);\n   } else {\n      array2 = (array_t*)malloc(sizeof(array_t));\n      array2->size = 362;\n      array2->refC = 1;\n      array2->id = 2;\n      array2->data = (unsigned int*)malloc(array2->size*sizeof(unsigned int));\n      memset(array2->data, 0, array2->size*sizeof(unsigned int));\n      DEBUG_NEW(array2->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      for (int i = 0; i < array2->size; i++) {\n         array2->data[i]--;\n      }\n   }\n   return array2;\n}\n\n### File: rng.c\n#include \"array3_1.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4111223\n    - Instructions: 6780884\n    - Cache References: 78027\n    - Cache Misses: 30834\n    - Branch Instructions: 1039115\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array4_17.c\n#include \"array4_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array4_17.h\n#ifndef array4_17\n#define array4_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array4_17.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array4_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2005106\n    - Instructions: 1979844\n    - Cache References: 79829\n    - Cache Misses: 24305\n    - Branch Instructions: 375436\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array15_13.c\n#include \"array15_13.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array0;\n      array0 = (array_t*)malloc(sizeof(array_t));\n      array0->size = 777;\n      array0->refC = 1;\n         array0->id = 0;\n      array0->data = (unsigned int*)malloc(array0->size*sizeof(unsigned int));\n      memset(array0->data, 0, array0->size*sizeof(unsigned int));\n      DEBUG_NEW(array0->id);\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array0;\n      array_t* array1 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array1->id);\n      free(params0.data);\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array15_13.h\n#ifndef array15_13\n#define array15_13\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array15_13.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n   }\n   array_t* array2;\n   if (pCounter > 0) {\n      array2 = vars->data[--pCounter];\n      array2->refC++;\n      DEBUG_COPY(array2->id);\n   } else {\n      array2 = (array_t*)malloc(sizeof(array_t));\n      array2->size = 492;\n      array2->refC = 1;\n      array2->id = 2;\n      array2->data = (unsigned int*)malloc(array2->size*sizeof(unsigned int));\n      memset(array2->data, 0, array2->size*sizeof(unsigned int));\n      DEBUG_NEW(array2->id);\n   }\n   return array2;\n}\n\n### File: rng.c\n#include \"array15_13.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4007582\n    - Instructions: 6785731\n    - Cache References: 84672\n    - Cache Misses: 20511\n    - Branch Instructions: 1040038\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array12_17.c\n#include \"array12_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array12_17.h\n#ifndef array12_17\n#define array12_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array12_17.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array12_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1734297\n    - Instructions: 1681465\n    - Cache References: 69944\n    - Cache Misses: 19038\n    - Branch Instructions: 321351\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist7_7.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist7_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist7_7.c\n#include \"sortedlist7_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist7_7.h\n#ifndef sortedlist7_7\n#define sortedlist7_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7158259\n    - Instructions: 13251659\n    - Cache References: 103638\n    - Cache Misses: 29014\n    - Branch Instructions: 2545523\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist9_18.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist9_18.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist9_18.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist9_18.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist9_18.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist9_18.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist9_18.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist9_18.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist9_18.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist9_18.c\n#include \"sortedlist9_18.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist9->id);\n         free(params0.data);\n         sortedlist9->refC--;\n         if(sortedlist9->refC == 0){\n              cell_t* cell7 = sortedlist9->root;\n              cell_t* tmp7  = NULL;\n              while(cell7 != NULL) {\n                  tmp7 = cell7->next;\n                  free(cell7);\n                  cell7 = tmp7;\n              }\n              free(sortedlist9);\n              DEBUG_FREE(sortedlist9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist9_18.h\n#ifndef sortedlist9_18\n#define sortedlist9_18\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1821250\n    - Instructions: 1695225\n    - Cache References: 75736\n    - Cache Misses: 25385\n    - Branch Instructions: 322876\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist1_12.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist1_12.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist1_12.c\n#include \"sortedlist1_12.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist1_12.h\n#ifndef sortedlist1_12\n#define sortedlist1_12\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 3591846\n    - Instructions: 2936630\n    - Cache References: 97976\n    - Cache Misses: 35922\n    - Branch Instructions: 555834\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array9_4.c\n#include \"array9_4.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      unsigned int loop0 = 0;\n      unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n      for(; loop0 < loopLimit0; loop0++) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n   }\n   else {\n      unsigned int loop2 = 0;\n      unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n      for(; loop2 < loopLimit2; loop2++) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(array9->id);\n         free(params0.data);\n         array9->refC--;\n         if(array9->refC == 0) {\n            free(array9->data);\n            free(array9);\n            DEBUG_FREE(array9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array9_4.h\n#ifndef array9_4\n#define array9_4\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array9_4.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array9_4.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array9_4.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array9_4.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array9_4.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array9_4.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array9_4.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array9_4.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array9_4.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7977182\n    - Instructions: 13325905\n    - Cache References: 128683\n    - Cache Misses: 40423\n    - Branch Instructions: 2554772\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist12_18.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist12_18.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist12_18.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist12_18.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist12_18.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist12_18.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist12_18.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist12_18.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist12_18.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist12_18.c\n#include \"sortedlist12_18.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist9->id);\n         free(params0.data);\n         sortedlist9->refC--;\n         if(sortedlist9->refC == 0){\n              cell_t* cell7 = sortedlist9->root;\n              cell_t* tmp7  = NULL;\n              while(cell7 != NULL) {\n                  tmp7 = cell7->next;\n                  free(cell7);\n                  cell7 = tmp7;\n              }\n              free(sortedlist9);\n              DEBUG_FREE(sortedlist9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist12_18.h\n#ifndef sortedlist12_18\n#define sortedlist12_18\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2171906\n    - Instructions: 1702548\n    - Cache References: 82393\n    - Cache Misses: 23408\n    - Branch Instructions: 324696\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist14_3.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist14_3.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist14_3.c\n#include \"sortedlist14_3.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist14_3.h\n#ifndef sortedlist14_3\n#define sortedlist14_3\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1582770\n    - Instructions: 1398977\n    - Cache References: 72967\n    - Cache Misses: 21742\n    - Branch Instructions: 264378\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist4_17.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist4_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist4_17.c\n#include \"sortedlist4_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist4_17.h\n#ifndef sortedlist4_17\n#define sortedlist4_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1594624\n    - Instructions: 1138093\n    - Cache References: 72474\n    - Cache Misses: 24974\n    - Branch Instructions: 210177\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array9_2.c\n#include \"array9_2.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   return 0;\n}\n\n### File: array9_2.h\n#ifndef array9_2\n#define array9_2\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array9_2.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array9_2.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array9_2.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array9_2.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array9_2.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array9_2.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array9_2.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array9_2.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array9_2.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 65939968\n    - Instructions: 79487535\n    - Cache References: 274479\n    - Cache Misses: 61799\n    - Branch Instructions: 15464689\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist3_20.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell4 = sortedlist2->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell5 = sortedlist1->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist9;\n   if (pCounter > 0) {\n      sortedlist9 = vars->data[--pCounter];\n      sortedlist9->refC++;\n      DEBUG_COPY(sortedlist9->id);\n   } else {\n      sortedlist9 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist9->refC = 1;\n      sortedlist9->id = 9;\n      sortedlist9->n = 0;\n      sortedlist9->root = NULL;\n      DEBUG_NEW(sortedlist9->id);\n   }\n   return sortedlist9;\n}\n\n### File: func1.c\n#include \"sortedlist3_20.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist11 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist11->id);\n   free(params0.data);\n   return sortedlist11;\n}\n\n### File: func2.c\n#include \"sortedlist3_20.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist20;\n   if (pCounter > 0) {\n      sortedlist20 = vars->data[--pCounter];\n      sortedlist20->refC++;\n      DEBUG_COPY(sortedlist20->id);\n   } else {\n      sortedlist20 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist20->refC = 1;\n      sortedlist20->id = 20;\n      sortedlist20->n = 0;\n      sortedlist20->root = NULL;\n      DEBUG_NEW(sortedlist20->id);\n   }\n   unsigned int loop8 = 0;\n   unsigned int loopLimit8 = (rand()%loopsFactor)/3 + 1;\n   for(; loop8 < loopLimit8; loop8++) {\n      if(sortedlist20 != NULL && sortedlist20->n > 0)\n      {\n          cell_t* cell14 = sortedlist20->root;\n          if(cell14->val == 26)\n          {\n              cell14 = cell14->next;\n              sortedlist20->n--;\n          }else{\n              while(cell14->next != NULL && cell14->next->val != 26) cell14 = cell14->next;\n              if(cell14->next != NULL)\n              {\n                  cell14 = cell14->next->next;\n                  sortedlist20->n--;\n              }\n           }\n      }\n   }\n   return sortedlist20;\n}\n\n### File: func3.c\n#include \"sortedlist3_20.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist12 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist12->id);\n      free(params0.data);\n      sortedlist12->refC--;\n      if(sortedlist12->refC == 0){\n           cell_t* cell8 = sortedlist12->root;\n           cell_t* tmp8  = NULL;\n           while(cell8 != NULL) {\n               tmp8 = cell8->next;\n               free(cell8);\n               cell8 = tmp8;\n           }\n           free(sortedlist12);\n           DEBUG_FREE(sortedlist12->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist14 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist14->id);\n      free(params0.data);\n      sortedlist14->refC--;\n      if(sortedlist14->refC == 0){\n           cell_t* cell12 = sortedlist14->root;\n           cell_t* tmp12  = NULL;\n           while(cell12 != NULL) {\n               tmp12 = cell12->next;\n               free(cell12);\n               cell12 = tmp12;\n           }\n           free(sortedlist14);\n           DEBUG_FREE(sortedlist14->id);\n      }\n   }\n   sortedlist_t* sortedlist18;\n   if (pCounter > 0) {\n      sortedlist18 = vars->data[--pCounter];\n      sortedlist18->refC++;\n      DEBUG_COPY(sortedlist18->id);\n   } else {\n      sortedlist18 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist18->refC = 1;\n      sortedlist18->id = 18;\n      sortedlist18->n = 0;\n      sortedlist18->root = NULL;\n      DEBUG_NEW(sortedlist18->id);\n   }\n   return sortedlist18;\n}\n\n### File: func4.c\n#include \"sortedlist3_20.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist13;\n   if (pCounter > 0) {\n      sortedlist13 = vars->data[--pCounter];\n      sortedlist13->refC++;\n      DEBUG_COPY(sortedlist13->id);\n   } else {\n      sortedlist13 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist13->refC = 1;\n      sortedlist13->id = 13;\n      sortedlist13->n = 0;\n      sortedlist13->root = NULL;\n      DEBUG_NEW(sortedlist13->id);\n   }\n   unsigned int loop5 = 0;\n   unsigned int loopLimit5 = (rand()%loopsFactor)/3 + 1;\n   for(; loop5 < loopLimit5; loop5++) {\n      if(sortedlist13 != NULL && sortedlist13->n > 0)\n      {\n          cell_t* cell7 = sortedlist13->root;\n          if(cell7->val == 92)\n          {\n              cell7 = cell7->next;\n              sortedlist13->n--;\n          }else{\n              while(cell7->next != NULL && cell7->next->val != 92) cell7 = cell7->next;\n              if(cell7->next != NULL)\n              {\n                  cell7 = cell7->next->next;\n                  sortedlist13->n--;\n              }\n           }\n      }\n   }\n   return sortedlist13;\n}\n\n### File: func5.c\n#include \"sortedlist3_20.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop6 = 0;\n   unsigned int loopLimit6 = (rand()%loopsFactor)/3 + 1;\n   for(; loop6 < loopLimit6; loop6++) {\n      sortedlist_t* sortedlist15;\n      if (pCounter > 0) {\n         sortedlist15 = vars->data[--pCounter];\n         sortedlist15->refC++;\n         DEBUG_COPY(sortedlist15->id);\n      } else {\n         sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist15->refC = 1;\n         sortedlist15->id = 15;\n         sortedlist15->n = 0;\n         sortedlist15->root = NULL;\n         DEBUG_NEW(sortedlist15->id);\n      }\n      sortedlist_t* sortedlist16;\n      if (pCounter > 0) {\n         sortedlist16 = vars->data[--pCounter];\n         sortedlist16->refC++;\n         DEBUG_COPY(sortedlist16->id);\n      } else {\n         sortedlist16 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist16->refC = 1;\n         sortedlist16->id = 16;\n         sortedlist16->n = 0;\n         sortedlist16->root = NULL;\n         DEBUG_NEW(sortedlist16->id);\n      }\n      unsigned int loop7 = 0;\n      unsigned int loopLimit7 = (rand()%loopsFactor)/4 + 1;\n      for(; loop7 < loopLimit7; loop7++) {\n         if(sortedlist16 != NULL && sortedlist16->n > 0)\n         {\n             cell_t* cell9 = sortedlist16->root;\n             if(cell9->val == 62)\n             {\n                 cell9 = cell9->next;\n                 sortedlist16->n--;\n             }else{\n                 while(cell9->next != NULL && cell9->next->val != 62) cell9 = cell9->next;\n                 if(cell9->next != NULL)\n                 {\n                     cell9 = cell9->next->next;\n                     sortedlist16->n--;\n                 }\n              }\n         }\n      }\n      sortedlist16->refC--;\n      if(sortedlist16->refC == 0){\n           cell_t* cell10 = sortedlist16->root;\n           cell_t* tmp10  = NULL;\n           while(cell10 != NULL) {\n               tmp10 = cell10->next;\n               free(cell10);\n               cell10 = tmp10;\n           }\n           free(sortedlist16);\n           DEBUG_FREE(sortedlist16->id);\n      }\n      sortedlist15->refC--;\n      if(sortedlist15->refC == 0){\n           cell_t* cell11 = sortedlist15->root;\n           cell_t* tmp11  = NULL;\n           while(cell11 != NULL) {\n               tmp11 = cell11->next;\n               free(cell11);\n               cell11 = tmp11;\n           }\n           free(sortedlist15);\n           DEBUG_FREE(sortedlist15->id);\n      }\n   }\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   return sortedlist17;\n}\n\n### File: func6.c\n#include \"sortedlist3_20.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell1 = sortedlist3->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell3 = sortedlist5->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func7.c\n#include \"sortedlist3_20.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist4 != NULL && sortedlist4->n > 0)\n      {\n          cell_t* cell0 = sortedlist4->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist4->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist4->n--;\n              }\n           }\n      }\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist3_20.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/3 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      sortedlist_t* sortedlist6;\n      if (pCounter > 0) {\n         sortedlist6 = vars->data[--pCounter];\n         sortedlist6->refC++;\n         DEBUG_COPY(sortedlist6->id);\n      } else {\n         sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist6->refC = 1;\n         sortedlist6->id = 6;\n         sortedlist6->n = 0;\n         sortedlist6->root = NULL;\n         DEBUG_NEW(sortedlist6->id);\n      }\n      sortedlist6->refC--;\n      if(sortedlist6->refC == 0){\n           cell_t* cell2 = sortedlist6->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist6);\n           DEBUG_FREE(sortedlist6->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: rng.c\n#include \"sortedlist3_20.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist3_20.c\n#include \"sortedlist3_20.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell6 = sortedlist0->root;\n              cell_t* tmp6  = NULL;\n              while(cell6 != NULL) {\n                  tmp6 = cell6->next;\n                  free(cell6);\n                  cell6 = tmp6;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop4 = 0;\n         unsigned int loopLimit4 = (rand()%loopsFactor)/2 + 1;\n         for(; loop4 < loopLimit4; loop4++) {\n            if(rng() & 1) {\n               sortedlist_t_param params0;\n               params0.size = 0;\n               params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n               sortedlist_t* sortedlist10 = func1(&params0, loopsFactor);\n               DEBUG_RETURN(sortedlist10->id);\n               free(params0.data);\n               sortedlist10->refC--;\n               if(sortedlist10->refC == 0){\n                    cell_t* cell13 = sortedlist10->root;\n                    cell_t* tmp13  = NULL;\n                    while(cell13 != NULL) {\n                        tmp13 = cell13->next;\n                        free(cell13);\n                        cell13 = tmp13;\n                    }\n                    free(sortedlist10);\n                    DEBUG_FREE(sortedlist10->id);\n               }\n            }\n            else {\n               sortedlist_t_param params0;\n               params0.size = 0;\n               params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n               sortedlist_t* sortedlist19 = func2(&params0, loopsFactor);\n               DEBUG_RETURN(sortedlist19->id);\n               free(params0.data);\n               sortedlist19->refC--;\n               if(sortedlist19->refC == 0){\n                    cell_t* cell15 = sortedlist19->root;\n                    cell_t* tmp15  = NULL;\n                    while(cell15 != NULL) {\n                        tmp15 = cell15->next;\n                        free(cell15);\n                        cell15 = tmp15;\n                    }\n                    free(sortedlist19);\n                    DEBUG_FREE(sortedlist19->id);\n               }\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist3_20.h\n#ifndef sortedlist3_20\n#define sortedlist3_20\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1845683\n    - Instructions: 1690046\n    - Cache References: 87313\n    - Cache Misses: 21782\n    - Branch Instructions: 319725\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist12_13.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n   }\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   return sortedlist2;\n}\n\n### File: rng.c\n#include \"sortedlist12_13.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist12_13.c\n#include \"sortedlist12_13.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist0 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist0->refC = 1;\n      sortedlist0->id = 0;\n      sortedlist0->n = 0;\n      sortedlist0->root = NULL;\n      DEBUG_NEW(sortedlist0->id);\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist0;\n      sortedlist_t* sortedlist1 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist1->id);\n      free(params0.data);\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell0 = sortedlist1->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist12_13.h\n#ifndef sortedlist12_13\n#define sortedlist12_13\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7423869\n    - Instructions: 14367085\n    - Cache References: 82199\n    - Cache Misses: 18879\n    - Branch Instructions: 2146413\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array11_7.c\n#include \"array11_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array11_7.h\n#ifndef array11_7\n#define array11_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array11_7.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array11_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1892914\n    - Instructions: 1699394\n    - Cache References: 82764\n    - Cache Misses: 26836\n    - Branch Instructions: 324437\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist13_3.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist13_3.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist13_3.c\n#include \"sortedlist13_3.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist13_3.h\n#ifndef sortedlist13_3\n#define sortedlist13_3\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 13464926\n    - Instructions: 17333907\n    - Cache References: 124340\n    - Cache Misses: 27105\n    - Branch Instructions: 3357287\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist1_20.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell0 = sortedlist1->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   return sortedlist2;\n}\n\n### File: func1.c\n#include \"sortedlist1_20.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist4 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist4->id);\n   free(params0.data);\n   return sortedlist4;\n}\n\n### File: func2.c\n#include \"sortedlist1_20.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist11;\n   if (pCounter > 0) {\n      sortedlist11 = vars->data[--pCounter];\n      sortedlist11->refC++;\n      DEBUG_COPY(sortedlist11->id);\n   } else {\n      sortedlist11 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist11->refC = 1;\n      sortedlist11->id = 11;\n      sortedlist11->n = 0;\n      sortedlist11->root = NULL;\n      DEBUG_NEW(sortedlist11->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/3 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      if(sortedlist11 != NULL && sortedlist11->n > 0)\n      {\n          cell_t* cell5 = sortedlist11->root;\n          if(cell5->val == 86)\n          {\n              cell5 = cell5->next;\n              sortedlist11->n--;\n          }else{\n              while(cell5->next != NULL && cell5->next->val != 86) cell5 = cell5->next;\n              if(cell5->next != NULL)\n              {\n                  cell5 = cell5->next->next;\n                  sortedlist11->n--;\n              }\n           }\n      }\n   }\n   return sortedlist11;\n}\n\n### File: func3.c\n#include \"sortedlist1_20.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell2 = sortedlist5->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist7 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist7->id);\n      free(params0.data);\n      sortedlist7->refC--;\n      if(sortedlist7->refC == 0){\n           cell_t* cell3 = sortedlist7->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist7);\n           DEBUG_FREE(sortedlist7->id);\n      }\n   }\n   sortedlist_t* sortedlist9;\n   if (pCounter > 0) {\n      sortedlist9 = vars->data[--pCounter];\n      sortedlist9->refC++;\n      DEBUG_COPY(sortedlist9->id);\n   } else {\n      sortedlist9 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist9->refC = 1;\n      sortedlist9->id = 9;\n      sortedlist9->n = 0;\n      sortedlist9->root = NULL;\n      DEBUG_NEW(sortedlist9->id);\n   }\n   return sortedlist9;\n}\n\n### File: func4.c\n#include \"sortedlist1_20.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: func5.c\n#include \"sortedlist1_20.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: rng.c\n#include \"sortedlist1_20.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist1_20.c\n#include \"sortedlist1_20.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            if(rng() & 1) {\n               sortedlist_t_param params0;\n               params0.size = 0;\n               params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n               sortedlist_t* sortedlist3 = func1(&params0, loopsFactor);\n               DEBUG_RETURN(sortedlist3->id);\n               free(params0.data);\n               sortedlist3->refC--;\n               if(sortedlist3->refC == 0){\n                    cell_t* cell4 = sortedlist3->root;\n                    cell_t* tmp4  = NULL;\n                    while(cell4 != NULL) {\n                        tmp4 = cell4->next;\n                        free(cell4);\n                        cell4 = tmp4;\n                    }\n                    free(sortedlist3);\n                    DEBUG_FREE(sortedlist3->id);\n               }\n            }\n            else {\n               sortedlist_t_param params0;\n               params0.size = 0;\n               params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n               sortedlist_t* sortedlist10 = func2(&params0, loopsFactor);\n               DEBUG_RETURN(sortedlist10->id);\n               free(params0.data);\n               sortedlist10->refC--;\n               if(sortedlist10->refC == 0){\n                    cell_t* cell6 = sortedlist10->root;\n                    cell_t* tmp6  = NULL;\n                    while(cell6 != NULL) {\n                        tmp6 = cell6->next;\n                        free(cell6);\n                        cell6 = tmp6;\n                    }\n                    free(sortedlist10);\n                    DEBUG_FREE(sortedlist10->id);\n               }\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist1_20.h\n#ifndef sortedlist1_20\n#define sortedlist1_20\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1718456\n    - Instructions: 1672986\n    - Cache References: 64331\n    - Cache Misses: 17044\n    - Branch Instructions: 319553\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist9_12.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist9_12.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist9_12.c\n#include \"sortedlist9_12.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist9_12.h\n#ifndef sortedlist9_12\n#define sortedlist9_12\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 87374912\n    - Instructions: 199843920\n    - Cache References: 140071\n    - Cache Misses: 26469\n    - Branch Instructions: 29711597\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array13_1.c\n#include \"array13_1.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array13_1.h\n#ifndef array13_1\n#define array13_1\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array13_1.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array1 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array1->id);\n      free(params0.data);\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array3;\n   if (pCounter > 0) {\n      array3 = vars->data[--pCounter];\n      array3->refC++;\n      DEBUG_COPY(array3->id);\n   } else {\n      array3 = (array_t*)malloc(sizeof(array_t));\n      array3->size = 59;\n      array3->refC = 1;\n      array3->id = 3;\n      array3->data = (unsigned int*)malloc(array3->size*sizeof(unsigned int));\n      memset(array3->data, 0, array3->size*sizeof(unsigned int));\n      DEBUG_NEW(array3->id);\n   }\n   return array3;\n}\n\n### File: func1.c\n#include \"array13_1.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array2;\n   if (pCounter > 0) {\n      array2 = vars->data[--pCounter];\n      array2->refC++;\n      DEBUG_COPY(array2->id);\n   } else {\n      array2 = (array_t*)malloc(sizeof(array_t));\n      array2->size = 362;\n      array2->refC = 1;\n      array2->id = 2;\n      array2->data = (unsigned int*)malloc(array2->size*sizeof(unsigned int));\n      memset(array2->data, 0, array2->size*sizeof(unsigned int));\n      DEBUG_NEW(array2->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      for (int i = 0; i < array2->size; i++) {\n         array2->data[i]--;\n      }\n   }\n   return array2;\n}\n\n### File: rng.c\n#include \"array13_1.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 71555039\n    - Instructions: 103703799\n    - Cache References: 374249\n    - Cache Misses: 53612\n    - Branch Instructions: 20400478\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist4_20.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell6 = sortedlist2->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell7 = sortedlist1->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist10;\n   if (pCounter > 0) {\n      sortedlist10 = vars->data[--pCounter];\n      sortedlist10->refC++;\n      DEBUG_COPY(sortedlist10->id);\n   } else {\n      sortedlist10 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist10->refC = 1;\n      sortedlist10->id = 10;\n      sortedlist10->n = 0;\n      sortedlist10->root = NULL;\n      DEBUG_NEW(sortedlist10->id);\n   }\n   return sortedlist10;\n}\n\n### File: func1.c\n#include \"sortedlist4_20.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist12 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist12->id);\n   free(params0.data);\n   return sortedlist12;\n}\n\n### File: func2.c\n#include \"sortedlist4_20.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist21;\n   if (pCounter > 0) {\n      sortedlist21 = vars->data[--pCounter];\n      sortedlist21->refC++;\n      DEBUG_COPY(sortedlist21->id);\n   } else {\n      sortedlist21 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist21->refC = 1;\n      sortedlist21->id = 21;\n      sortedlist21->n = 0;\n      sortedlist21->root = NULL;\n      DEBUG_NEW(sortedlist21->id);\n   }\n   unsigned int loop9 = 0;\n   unsigned int loopLimit9 = (rand()%loopsFactor)/3 + 1;\n   for(; loop9 < loopLimit9; loop9++) {\n      if(sortedlist21 != NULL && sortedlist21->n > 0)\n      {\n          cell_t* cell16 = sortedlist21->root;\n          if(cell16->val == 26)\n          {\n              cell16 = cell16->next;\n              sortedlist21->n--;\n          }else{\n              while(cell16->next != NULL && cell16->next->val != 26) cell16 = cell16->next;\n              if(cell16->next != NULL)\n              {\n                  cell16 = cell16->next->next;\n                  sortedlist21->n--;\n              }\n           }\n      }\n   }\n   return sortedlist21;\n}\n\n### File: func3.c\n#include \"sortedlist4_20.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell10 = sortedlist13->root;\n           cell_t* tmp10  = NULL;\n           while(cell10 != NULL) {\n               tmp10 = cell10->next;\n               free(cell10);\n               cell10 = tmp10;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist15 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist15->id);\n      free(params0.data);\n      sortedlist15->refC--;\n      if(sortedlist15->refC == 0){\n           cell_t* cell14 = sortedlist15->root;\n           cell_t* tmp14  = NULL;\n           while(cell14 != NULL) {\n               tmp14 = cell14->next;\n               free(cell14);\n               cell14 = tmp14;\n           }\n           free(sortedlist15);\n           DEBUG_FREE(sortedlist15->id);\n      }\n   }\n   sortedlist_t* sortedlist19;\n   if (pCounter > 0) {\n      sortedlist19 = vars->data[--pCounter];\n      sortedlist19->refC++;\n      DEBUG_COPY(sortedlist19->id);\n   } else {\n      sortedlist19 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist19->refC = 1;\n      sortedlist19->id = 19;\n      sortedlist19->n = 0;\n      sortedlist19->root = NULL;\n      DEBUG_NEW(sortedlist19->id);\n   }\n   return sortedlist19;\n}\n\n### File: func4.c\n#include \"sortedlist4_20.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   unsigned int loop6 = 0;\n   unsigned int loopLimit6 = (rand()%loopsFactor)/3 + 1;\n   for(; loop6 < loopLimit6; loop6++) {\n      if(sortedlist14 != NULL && sortedlist14->n > 0)\n      {\n          cell_t* cell9 = sortedlist14->root;\n          if(cell9->val == 21)\n          {\n              cell9 = cell9->next;\n              sortedlist14->n--;\n          }else{\n              while(cell9->next != NULL && cell9->next->val != 21) cell9 = cell9->next;\n              if(cell9->next != NULL)\n              {\n                  cell9 = cell9->next->next;\n                  sortedlist14->n--;\n              }\n           }\n      }\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist4_20.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop7 = 0;\n   unsigned int loopLimit7 = (rand()%loopsFactor)/3 + 1;\n   for(; loop7 < loopLimit7; loop7++) {\n      sortedlist_t* sortedlist16;\n      if (pCounter > 0) {\n         sortedlist16 = vars->data[--pCounter];\n         sortedlist16->refC++;\n         DEBUG_COPY(sortedlist16->id);\n      } else {\n         sortedlist16 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist16->refC = 1;\n         sortedlist16->id = 16;\n         sortedlist16->n = 0;\n         sortedlist16->root = NULL;\n         DEBUG_NEW(sortedlist16->id);\n      }\n      sortedlist_t* sortedlist17;\n      if (pCounter > 0) {\n         sortedlist17 = vars->data[--pCounter];\n         sortedlist17->refC++;\n         DEBUG_COPY(sortedlist17->id);\n      } else {\n         sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist17->refC = 1;\n         sortedlist17->id = 17;\n         sortedlist17->n = 0;\n         sortedlist17->root = NULL;\n         DEBUG_NEW(sortedlist17->id);\n      }\n      unsigned int loop8 = 0;\n      unsigned int loopLimit8 = (rand()%loopsFactor)/4 + 1;\n      for(; loop8 < loopLimit8; loop8++) {\n         if(sortedlist17 != NULL && sortedlist17->n > 0)\n         {\n             cell_t* cell11 = sortedlist17->root;\n             if(cell11->val == 90)\n             {\n                 cell11 = cell11->next;\n                 sortedlist17->n--;\n             }else{\n                 while(cell11->next != NULL && cell11->next->val != 90) cell11 = cell11->next;\n                 if(cell11->next != NULL)\n                 {\n                     cell11 = cell11->next->next;\n                     sortedlist17->n--;\n                 }\n              }\n         }\n      }\n      sortedlist17->refC--;\n      if(sortedlist17->refC == 0){\n           cell_t* cell12 = sortedlist17->root;\n           cell_t* tmp12  = NULL;\n           while(cell12 != NULL) {\n               tmp12 = cell12->next;\n               free(cell12);\n               cell12 = tmp12;\n           }\n           free(sortedlist17);\n           DEBUG_FREE(sortedlist17->id);\n      }\n      sortedlist16->refC--;\n      if(sortedlist16->refC == 0){\n           cell_t* cell13 = sortedlist16->root;\n           cell_t* tmp13  = NULL;\n           while(cell13 != NULL) {\n               tmp13 = cell13->next;\n               free(cell13);\n               cell13 = tmp13;\n           }\n           free(sortedlist16);\n           DEBUG_FREE(sortedlist16->id);\n      }\n   }\n   sortedlist_t* sortedlist18;\n   if (pCounter > 0) {\n      sortedlist18 = vars->data[--pCounter];\n      sortedlist18->refC++;\n      DEBUG_COPY(sortedlist18->id);\n   } else {\n      sortedlist18 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist18->refC = 1;\n      sortedlist18->id = 18;\n      sortedlist18->n = 0;\n      sortedlist18->root = NULL;\n      DEBUG_NEW(sortedlist18->id);\n   }\n   return sortedlist18;\n}\n\n### File: func6.c\n#include \"sortedlist4_20.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell1 = sortedlist3->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell5 = sortedlist5->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist9;\n   if (pCounter > 0) {\n      sortedlist9 = vars->data[--pCounter];\n      sortedlist9->refC++;\n      DEBUG_COPY(sortedlist9->id);\n   } else {\n      sortedlist9 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist9->refC = 1;\n      sortedlist9->id = 9;\n      sortedlist9->n = 0;\n      sortedlist9->root = NULL;\n      DEBUG_NEW(sortedlist9->id);\n   }\n   return sortedlist9;\n}\n\n### File: func7.c\n#include \"sortedlist4_20.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist4 != NULL && sortedlist4->n > 0)\n      {\n          cell_t* cell0 = sortedlist4->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist4->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist4->n--;\n              }\n           }\n      }\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist4_20.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/3 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      sortedlist_t* sortedlist6;\n      if (pCounter > 0) {\n         sortedlist6 = vars->data[--pCounter];\n         sortedlist6->refC++;\n         DEBUG_COPY(sortedlist6->id);\n      } else {\n         sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist6->refC = 1;\n         sortedlist6->id = 6;\n         sortedlist6->n = 0;\n         sortedlist6->root = NULL;\n         DEBUG_NEW(sortedlist6->id);\n      }\n      sortedlist_t* sortedlist7;\n      if (pCounter > 0) {\n         sortedlist7 = vars->data[--pCounter];\n         sortedlist7->refC++;\n         DEBUG_COPY(sortedlist7->id);\n      } else {\n         sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist7->refC = 1;\n         sortedlist7->id = 7;\n         sortedlist7->n = 0;\n         sortedlist7->root = NULL;\n         DEBUG_NEW(sortedlist7->id);\n      }\n      unsigned int loop4 = 0;\n      unsigned int loopLimit4 = (rand()%loopsFactor)/4 + 1;\n      for(; loop4 < loopLimit4; loop4++) {\n         if(sortedlist7 != NULL && sortedlist7->n > 0)\n         {\n             cell_t* cell2 = sortedlist7->root;\n             if(cell2->val == 93)\n             {\n                 cell2 = cell2->next;\n                 sortedlist7->n--;\n             }else{\n                 while(cell2->next != NULL && cell2->next->val != 93) cell2 = cell2->next;\n                 if(cell2->next != NULL)\n                 {\n                     cell2 = cell2->next->next;\n                     sortedlist7->n--;\n                 }\n              }\n         }\n      }\n      sortedlist7->refC--;\n      if(sortedlist7->refC == 0){\n           cell_t* cell3 = sortedlist7->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist7);\n           DEBUG_FREE(sortedlist7->id);\n      }\n      sortedlist6->refC--;\n      if(sortedlist6->refC == 0){\n           cell_t* cell4 = sortedlist6->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist6);\n           DEBUG_FREE(sortedlist6->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: rng.c\n#include \"sortedlist4_20.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist4_20.c\n#include \"sortedlist4_20.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell8 = sortedlist0->root;\n              cell_t* tmp8  = NULL;\n              while(cell8 != NULL) {\n                  tmp8 = cell8->next;\n                  free(cell8);\n                  cell8 = tmp8;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop5 = 0;\n         unsigned int loopLimit5 = (rand()%loopsFactor)/2 + 1;\n         for(; loop5 < loopLimit5; loop5++) {\n            if(rng() & 1) {\n               sortedlist_t_param params0;\n               params0.size = 0;\n               params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n               sortedlist_t* sortedlist11 = func1(&params0, loopsFactor);\n               DEBUG_RETURN(sortedlist11->id);\n               free(params0.data);\n               sortedlist11->refC--;\n               if(sortedlist11->refC == 0){\n                    cell_t* cell15 = sortedlist11->root;\n                    cell_t* tmp15  = NULL;\n                    while(cell15 != NULL) {\n                        tmp15 = cell15->next;\n                        free(cell15);\n                        cell15 = tmp15;\n                    }\n                    free(sortedlist11);\n                    DEBUG_FREE(sortedlist11->id);\n               }\n            }\n            else {\n               sortedlist_t_param params0;\n               params0.size = 0;\n               params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n               sortedlist_t* sortedlist20 = func2(&params0, loopsFactor);\n               DEBUG_RETURN(sortedlist20->id);\n               free(params0.data);\n               sortedlist20->refC--;\n               if(sortedlist20->refC == 0){\n                    cell_t* cell17 = sortedlist20->root;\n                    cell_t* tmp17  = NULL;\n                    while(cell17 != NULL) {\n                        tmp17 = cell17->next;\n                        free(cell17);\n                        cell17 = tmp17;\n                    }\n                    free(sortedlist20);\n                    DEBUG_FREE(sortedlist20->id);\n               }\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist4_20.h\n#ifndef sortedlist4_20\n#define sortedlist4_20\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4058486\n    - Instructions: 6781288\n    - Cache References: 80139\n    - Cache Misses: 19326\n    - Branch Instructions: 1039259\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array13_17.c\n#include \"array13_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array13_17.h\n#ifndef array13_17\n#define array13_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array13_17.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array13_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1923284\n    - Instructions: 1700653\n    - Cache References: 83177\n    - Cache Misses: 34178\n    - Branch Instructions: 323952\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist15_12.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist15_12.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist15_12.c\n#include \"sortedlist15_12.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist15_12.h\n#ifndef sortedlist15_12\n#define sortedlist15_12\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1730916\n    - Instructions: 1706320\n    - Cache References: 82155\n    - Cache Misses: 23598\n    - Branch Instructions: 324845\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist12_7.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist12_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist12_7.c\n#include \"sortedlist12_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist12_7.h\n#ifndef sortedlist12_7\n#define sortedlist12_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1567359\n    - Instructions: 1134903\n    - Cache References: 76550\n    - Cache Misses: 25239\n    - Branch Instructions: 210441\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array10_8.c\n#include \"array10_8.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   return 0;\n}\n\n### File: array10_8.h\n#ifndef array10_8\n#define array10_8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array10_8.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array10_8.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array10_8.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array10_8.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array10_8.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array10_8.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array10_8.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array10_8.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array10_8.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2216720\n    - Instructions: 1685805\n    - Cache References: 85172\n    - Cache Misses: 32879\n    - Branch Instructions: 321531\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist3_7.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist3_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist3_7.c\n#include \"sortedlist3_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist3_7.h\n#ifndef sortedlist3_7\n#define sortedlist3_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2066562\n    - Instructions: 2388574\n    - Cache References: 81609\n    - Cache Misses: 20174\n    - Branch Instructions: 451165\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist11_4.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist11_4.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist11_4.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist11_4.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist11_4.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist11_4.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist11_4.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist11_4.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist11_4.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist11_4.c\n#include \"sortedlist11_4.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      unsigned int loop0 = 0;\n      unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n      for(; loop0 < loopLimit0; loop0++) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n   }\n   else {\n      unsigned int loop2 = 0;\n      unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n      for(; loop2 < loopLimit2; loop2++) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist9->id);\n         free(params0.data);\n         sortedlist9->refC--;\n         if(sortedlist9->refC == 0){\n              cell_t* cell7 = sortedlist9->root;\n              cell_t* tmp7  = NULL;\n              while(cell7 != NULL) {\n                  tmp7 = cell7->next;\n                  free(cell7);\n                  cell7 = tmp7;\n              }\n              free(sortedlist9);\n              DEBUG_FREE(sortedlist9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist11_4.h\n#ifndef sortedlist11_4\n#define sortedlist11_4\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2163594\n    - Instructions: 2399040\n    - Cache References: 78335\n    - Cache Misses: 27071\n    - Branch Instructions: 452880\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist13_4.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist13_4.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist13_4.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist13_4.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist13_4.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist13_4.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist13_4.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist13_4.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist13_4.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist13_4.c\n#include \"sortedlist13_4.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      unsigned int loop0 = 0;\n      unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n      for(; loop0 < loopLimit0; loop0++) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n   }\n   else {\n      unsigned int loop2 = 0;\n      unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n      for(; loop2 < loopLimit2; loop2++) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist9->id);\n         free(params0.data);\n         sortedlist9->refC--;\n         if(sortedlist9->refC == 0){\n              cell_t* cell7 = sortedlist9->root;\n              cell_t* tmp7  = NULL;\n              while(cell7 != NULL) {\n                  tmp7 = cell7->next;\n                  free(cell7);\n                  cell7 = tmp7;\n              }\n              free(sortedlist9);\n              DEBUG_FREE(sortedlist9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist13_4.h\n#ifndef sortedlist13_4\n#define sortedlist13_4\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7246907\n    - Instructions: 13921481\n    - Cache References: 82148\n    - Cache Misses: 20688\n    - Branch Instructions: 2083176\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array10_12.c\n#include \"array10_12.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array10_12.h\n#ifndef array10_12\n#define array10_12\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array10_12.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array10_12.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1733940\n    - Instructions: 1683377\n    - Cache References: 68600\n    - Cache Misses: 21147\n    - Branch Instructions: 321080\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist9_10.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist9_10.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist9_10.c\n#include \"sortedlist9_10.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist9_10.h\n#ifndef sortedlist9_10\n#define sortedlist9_10\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1734378\n    - Instructions: 1421659\n    - Cache References: 87655\n    - Cache Misses: 22712\n    - Branch Instructions: 268146\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist13_16.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist13_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist13_16.c\n#include \"sortedlist13_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist13_16.h\n#ifndef sortedlist13_16\n#define sortedlist13_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1877644\n    - Instructions: 1676905\n    - Cache References: 75922\n    - Cache Misses: 22486\n    - Branch Instructions: 317378\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist2_13.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n   }\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   return sortedlist2;\n}\n\n### File: rng.c\n#include \"sortedlist2_13.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist2_13.c\n#include \"sortedlist2_13.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist0 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist0->refC = 1;\n      sortedlist0->id = 0;\n      sortedlist0->n = 0;\n      sortedlist0->root = NULL;\n      DEBUG_NEW(sortedlist0->id);\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist0;\n      sortedlist_t* sortedlist1 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist1->id);\n      free(params0.data);\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell0 = sortedlist1->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist2_13.h\n#ifndef sortedlist2_13\n#define sortedlist2_13\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2237519\n    - Instructions: 2895118\n    - Cache References: 75029\n    - Cache Misses: 20643\n    - Branch Instructions: 550369\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array5_4.c\n#include \"array5_4.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      unsigned int loop0 = 0;\n      unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n      for(; loop0 < loopLimit0; loop0++) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n   }\n   else {\n      unsigned int loop2 = 0;\n      unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n      for(; loop2 < loopLimit2; loop2++) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(array9->id);\n         free(params0.data);\n         array9->refC--;\n         if(array9->refC == 0) {\n            free(array9->data);\n            free(array9);\n            DEBUG_FREE(array9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array5_4.h\n#ifndef array5_4\n#define array5_4\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array5_4.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array5_4.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array5_4.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array5_4.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array5_4.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array5_4.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array5_4.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array5_4.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array5_4.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 8310627\n    - Instructions: 14457030\n    - Cache References: 110712\n    - Cache Misses: 43386\n    - Branch Instructions: 2160929\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array8_14.c\n#include \"array8_14.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array8_14.h\n#ifndef array8_14\n#define array8_14\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array8_14.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array8_14.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 26777316\n    - Instructions: 33233182\n    - Cache References: 166612\n    - Cache Misses: 32618\n    - Branch Instructions: 6381853\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist3_6.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist3_6.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist3_6.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist3_6.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist3_6.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist3_6.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist3_6.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist3_6.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist3_6.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist3_6.c\n#include \"sortedlist3_6.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            sortedlist_t_param params0;\n            params0.size = 0;\n            params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n            sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n            DEBUG_RETURN(sortedlist9->id);\n            free(params0.data);\n            sortedlist9->refC--;\n            if(sortedlist9->refC == 0){\n                 cell_t* cell7 = sortedlist9->root;\n                 cell_t* tmp7  = NULL;\n                 while(cell7 != NULL) {\n                     tmp7 = cell7->next;\n                     free(cell7);\n                     cell7 = tmp7;\n                 }\n                 free(sortedlist9);\n                 DEBUG_FREE(sortedlist9->id);\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist3_6.h\n#ifndef sortedlist3_6\n#define sortedlist3_6\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1921195\n    - Instructions: 1688232\n    - Cache References: 82601\n    - Cache Misses: 21921\n    - Branch Instructions: 322154\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist13_10.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist13_10.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist13_10.c\n#include \"sortedlist13_10.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist13_10.h\n#ifndef sortedlist13_10\n#define sortedlist13_10\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1820830\n    - Instructions: 1698928\n    - Cache References: 84056\n    - Cache Misses: 21714\n    - Branch Instructions: 323965\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist13_12.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist13_12.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist13_12.c\n#include \"sortedlist13_12.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist13_12.h\n#ifndef sortedlist13_12\n#define sortedlist13_12\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2137318\n    - Instructions: 1411559\n    - Cache References: 86424\n    - Cache Misses: 29726\n    - Branch Instructions: 265766\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist5_16.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist5_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist5_16.c\n#include \"sortedlist5_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist5_16.h\n#ifndef sortedlist5_16\n#define sortedlist5_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 8515647\n    - Instructions: 16479549\n    - Cache References: 92998\n    - Cache Misses: 30636\n    - Branch Instructions: 2544907\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array13_15.c\n#include \"array13_15.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array_t_param params1;\n      params1.size = 1;\n      params1.data = (array_t**)malloc(params1.size*sizeof(array_t*));\n      params1.data[0] = array0;\n      array_t* array2 = func1(&params1, loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params1.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array13_15.h\n#ifndef array13_15\n#define array13_15\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array13_15.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: func1.c\n#include \"array13_15.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array3 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array3->id);\n   free(params0.data);\n   return array3;\n}\n\n### File: func2.c\n#include \"array13_15.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array4 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array4->id);\n      free(params0.data);\n      array4->refC--;\n      if(array4->refC == 0) {\n         free(array4->data);\n         free(array4);\n         DEBUG_FREE(array4->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array6 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array6->id);\n      free(params0.data);\n      array6->refC--;\n      if(array6->refC == 0) {\n         free(array6->data);\n         free(array6);\n         DEBUG_FREE(array6->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 929;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func3.c\n#include \"array13_15.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array5;\n   if (pCounter > 0) {\n      array5 = vars->data[--pCounter];\n      array5->refC++;\n      DEBUG_COPY(array5->id);\n   } else {\n      array5 = (array_t*)malloc(sizeof(array_t));\n      array5->size = 567;\n      array5->refC = 1;\n      array5->id = 5;\n      array5->data = (unsigned int*)malloc(array5->size*sizeof(unsigned int));\n      memset(array5->data, 0, array5->size*sizeof(unsigned int));\n      DEBUG_NEW(array5->id);\n   }\n   return array5;\n}\n\n### File: func4.c\n#include \"array13_15.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 67;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: rng.c\n#include \"array13_15.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2443099\n    - Instructions: 1692701\n    - Cache References: 85047\n    - Cache Misses: 34469\n    - Branch Instructions: 323029\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist5_7.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist5_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist5_7.c\n#include \"sortedlist5_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist5_7.h\n#ifndef sortedlist5_7\n#define sortedlist5_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1542080\n    - Instructions: 1125543\n    - Cache References: 68488\n    - Cache Misses: 16853\n    - Branch Instructions: 208666\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist3_11.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist3_11.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist3_11.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist3_11.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist3_11.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist3_11.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist3_11.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist3_11.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist3_11.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist3_11.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist3_11.c\n#include \"sortedlist3_11.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist16 = func2(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params0.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell8 = sortedlist16->root;\n        cell_t* tmp8  = NULL;\n        while(cell8 != NULL) {\n            tmp8 = cell8->next;\n            free(cell8);\n            cell8 = tmp8;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   return 0;\n}\n\n### File: sortedlist3_11.h\n#ifndef sortedlist3_11\n#define sortedlist3_11\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 17766409\n    - Instructions: 19697941\n    - Cache References: 110104\n    - Cache Misses: 22005\n    - Branch Instructions: 3782063\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array8_18.c\n#include \"array8_18.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(array9->id);\n         free(params0.data);\n         array9->refC--;\n         if(array9->refC == 0) {\n            free(array9->data);\n            free(array9);\n            DEBUG_FREE(array9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array8_18.h\n#ifndef array8_18\n#define array8_18\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array8_18.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array8_18.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array8_18.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array8_18.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array8_18.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array8_18.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array8_18.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array8_18.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array8_18.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1614827\n    - Instructions: 1123675\n    - Cache References: 80249\n    - Cache Misses: 21134\n    - Branch Instructions: 207810\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist13_8.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist13_8.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist13_8.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist13_8.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist13_8.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist13_8.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist13_8.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist13_8.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist13_8.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist13_8.c\n#include \"sortedlist13_8.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist13_8.h\n#ifndef sortedlist13_8\n#define sortedlist13_8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1845443\n    - Instructions: 1697305\n    - Cache References: 86389\n    - Cache Misses: 24820\n    - Branch Instructions: 323929\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist15_10.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist15_10.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist15_10.c\n#include \"sortedlist15_10.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist15_10.h\n#ifndef sortedlist15_10\n#define sortedlist15_10\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 33006727\n    - Instructions: 45754355\n    - Cache References: 165430\n    - Cache Misses: 32427\n    - Branch Instructions: 8879239\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist2_20.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist2_20.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist2_20.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist18;\n   if (pCounter > 0) {\n      sortedlist18 = vars->data[--pCounter];\n      sortedlist18->refC++;\n      DEBUG_COPY(sortedlist18->id);\n   } else {\n      sortedlist18 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist18->refC = 1;\n      sortedlist18->id = 18;\n      sortedlist18->n = 0;\n      sortedlist18->root = NULL;\n      DEBUG_NEW(sortedlist18->id);\n   }\n   unsigned int loop5 = 0;\n   unsigned int loopLimit5 = (rand()%loopsFactor)/3 + 1;\n   for(; loop5 < loopLimit5; loop5++) {\n      if(sortedlist18 != NULL && sortedlist18->n > 0)\n      {\n          cell_t* cell10 = sortedlist18->root;\n          if(cell10->val == 27)\n          {\n              cell10 = cell10->next;\n              sortedlist18->n--;\n          }else{\n              while(cell10->next != NULL && cell10->next->val != 27) cell10 = cell10->next;\n              if(cell10->next != NULL)\n              {\n                  cell10 = cell10->next->next;\n                  sortedlist18->n--;\n              }\n           }\n      }\n   }\n   return sortedlist18;\n}\n\n### File: func3.c\n#include \"sortedlist2_20.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell6 = sortedlist11->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell8 = sortedlist13->root;\n           cell_t* tmp8  = NULL;\n           while(cell8 != NULL) {\n               tmp8 = cell8->next;\n               free(cell8);\n               cell8 = tmp8;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist16;\n   if (pCounter > 0) {\n      sortedlist16 = vars->data[--pCounter];\n      sortedlist16->refC++;\n      DEBUG_COPY(sortedlist16->id);\n   } else {\n      sortedlist16 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist16->refC = 1;\n      sortedlist16->id = 16;\n      sortedlist16->n = 0;\n      sortedlist16->root = NULL;\n      DEBUG_NEW(sortedlist16->id);\n   }\n   return sortedlist16;\n}\n\n### File: func4.c\n#include \"sortedlist2_20.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/3 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      if(sortedlist12 != NULL && sortedlist12->n > 0)\n      {\n          cell_t* cell5 = sortedlist12->root;\n          if(cell5->val == 35)\n          {\n              cell5 = cell5->next;\n              sortedlist12->n--;\n          }else{\n              while(cell5->next != NULL && cell5->next->val != 35) cell5 = cell5->next;\n              if(cell5->next != NULL)\n              {\n                  cell5 = cell5->next->next;\n                  sortedlist12->n--;\n              }\n           }\n      }\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist2_20.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop4 = 0;\n   unsigned int loopLimit4 = (rand()%loopsFactor)/3 + 1;\n   for(; loop4 < loopLimit4; loop4++) {\n      sortedlist_t* sortedlist14;\n      if (pCounter > 0) {\n         sortedlist14 = vars->data[--pCounter];\n         sortedlist14->refC++;\n         DEBUG_COPY(sortedlist14->id);\n      } else {\n         sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist14->refC = 1;\n         sortedlist14->id = 14;\n         sortedlist14->n = 0;\n         sortedlist14->root = NULL;\n         DEBUG_NEW(sortedlist14->id);\n      }\n      sortedlist14->refC--;\n      if(sortedlist14->refC == 0){\n           cell_t* cell7 = sortedlist14->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist14);\n           DEBUG_FREE(sortedlist14->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func6.c\n#include \"sortedlist2_20.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist2_20.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist2_20.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist2_20.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist2_20.c\n#include \"sortedlist2_20.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            if(rng() & 1) {\n               sortedlist_t_param params0;\n               params0.size = 0;\n               params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n               sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n               DEBUG_RETURN(sortedlist9->id);\n               free(params0.data);\n               sortedlist9->refC--;\n               if(sortedlist9->refC == 0){\n                    cell_t* cell9 = sortedlist9->root;\n                    cell_t* tmp9  = NULL;\n                    while(cell9 != NULL) {\n                        tmp9 = cell9->next;\n                        free(cell9);\n                        cell9 = tmp9;\n                    }\n                    free(sortedlist9);\n                    DEBUG_FREE(sortedlist9->id);\n               }\n            }\n            else {\n               sortedlist_t_param params0;\n               params0.size = 0;\n               params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n               sortedlist_t* sortedlist17 = func2(&params0, loopsFactor);\n               DEBUG_RETURN(sortedlist17->id);\n               free(params0.data);\n               sortedlist17->refC--;\n               if(sortedlist17->refC == 0){\n                    cell_t* cell11 = sortedlist17->root;\n                    cell_t* tmp11  = NULL;\n                    while(cell11 != NULL) {\n                        tmp11 = cell11->next;\n                        free(cell11);\n                        cell11 = tmp11;\n                    }\n                    free(sortedlist17);\n                    DEBUG_FREE(sortedlist17->id);\n               }\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist2_20.h\n#ifndef sortedlist2_20\n#define sortedlist2_20\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1810175\n    - Instructions: 1700440\n    - Cache References: 76627\n    - Cache Misses: 16966\n    - Branch Instructions: 324565\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist13_14.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist13_14.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist13_14.c\n#include \"sortedlist13_14.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist13_14.h\n#ifndef sortedlist13_14\n#define sortedlist13_14\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1834715\n    - Instructions: 1678616\n    - Cache References: 72410\n    - Cache Misses: 26928\n    - Branch Instructions: 320177\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist5_9.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist5_9.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist5_9.c\n#include \"sortedlist5_9.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist5_9.h\n#ifndef sortedlist5_9\n#define sortedlist5_9\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 10308785\n    - Instructions: 13288047\n    - Cache References: 91310\n    - Cache Misses: 19635\n    - Branch Instructions: 2547956\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist2_18.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist2_18.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist2_18.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist2_18.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist2_18.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist2_18.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist2_18.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist2_18.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist2_18.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist2_18.c\n#include \"sortedlist2_18.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist9->id);\n         free(params0.data);\n         sortedlist9->refC--;\n         if(sortedlist9->refC == 0){\n              cell_t* cell7 = sortedlist9->root;\n              cell_t* tmp7  = NULL;\n              while(cell7 != NULL) {\n                  tmp7 = cell7->next;\n                  free(cell7);\n                  cell7 = tmp7;\n              }\n              free(sortedlist9);\n              DEBUG_FREE(sortedlist9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist2_18.h\n#ifndef sortedlist2_18\n#define sortedlist2_18\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2120522\n    - Instructions: 1139821\n    - Cache References: 84056\n    - Cache Misses: 29292\n    - Branch Instructions: 211020\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist3_2.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist3_2.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist3_2.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist3_2.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist3_2.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist3_2.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist3_2.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist3_2.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist3_2.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist3_2.c\n#include \"sortedlist3_2.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist3_2.h\n#ifndef sortedlist3_2\n#define sortedlist3_2\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2344758\n    - Instructions: 3070607\n    - Cache References: 80889\n    - Cache Misses: 19522\n    - Branch Instructions: 588059\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist14_15.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: func1.c\n#include \"sortedlist14_15.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist3 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist3->id);\n   free(params0.data);\n   return sortedlist3;\n}\n\n### File: func2.c\n#include \"sortedlist14_15.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist4 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist4->id);\n      free(params0.data);\n      sortedlist4->refC--;\n      if(sortedlist4->refC == 0){\n           cell_t* cell2 = sortedlist4->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist4);\n           DEBUG_FREE(sortedlist4->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist6 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist6->id);\n      free(params0.data);\n      sortedlist6->refC--;\n      if(sortedlist6->refC == 0){\n           cell_t* cell3 = sortedlist6->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist6);\n           DEBUG_FREE(sortedlist6->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func3.c\n#include \"sortedlist14_15.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist5;\n   if (pCounter > 0) {\n      sortedlist5 = vars->data[--pCounter];\n      sortedlist5->refC++;\n      DEBUG_COPY(sortedlist5->id);\n   } else {\n      sortedlist5 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist5->refC = 1;\n      sortedlist5->id = 5;\n      sortedlist5->n = 0;\n      sortedlist5->root = NULL;\n      DEBUG_NEW(sortedlist5->id);\n   }\n   return sortedlist5;\n}\n\n### File: func4.c\n#include \"sortedlist14_15.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: rng.c\n#include \"sortedlist14_15.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist14_15.c\n#include \"sortedlist14_15.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist_t_param params1;\n      params1.size = 1;\n      params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n      params1.data[0] = sortedlist0;\n      sortedlist_t* sortedlist2 = func1(&params1, loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params1.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell4 = sortedlist2->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell5 = sortedlist0->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist14_15.h\n#ifndef sortedlist14_15\n#define sortedlist14_15\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7480996\n    - Instructions: 14361147\n    - Cache References: 76979\n    - Cache Misses: 19393\n    - Branch Instructions: 2144518\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array4_3.c\n#include \"array4_3.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array4_3.h\n#ifndef array4_3\n#define array4_3\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array4_3.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array4_3.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1763676\n    - Instructions: 1671562\n    - Cache References: 71737\n    - Cache Misses: 24855\n    - Branch Instructions: 316537\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist8_13.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n   }\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   return sortedlist2;\n}\n\n### File: rng.c\n#include \"sortedlist8_13.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist8_13.c\n#include \"sortedlist8_13.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist0 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist0->refC = 1;\n      sortedlist0->id = 0;\n      sortedlist0->n = 0;\n      sortedlist0->root = NULL;\n      DEBUG_NEW(sortedlist0->id);\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist0;\n      sortedlist_t* sortedlist1 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist1->id);\n      free(params0.data);\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell0 = sortedlist1->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist8_13.h\n#ifndef sortedlist8_13\n#define sortedlist8_13\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4590167\n    - Instructions: 6795087\n    - Cache References: 91619\n    - Cache Misses: 38320\n    - Branch Instructions: 1041448\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array14_16.c\n#include \"array14_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array14_16.h\n#ifndef array14_16\n#define array14_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array14_16.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array14_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1979230\n    - Instructions: 1684987\n    - Cache References: 76034\n    - Cache Misses: 31642\n    - Branch Instructions: 321673\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist4_7.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist4_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist4_7.c\n#include \"sortedlist4_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist4_7.h\n#ifndef sortedlist4_7\n#define sortedlist4_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1775508\n    - Instructions: 1671770\n    - Cache References: 67542\n    - Cache Misses: 15536\n    - Branch Instructions: 319515\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist7_12.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist7_12.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist7_12.c\n#include \"sortedlist7_12.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist7_12.h\n#ifndef sortedlist7_12\n#define sortedlist7_12\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 8314985\n    - Instructions: 15803692\n    - Cache References: 101330\n    - Cache Misses: 37166\n    - Branch Instructions: 2394348\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array11_5.c\n#include \"array11_5.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array0 = func0(&params0, loopsFactor);\n   DEBUG_RETURN(array0->id);\n   free(params0.data);\n   array_t_param params1;\n   params1.size = 1;\n   params1.data = (array_t**)malloc(params1.size*sizeof(array_t*));\n   params1.data[0] = array0;\n   array_t* array9 = func1(&params1, loopsFactor);\n   DEBUG_RETURN(array9->id);\n   free(params1.data);\n   array_t_param params2;\n   params2.size = 2;\n   params2.data = (array_t**)malloc(params2.size*sizeof(array_t*));\n   params2.data[0] = array0;\n   params2.data[1] = array9;\n   array_t* array16 = func2(&params2, loopsFactor);\n   DEBUG_RETURN(array16->id);\n   free(params2.data);\n   array16->refC--;\n   if(array16->refC == 0) {\n      free(array16->data);\n      free(array16);\n      DEBUG_FREE(array16->id);\n   }\n   array9->refC--;\n   if(array9->refC == 0) {\n      free(array9->data);\n      free(array9);\n      DEBUG_FREE(array9->id);\n   }\n   array0->refC--;\n   if(array0->refC == 0) {\n      free(array0->data);\n      free(array0);\n      DEBUG_FREE(array0->id);\n   }\n   return 0;\n}\n\n### File: array11_5.h\n#ifndef array11_5\n#define array11_5\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array11_5.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 862;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array11_5.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array11_5.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array17;\n   if (pCounter > 0) {\n      array17 = vars->data[--pCounter];\n      array17->refC++;\n      DEBUG_COPY(array17->id);\n   } else {\n      array17 = (array_t*)malloc(sizeof(array_t));\n      array17->size = 862;\n      array17->refC = 1;\n      array17->id = 17;\n      array17->data = (unsigned int*)malloc(array17->size*sizeof(unsigned int));\n      memset(array17->data, 0, array17->size*sizeof(unsigned int));\n      DEBUG_NEW(array17->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/1 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      for (int i = 0; i < array17->size; i++) {\n         array17->data[i]--;\n      }\n   }\n   return array17;\n}\n\n### File: func3.c\n#include \"array11_5.h\" \narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 370;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func4.c\n#include \"array11_5.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 229;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      for (int i = 0; i < array12->size; i++) {\n         array12->data[i]--;\n      }\n   }\n   return array12;\n}\n\n### File: func5.c\n#include \"array11_5.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 324;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func6.c\n#include \"array11_5.h\" \narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 782;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func7.c\n#include \"array11_5.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array4->size; i++) {\n         array4->data[i]--;\n      }\n   }\n   return array4;\n}\n\n### File: func8.c\n#include \"array11_5.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 567;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array11_5.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2555445\n    - Instructions: 1162120\n    - Cache References: 104496\n    - Cache Misses: 41866\n    - Branch Instructions: 214503\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist12_2.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist12_2.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist12_2.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist12_2.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist12_2.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist12_2.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist12_2.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist12_2.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist12_2.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist12_2.c\n#include \"sortedlist12_2.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist12_2.h\n#ifndef sortedlist12_2\n#define sortedlist12_2\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1567412\n    - Instructions: 1150399\n    - Cache References: 72138\n    - Cache Misses: 17413\n    - Branch Instructions: 213244\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array4_11.c\n#include \"array4_11.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array16 = func2(&params0, loopsFactor);\n   DEBUG_RETURN(array16->id);\n   free(params0.data);\n   array16->refC--;\n   if(array16->refC == 0) {\n      free(array16->data);\n      free(array16);\n      DEBUG_FREE(array16->id);\n   }\n   return 0;\n}\n\n### File: array4_11.h\n#ifndef array4_11\n#define array4_11\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array4_11.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array4_11.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array4_11.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array17;\n   if (pCounter > 0) {\n      array17 = vars->data[--pCounter];\n      array17->refC++;\n      DEBUG_COPY(array17->id);\n   } else {\n      array17 = (array_t*)malloc(sizeof(array_t));\n      array17->size = 956;\n      array17->refC = 1;\n      array17->id = 17;\n      array17->data = (unsigned int*)malloc(array17->size*sizeof(unsigned int));\n      memset(array17->data, 0, array17->size*sizeof(unsigned int));\n      DEBUG_NEW(array17->id);\n   }\n   return array17;\n}\n\n### File: func3.c\n#include \"array4_11.h\" \narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func4.c\n#include \"array4_11.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func5.c\n#include \"array4_11.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func6.c\n#include \"array4_11.h\" \narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func7.c\n#include \"array4_11.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func8.c\n#include \"array4_11.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array4_11.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1508958\n    - Instructions: 1131224\n    - Cache References: 65809\n    - Cache Misses: 18263\n    - Branch Instructions: 209641\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array4_8.c\n#include \"array4_8.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   return 0;\n}\n\n### File: array4_8.h\n#ifndef array4_8\n#define array4_8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array4_8.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array4_8.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array4_8.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array4_8.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array4_8.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array4_8.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array4_8.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array4_8.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array4_8.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4351923\n    - Instructions: 6797174\n    - Cache References: 90560\n    - Cache Misses: 34861\n    - Branch Instructions: 1042319\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array11_17.c\n#include \"array11_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array11_17.h\n#ifndef array11_17\n#define array11_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array11_17.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array11_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7217973\n    - Instructions: 13886166\n    - Cache References: 74353\n    - Cache Misses: 18682\n    - Branch Instructions: 2076513\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array7_10.c\n#include \"array7_10.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array7_10.h\n#ifndef array7_10\n#define array7_10\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array7_10.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array7_10.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1780463\n    - Instructions: 1168763\n    - Cache References: 80744\n    - Cache Misses: 30241\n    - Branch Instructions: 216316\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist15_11.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist15_11.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist15_11.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist15_11.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist15_11.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist15_11.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist15_11.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist15_11.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist15_11.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist15_11.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist15_11.c\n#include \"sortedlist15_11.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist16 = func2(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params0.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell8 = sortedlist16->root;\n        cell_t* tmp8  = NULL;\n        while(cell8 != NULL) {\n            tmp8 = cell8->next;\n            free(cell8);\n            cell8 = tmp8;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   return 0;\n}\n\n### File: sortedlist15_11.h\n#ifndef sortedlist15_11\n#define sortedlist15_11\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7511063\n    - Instructions: 13920581\n    - Cache References: 83332\n    - Cache Misses: 34410\n    - Branch Instructions: 2082054\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array5_10.c\n#include \"array5_10.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array5_10.h\n#ifndef array5_10\n#define array5_10\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array5_10.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array5_10.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 14614621\n    - Instructions: 32689199\n    - Cache References: 102645\n    - Cache Misses: 34012\n    - Branch Instructions: 6331719\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist2_6.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist2_6.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist2_6.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist2_6.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist2_6.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist2_6.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist2_6.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist2_6.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist2_6.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist2_6.c\n#include \"sortedlist2_6.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            sortedlist_t_param params0;\n            params0.size = 0;\n            params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n            sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n            DEBUG_RETURN(sortedlist9->id);\n            free(params0.data);\n            sortedlist9->refC--;\n            if(sortedlist9->refC == 0){\n                 cell_t* cell7 = sortedlist9->root;\n                 cell_t* tmp7  = NULL;\n                 while(cell7 != NULL) {\n                     tmp7 = cell7->next;\n                     free(cell7);\n                     cell7 = tmp7;\n                 }\n                 free(sortedlist9);\n                 DEBUG_FREE(sortedlist9->id);\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist2_6.h\n#ifndef sortedlist2_6\n#define sortedlist2_6\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1802237\n    - Instructions: 1679088\n    - Cache References: 75185\n    - Cache Misses: 22732\n    - Branch Instructions: 320250\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist6_12.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist6_12.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist6_12.c\n#include \"sortedlist6_12.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist6_12.h\n#ifndef sortedlist6_12\n#define sortedlist6_12\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1881915\n    - Instructions: 1145712\n    - Cache References: 88871\n    - Cache Misses: 20088\n    - Branch Instructions: 212263\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array14_2.c\n#include \"array14_2.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   return 0;\n}\n\n### File: array14_2.h\n#ifndef array14_2\n#define array14_2\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array14_2.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array14_2.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array14_2.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array14_2.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array14_2.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array14_2.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array14_2.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array14_2.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array14_2.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1915900\n    - Instructions: 1708175\n    - Cache References: 82594\n    - Cache Misses: 24822\n    - Branch Instructions: 325322\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist14_14.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist14_14.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist14_14.c\n#include \"sortedlist14_14.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist14_14.h\n#ifndef sortedlist14_14\n#define sortedlist14_14\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4114829\n    - Instructions: 6779549\n    - Cache References: 76327\n    - Cache Misses: 26531\n    - Branch Instructions: 1038818\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array5_17.c\n#include \"array5_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array5_17.h\n#ifndef array5_17\n#define array5_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array5_17.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array5_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 8280555\n    - Instructions: 14355829\n    - Cache References: 96779\n    - Cache Misses: 35152\n    - Branch Instructions: 2144169\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array5_14.c\n#include \"array5_14.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array5_14.h\n#ifndef array5_14\n#define array5_14\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array5_14.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array5_14.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1878138\n    - Instructions: 1683710\n    - Cache References: 78001\n    - Cache Misses: 23493\n    - Branch Instructions: 321645\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist2_7.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist2_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist2_7.c\n#include \"sortedlist2_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist2_7.h\n#ifndef sortedlist2_7\n#define sortedlist2_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 14956120\n    - Instructions: 19825703\n    - Cache References: 126884\n    - Cache Misses: 32585\n    - Branch Instructions: 3797872\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array11_18.c\n#include \"array11_18.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(array9->id);\n         free(params0.data);\n         array9->refC--;\n         if(array9->refC == 0) {\n            free(array9->data);\n            free(array9);\n            DEBUG_FREE(array9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array11_18.h\n#ifndef array11_18\n#define array11_18\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array11_18.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array11_18.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array11_18.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array11_18.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array11_18.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array11_18.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array11_18.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array11_18.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array11_18.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 8157176\n    - Instructions: 15789302\n    - Cache References: 83145\n    - Cache Misses: 23744\n    - Branch Instructions: 2391528\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array3_5.c\n#include \"array3_5.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array0 = func0(&params0, loopsFactor);\n   DEBUG_RETURN(array0->id);\n   free(params0.data);\n   array_t_param params1;\n   params1.size = 1;\n   params1.data = (array_t**)malloc(params1.size*sizeof(array_t*));\n   params1.data[0] = array0;\n   array_t* array9 = func1(&params1, loopsFactor);\n   DEBUG_RETURN(array9->id);\n   free(params1.data);\n   array_t_param params2;\n   params2.size = 2;\n   params2.data = (array_t**)malloc(params2.size*sizeof(array_t*));\n   params2.data[0] = array0;\n   params2.data[1] = array9;\n   array_t* array16 = func2(&params2, loopsFactor);\n   DEBUG_RETURN(array16->id);\n   free(params2.data);\n   array16->refC--;\n   if(array16->refC == 0) {\n      free(array16->data);\n      free(array16);\n      DEBUG_FREE(array16->id);\n   }\n   array9->refC--;\n   if(array9->refC == 0) {\n      free(array9->data);\n      free(array9);\n      DEBUG_FREE(array9->id);\n   }\n   array0->refC--;\n   if(array0->refC == 0) {\n      free(array0->data);\n      free(array0);\n      DEBUG_FREE(array0->id);\n   }\n   return 0;\n}\n\n### File: array3_5.h\n#ifndef array3_5\n#define array3_5\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array3_5.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 862;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array3_5.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array3_5.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array17;\n   if (pCounter > 0) {\n      array17 = vars->data[--pCounter];\n      array17->refC++;\n      DEBUG_COPY(array17->id);\n   } else {\n      array17 = (array_t*)malloc(sizeof(array_t));\n      array17->size = 862;\n      array17->refC = 1;\n      array17->id = 17;\n      array17->data = (unsigned int*)malloc(array17->size*sizeof(unsigned int));\n      memset(array17->data, 0, array17->size*sizeof(unsigned int));\n      DEBUG_NEW(array17->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/1 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      for (int i = 0; i < array17->size; i++) {\n         array17->data[i]--;\n      }\n   }\n   return array17;\n}\n\n### File: func3.c\n#include \"array3_5.h\" \narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 370;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func4.c\n#include \"array3_5.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 229;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      for (int i = 0; i < array12->size; i++) {\n         array12->data[i]--;\n      }\n   }\n   return array12;\n}\n\n### File: func5.c\n#include \"array3_5.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 324;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func6.c\n#include \"array3_5.h\" \narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 782;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func7.c\n#include \"array3_5.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array4->size; i++) {\n         array4->data[i]--;\n      }\n   }\n   return array4;\n}\n\n### File: func8.c\n#include \"array3_5.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 567;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array3_5.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2294314\n    - Instructions: 1384522\n    - Cache References: 96246\n    - Cache Misses: 30408\n    - Branch Instructions: 261764\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist10_16.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist10_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist10_16.c\n#include \"sortedlist10_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist10_16.h\n#ifndef sortedlist10_16\n#define sortedlist10_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1539252\n    - Instructions: 1135820\n    - Cache References: 69080\n    - Cache Misses: 16733\n    - Branch Instructions: 209874\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist2_11.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist2_11.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist2_11.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist2_11.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist2_11.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist2_11.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist2_11.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist2_11.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist2_11.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist2_11.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist2_11.c\n#include \"sortedlist2_11.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist16 = func2(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params0.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell8 = sortedlist16->root;\n        cell_t* tmp8  = NULL;\n        while(cell8 != NULL) {\n            tmp8 = cell8->next;\n            free(cell8);\n            cell8 = tmp8;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   return 0;\n}\n\n### File: sortedlist2_11.h\n#ifndef sortedlist2_11\n#define sortedlist2_11\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 11876913\n    - Instructions: 15326926\n    - Cache References: 129270\n    - Cache Misses: 37722\n    - Branch Instructions: 3026520\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist4_1.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist1 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist1->id);\n      free(params0.data);\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell1 = sortedlist1->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist3;\n   if (pCounter > 0) {\n      sortedlist3 = vars->data[--pCounter];\n      sortedlist3->refC++;\n      DEBUG_COPY(sortedlist3->id);\n   } else {\n      sortedlist3 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist3->refC = 1;\n      sortedlist3->id = 3;\n      sortedlist3->n = 0;\n      sortedlist3->root = NULL;\n      DEBUG_NEW(sortedlist3->id);\n   }\n   return sortedlist3;\n}\n\n### File: func1.c\n#include \"sortedlist4_1.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist2 != NULL && sortedlist2->n > 0)\n      {\n          cell_t* cell0 = sortedlist2->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist2->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist2->n--;\n              }\n           }\n      }\n   }\n   return sortedlist2;\n}\n\n### File: rng.c\n#include \"sortedlist4_1.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist4_1.c\n#include \"sortedlist4_1.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist4_1.h\n#ifndef sortedlist4_1\n#define sortedlist4_1\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2024547\n    - Instructions: 2382369\n    - Cache References: 73699\n    - Cache Misses: 17322\n    - Branch Instructions: 450398\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist5_4.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist5_4.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist5_4.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist5_4.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist5_4.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist5_4.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist5_4.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist5_4.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist5_4.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist5_4.c\n#include \"sortedlist5_4.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      unsigned int loop0 = 0;\n      unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n      for(; loop0 < loopLimit0; loop0++) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n   }\n   else {\n      unsigned int loop2 = 0;\n      unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n      for(; loop2 < loopLimit2; loop2++) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist9->id);\n         free(params0.data);\n         sortedlist9->refC--;\n         if(sortedlist9->refC == 0){\n              cell_t* cell7 = sortedlist9->root;\n              cell_t* tmp7  = NULL;\n              while(cell7 != NULL) {\n                  tmp7 = cell7->next;\n                  free(cell7);\n                  cell7 = tmp7;\n              }\n              free(sortedlist9);\n              DEBUG_FREE(sortedlist9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist5_4.h\n#ifndef sortedlist5_4\n#define sortedlist5_4\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2291204\n    - Instructions: 3034828\n    - Cache References: 72451\n    - Cache Misses: 20802\n    - Branch Instructions: 582665\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist2_15.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: func1.c\n#include \"sortedlist2_15.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist3 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist3->id);\n   free(params0.data);\n   return sortedlist3;\n}\n\n### File: func2.c\n#include \"sortedlist2_15.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist4 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist4->id);\n      free(params0.data);\n      sortedlist4->refC--;\n      if(sortedlist4->refC == 0){\n           cell_t* cell2 = sortedlist4->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist4);\n           DEBUG_FREE(sortedlist4->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist6 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist6->id);\n      free(params0.data);\n      sortedlist6->refC--;\n      if(sortedlist6->refC == 0){\n           cell_t* cell3 = sortedlist6->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist6);\n           DEBUG_FREE(sortedlist6->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func3.c\n#include \"sortedlist2_15.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist5;\n   if (pCounter > 0) {\n      sortedlist5 = vars->data[--pCounter];\n      sortedlist5->refC++;\n      DEBUG_COPY(sortedlist5->id);\n   } else {\n      sortedlist5 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist5->refC = 1;\n      sortedlist5->id = 5;\n      sortedlist5->n = 0;\n      sortedlist5->root = NULL;\n      DEBUG_NEW(sortedlist5->id);\n   }\n   return sortedlist5;\n}\n\n### File: func4.c\n#include \"sortedlist2_15.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: rng.c\n#include \"sortedlist2_15.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist2_15.c\n#include \"sortedlist2_15.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist_t_param params1;\n      params1.size = 1;\n      params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n      params1.data[0] = sortedlist0;\n      sortedlist_t* sortedlist2 = func1(&params1, loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params1.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell4 = sortedlist2->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell5 = sortedlist0->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist2_15.h\n#ifndef sortedlist2_15\n#define sortedlist2_15\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 3596293\n    - Instructions: 6225935\n    - Cache References: 75610\n    - Cache Misses: 17873\n    - Branch Instructions: 1191626\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist1_19.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell0 = sortedlist1->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   return sortedlist2;\n}\n\n### File: func1.c\n#include \"sortedlist1_19.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist4 = func4(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist4->id);\n   free(params0.data);\n   return sortedlist4;\n}\n\n### File: func2.c\n#include \"sortedlist1_19.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist11;\n   if (pCounter > 0) {\n      sortedlist11 = vars->data[--pCounter];\n      sortedlist11->refC++;\n      DEBUG_COPY(sortedlist11->id);\n   } else {\n      sortedlist11 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist11->refC = 1;\n      sortedlist11->id = 11;\n      sortedlist11->n = 0;\n      sortedlist11->root = NULL;\n      DEBUG_NEW(sortedlist11->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist11 != NULL && sortedlist11->n > 0)\n      {\n          cell_t* cell5 = sortedlist11->root;\n          if(cell5->val == 86)\n          {\n              cell5 = cell5->next;\n              sortedlist11->n--;\n          }else{\n              while(cell5->next != NULL && cell5->next->val != 86) cell5 = cell5->next;\n              if(cell5->next != NULL)\n              {\n                  cell5 = cell5->next->next;\n                  sortedlist11->n--;\n              }\n           }\n      }\n   }\n   return sortedlist11;\n}\n\n### File: func3.c\n#include \"sortedlist1_19.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist13 = func7(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist13->id);\n   free(params0.data);\n   return sortedlist13;\n}\n\n### File: func4.c\n#include \"sortedlist1_19.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell2 = sortedlist5->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist7 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist7->id);\n      free(params0.data);\n      sortedlist7->refC--;\n      if(sortedlist7->refC == 0){\n           cell_t* cell3 = sortedlist7->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist7);\n           DEBUG_FREE(sortedlist7->id);\n      }\n   }\n   sortedlist_t* sortedlist9;\n   if (pCounter > 0) {\n      sortedlist9 = vars->data[--pCounter];\n      sortedlist9->refC++;\n      DEBUG_COPY(sortedlist9->id);\n   } else {\n      sortedlist9 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist9->refC = 1;\n      sortedlist9->id = 9;\n      sortedlist9->n = 0;\n      sortedlist9->root = NULL;\n      DEBUG_NEW(sortedlist9->id);\n   }\n   return sortedlist9;\n}\n\n### File: func5.c\n#include \"sortedlist1_19.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: func6.c\n#include \"sortedlist1_19.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func7.c\n#include \"sortedlist1_19.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist14 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist14->id);\n      free(params0.data);\n      sortedlist14->refC--;\n      if(sortedlist14->refC == 0){\n           cell_t* cell7 = sortedlist14->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist14);\n           DEBUG_FREE(sortedlist14->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist16 = func9(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist16->id);\n      free(params0.data);\n      sortedlist16->refC--;\n      if(sortedlist16->refC == 0){\n           cell_t* cell8 = sortedlist16->root;\n           cell_t* tmp8  = NULL;\n           while(cell8 != NULL) {\n               tmp8 = cell8->next;\n               free(cell8);\n               cell8 = tmp8;\n           }\n           free(sortedlist16);\n           DEBUG_FREE(sortedlist16->id);\n      }\n   }\n   sortedlist_t* sortedlist18;\n   if (pCounter > 0) {\n      sortedlist18 = vars->data[--pCounter];\n      sortedlist18->refC++;\n      DEBUG_COPY(sortedlist18->id);\n   } else {\n      sortedlist18 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist18->refC = 1;\n      sortedlist18->id = 18;\n      sortedlist18->n = 0;\n      sortedlist18->root = NULL;\n      DEBUG_NEW(sortedlist18->id);\n   }\n   return sortedlist18;\n}\n\n### File: func8.c\n#include \"sortedlist1_19.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func9.c\n#include \"sortedlist1_19.h\" \nsortedlist_t* func9(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   return sortedlist17;\n}\n\n### File: rng.c\n#include \"sortedlist1_19.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist1_19.c\n#include \"sortedlist1_19.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist3 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist3->id);\n         free(params0.data);\n         sortedlist3->refC--;\n         if(sortedlist3->refC == 0){\n              cell_t* cell4 = sortedlist3->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist3);\n              DEBUG_FREE(sortedlist3->id);\n         }\n      }\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist10 = func2(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist10->id);\n         free(params0.data);\n         sortedlist10->refC--;\n         if(sortedlist10->refC == 0){\n              cell_t* cell6 = sortedlist10->root;\n              cell_t* tmp6  = NULL;\n              while(cell6 != NULL) {\n                  tmp6 = cell6->next;\n                  free(cell6);\n                  cell6 = tmp6;\n              }\n              free(sortedlist10);\n              DEBUG_FREE(sortedlist10->id);\n         }\n      }\n      else {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist12 = func3(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist12->id);\n         free(params0.data);\n         sortedlist12->refC--;\n         if(sortedlist12->refC == 0){\n              cell_t* cell9 = sortedlist12->root;\n              cell_t* tmp9  = NULL;\n              while(cell9 != NULL) {\n                  tmp9 = cell9->next;\n                  free(cell9);\n                  cell9 = tmp9;\n              }\n              free(sortedlist12);\n              DEBUG_FREE(sortedlist12->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist1_19.h\n#ifndef sortedlist1_19\n#define sortedlist1_19\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func9(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1656634\n    - Instructions: 1122461\n    - Cache References: 83066\n    - Cache Misses: 27579\n    - Branch Instructions: 208038\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist2_2.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist2_2.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist2_2.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist2_2.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist2_2.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist2_2.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist2_2.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist2_2.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist2_2.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist2_2.c\n#include \"sortedlist2_2.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist2_2.h\n#ifndef sortedlist2_2\n#define sortedlist2_2\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1665220\n    - Instructions: 1404276\n    - Cache References: 72362\n    - Cache Misses: 21152\n    - Branch Instructions: 264767\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist1_16.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist1_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist1_16.c\n#include \"sortedlist1_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist1_16.h\n#ifndef sortedlist1_16\n#define sortedlist1_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4348448\n    - Instructions: 6799037\n    - Cache References: 97647\n    - Cache Misses: 19671\n    - Branch Instructions: 1042325\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array15_17.c\n#include \"array15_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array15_17.h\n#ifndef array15_17\n#define array15_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array15_17.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array15_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1682107\n    - Instructions: 1410251\n    - Cache References: 84362\n    - Cache Misses: 30113\n    - Branch Instructions: 265990\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist12_16.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist12_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist12_16.c\n#include \"sortedlist12_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist12_16.h\n#ifndef sortedlist12_16\n#define sortedlist12_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 3278545\n    - Instructions: 3057478\n    - Cache References: 77910\n    - Cache Misses: 23560\n    - Branch Instructions: 585846\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist4_15.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: func1.c\n#include \"sortedlist4_15.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist3 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist3->id);\n   free(params0.data);\n   return sortedlist3;\n}\n\n### File: func2.c\n#include \"sortedlist4_15.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist4 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist4->id);\n      free(params0.data);\n      sortedlist4->refC--;\n      if(sortedlist4->refC == 0){\n           cell_t* cell2 = sortedlist4->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist4);\n           DEBUG_FREE(sortedlist4->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist6 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist6->id);\n      free(params0.data);\n      sortedlist6->refC--;\n      if(sortedlist6->refC == 0){\n           cell_t* cell3 = sortedlist6->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist6);\n           DEBUG_FREE(sortedlist6->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func3.c\n#include \"sortedlist4_15.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist5;\n   if (pCounter > 0) {\n      sortedlist5 = vars->data[--pCounter];\n      sortedlist5->refC++;\n      DEBUG_COPY(sortedlist5->id);\n   } else {\n      sortedlist5 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist5->refC = 1;\n      sortedlist5->id = 5;\n      sortedlist5->n = 0;\n      sortedlist5->root = NULL;\n      DEBUG_NEW(sortedlist5->id);\n   }\n   return sortedlist5;\n}\n\n### File: func4.c\n#include \"sortedlist4_15.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: rng.c\n#include \"sortedlist4_15.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist4_15.c\n#include \"sortedlist4_15.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist_t_param params1;\n      params1.size = 1;\n      params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n      params1.data[0] = sortedlist0;\n      sortedlist_t* sortedlist2 = func1(&params1, loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params1.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell4 = sortedlist2->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell5 = sortedlist0->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist4_15.h\n#ifndef sortedlist4_15\n#define sortedlist4_15\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1536895\n    - Instructions: 1137522\n    - Cache References: 69901\n    - Cache Misses: 20907\n    - Branch Instructions: 210884\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array5_11.c\n#include \"array5_11.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array16 = func2(&params0, loopsFactor);\n   DEBUG_RETURN(array16->id);\n   free(params0.data);\n   array16->refC--;\n   if(array16->refC == 0) {\n      free(array16->data);\n      free(array16);\n      DEBUG_FREE(array16->id);\n   }\n   return 0;\n}\n\n### File: array5_11.h\n#ifndef array5_11\n#define array5_11\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array5_11.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array5_11.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array5_11.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array17;\n   if (pCounter > 0) {\n      array17 = vars->data[--pCounter];\n      array17->refC++;\n      DEBUG_COPY(array17->id);\n   } else {\n      array17 = (array_t*)malloc(sizeof(array_t));\n      array17->size = 956;\n      array17->refC = 1;\n      array17->id = 17;\n      array17->data = (unsigned int*)malloc(array17->size*sizeof(unsigned int));\n      memset(array17->data, 0, array17->size*sizeof(unsigned int));\n      DEBUG_NEW(array17->id);\n   }\n   return array17;\n}\n\n### File: func3.c\n#include \"array5_11.h\" \narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func4.c\n#include \"array5_11.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func5.c\n#include \"array5_11.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func6.c\n#include \"array5_11.h\" \narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func7.c\n#include \"array5_11.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func8.c\n#include \"array5_11.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array5_11.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 66248777\n    - Instructions: 141221363\n    - Cache References: 258737\n    - Cache Misses: 52978\n    - Branch Instructions: 27235159\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func10(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell14 = sortedlist2->root;\n           cell_t* tmp14  = NULL;\n           while(cell14 != NULL) {\n               tmp14 = cell14->next;\n               free(cell14);\n               cell14 = tmp14;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell15 = sortedlist1->root;\n           cell_t* tmp15  = NULL;\n           while(cell15 != NULL) {\n               tmp15 = cell15->next;\n               free(cell15);\n               cell15 = tmp15;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist30;\n   if (pCounter > 0) {\n      sortedlist30 = vars->data[--pCounter];\n      sortedlist30->refC++;\n      DEBUG_COPY(sortedlist30->id);\n   } else {\n      sortedlist30 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist30->refC = 1;\n      sortedlist30->id = 30;\n      sortedlist30->n = 0;\n      sortedlist30->root = NULL;\n      DEBUG_NEW(sortedlist30->id);\n   }\n   return sortedlist30;\n}\n\n### File: func1.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist32 = func4(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist32->id);\n   free(params0.data);\n   return sortedlist32;\n}\n\n### File: func10.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func10(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func11(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell1 = sortedlist3->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func12(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell13 = sortedlist5->root;\n           cell_t* tmp13  = NULL;\n           while(cell13 != NULL) {\n               tmp13 = cell13->next;\n               free(cell13);\n               cell13 = tmp13;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist29;\n   if (pCounter > 0) {\n      sortedlist29 = vars->data[--pCounter];\n      sortedlist29->refC++;\n      DEBUG_COPY(sortedlist29->id);\n   } else {\n      sortedlist29 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist29->refC = 1;\n      sortedlist29->id = 29;\n      sortedlist29->n = 0;\n      sortedlist29->root = NULL;\n      DEBUG_NEW(sortedlist29->id);\n   }\n   return sortedlist29;\n}\n\n### File: func11.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func11(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist4 != NULL && sortedlist4->n > 0)\n      {\n          cell_t* cell0 = sortedlist4->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist4->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist4->n--;\n              }\n           }\n      }\n   }\n   return sortedlist4;\n}\n\n### File: func12.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func12(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist6 = func16(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist6->id);\n   free(params0.data);\n   return sortedlist6;\n}\n\n### File: func13.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func13(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist37 = func14(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist37->id);\n      free(params0.data);\n      sortedlist37->refC--;\n      if(sortedlist37->refC == 0){\n           cell_t* cell21 = sortedlist37->root;\n           cell_t* tmp21  = NULL;\n           while(cell21 != NULL) {\n               tmp21 = cell21->next;\n               free(cell21);\n               cell21 = tmp21;\n           }\n           free(sortedlist37);\n           DEBUG_FREE(sortedlist37->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist41 = func15(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist41->id);\n      free(params0.data);\n      sortedlist41->refC--;\n      if(sortedlist41->refC == 0){\n           cell_t* cell28 = sortedlist41->root;\n           cell_t* tmp28  = NULL;\n           while(cell28 != NULL) {\n               tmp28 = cell28->next;\n               free(cell28);\n               cell28 = tmp28;\n           }\n           free(sortedlist41);\n           DEBUG_FREE(sortedlist41->id);\n      }\n   }\n   sortedlist_t* sortedlist54;\n   if (pCounter > 0) {\n      sortedlist54 = vars->data[--pCounter];\n      sortedlist54->refC++;\n      DEBUG_COPY(sortedlist54->id);\n   } else {\n      sortedlist54 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist54->refC = 1;\n      sortedlist54->id = 54;\n      sortedlist54->n = 0;\n      sortedlist54->root = NULL;\n      DEBUG_NEW(sortedlist54->id);\n   }\n   return sortedlist54;\n}\n\n### File: func14.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func14(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop6 = 0;\n   unsigned int loopLimit6 = (rand()%loopsFactor)/2 + 1;\n   for(; loop6 < loopLimit6; loop6++) {\n      sortedlist_t* sortedlist38;\n      if (pCounter > 0) {\n         sortedlist38 = vars->data[--pCounter];\n         sortedlist38->refC++;\n         DEBUG_COPY(sortedlist38->id);\n      } else {\n         sortedlist38 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist38->refC = 1;\n         sortedlist38->id = 38;\n         sortedlist38->n = 0;\n         sortedlist38->root = NULL;\n         DEBUG_NEW(sortedlist38->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist38;\n      sortedlist_t* sortedlist39 = func22(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist39->id);\n      free(params0.data);\n      sortedlist39->refC--;\n      if(sortedlist39->refC == 0){\n           cell_t* cell19 = sortedlist39->root;\n           cell_t* tmp19  = NULL;\n           while(cell19 != NULL) {\n               tmp19 = cell19->next;\n               free(cell19);\n               cell19 = tmp19;\n           }\n           free(sortedlist39);\n           DEBUG_FREE(sortedlist39->id);\n      }\n      sortedlist38->refC--;\n      if(sortedlist38->refC == 0){\n           cell_t* cell20 = sortedlist38->root;\n           cell_t* tmp20  = NULL;\n           while(cell20 != NULL) {\n               tmp20 = cell20->next;\n               free(cell20);\n               cell20 = tmp20;\n           }\n           free(sortedlist38);\n           DEBUG_FREE(sortedlist38->id);\n      }\n   }\n   sortedlist_t* sortedlist40;\n   if (pCounter > 0) {\n      sortedlist40 = vars->data[--pCounter];\n      sortedlist40->refC++;\n      DEBUG_COPY(sortedlist40->id);\n   } else {\n      sortedlist40 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist40->refC = 1;\n      sortedlist40->id = 40;\n      sortedlist40->n = 0;\n      sortedlist40->root = NULL;\n      DEBUG_NEW(sortedlist40->id);\n   }\n   return sortedlist40;\n}\n\n### File: func15.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func15(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist42 = func19(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist42->id);\n   free(params0.data);\n   return sortedlist42;\n}\n\n### File: func16.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func16(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist7 = func17(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist7->id);\n      free(params0.data);\n      sortedlist7->refC--;\n      if(sortedlist7->refC == 0){\n           cell_t* cell6 = sortedlist7->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist7);\n           DEBUG_FREE(sortedlist7->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist16 = func18(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist16->id);\n      free(params0.data);\n      sortedlist16->refC--;\n      if(sortedlist16->refC == 0){\n           cell_t* cell12 = sortedlist16->root;\n           cell_t* tmp12  = NULL;\n           while(cell12 != NULL) {\n               tmp12 = cell12->next;\n               free(cell12);\n               cell12 = tmp12;\n           }\n           free(sortedlist16);\n           DEBUG_FREE(sortedlist16->id);\n      }\n   }\n   sortedlist_t* sortedlist28;\n   if (pCounter > 0) {\n      sortedlist28 = vars->data[--pCounter];\n      sortedlist28->refC++;\n      DEBUG_COPY(sortedlist28->id);\n   } else {\n      sortedlist28 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist28->refC = 1;\n      sortedlist28->id = 28;\n      sortedlist28->n = 0;\n      sortedlist28->root = NULL;\n      DEBUG_NEW(sortedlist28->id);\n   }\n   return sortedlist28;\n}\n\n### File: func17.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func17(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/3 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      sortedlist_t* sortedlist8;\n      if (pCounter > 0) {\n         sortedlist8 = vars->data[--pCounter];\n         sortedlist8->refC++;\n         DEBUG_COPY(sortedlist8->id);\n      } else {\n         sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist8->refC = 1;\n         sortedlist8->id = 8;\n         sortedlist8->n = 0;\n         sortedlist8->root = NULL;\n         DEBUG_NEW(sortedlist8->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist8;\n      sortedlist_t* sortedlist9 = func28(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell4 = sortedlist9->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n      sortedlist8->refC--;\n      if(sortedlist8->refC == 0){\n           cell_t* cell5 = sortedlist8->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist8);\n           DEBUG_FREE(sortedlist8->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func18.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func18(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist17 = func22(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist17->id);\n   free(params0.data);\n   return sortedlist17;\n}\n\n### File: func19.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func19(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist43 = func20(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist43->id);\n      free(params0.data);\n      sortedlist43->refC--;\n      if(sortedlist43->refC == 0){\n           cell_t* cell23 = sortedlist43->root;\n           cell_t* tmp23  = NULL;\n           while(cell23 != NULL) {\n               tmp23 = cell23->next;\n               free(cell23);\n               cell23 = tmp23;\n           }\n           free(sortedlist43);\n           DEBUG_FREE(sortedlist43->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist45 = func21(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist45->id);\n      free(params0.data);\n      sortedlist45->refC--;\n      if(sortedlist45->refC == 0){\n           cell_t* cell27 = sortedlist45->root;\n           cell_t* tmp27  = NULL;\n           while(cell27 != NULL) {\n               tmp27 = cell27->next;\n               free(cell27);\n               cell27 = tmp27;\n           }\n           free(sortedlist45);\n           DEBUG_FREE(sortedlist45->id);\n      }\n   }\n   sortedlist_t* sortedlist53;\n   if (pCounter > 0) {\n      sortedlist53 = vars->data[--pCounter];\n      sortedlist53->refC++;\n      DEBUG_COPY(sortedlist53->id);\n   } else {\n      sortedlist53 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist53->refC = 1;\n      sortedlist53->id = 53;\n      sortedlist53->n = 0;\n      sortedlist53->root = NULL;\n      DEBUG_NEW(sortedlist53->id);\n   }\n   return sortedlist53;\n}\n\n### File: func2.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist57;\n   if (pCounter > 0) {\n      sortedlist57 = vars->data[--pCounter];\n      sortedlist57->refC++;\n      DEBUG_COPY(sortedlist57->id);\n   } else {\n      sortedlist57 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist57->refC = 1;\n      sortedlist57->id = 57;\n      sortedlist57->n = 0;\n      sortedlist57->root = NULL;\n      DEBUG_NEW(sortedlist57->id);\n   }\n   unsigned int loop9 = 0;\n   unsigned int loopLimit9 = (rand()%loopsFactor)/2 + 1;\n   for(; loop9 < loopLimit9; loop9++) {\n      if(sortedlist57 != NULL && sortedlist57->n > 0)\n      {\n          cell_t* cell31 = sortedlist57->root;\n          if(cell31->val == 11)\n          {\n              cell31 = cell31->next;\n              sortedlist57->n--;\n          }else{\n              while(cell31->next != NULL && cell31->next->val != 11) cell31 = cell31->next;\n              if(cell31->next != NULL)\n              {\n                  cell31 = cell31->next->next;\n                  sortedlist57->n--;\n              }\n           }\n      }\n   }\n   return sortedlist57;\n}\n\n### File: func20.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func20(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist44;\n   if (pCounter > 0) {\n      sortedlist44 = vars->data[--pCounter];\n      sortedlist44->refC++;\n      DEBUG_COPY(sortedlist44->id);\n   } else {\n      sortedlist44 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist44->refC = 1;\n      sortedlist44->id = 44;\n      sortedlist44->n = 0;\n      sortedlist44->root = NULL;\n      DEBUG_NEW(sortedlist44->id);\n   }\n   unsigned int loop7 = 0;\n   unsigned int loopLimit7 = (rand()%loopsFactor)/2 + 1;\n   for(; loop7 < loopLimit7; loop7++) {\n      if(sortedlist44 != NULL && sortedlist44->n > 0)\n      {\n          cell_t* cell22 = sortedlist44->root;\n          if(cell22->val == 30)\n          {\n              cell22 = cell22->next;\n              sortedlist44->n--;\n          }else{\n              while(cell22->next != NULL && cell22->next->val != 30) cell22 = cell22->next;\n              if(cell22->next != NULL)\n              {\n                  cell22 = cell22->next->next;\n                  sortedlist44->n--;\n              }\n           }\n      }\n   }\n   return sortedlist44;\n}\n\n### File: func21.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func21(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist46 = func25(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist46->id);\n   free(params0.data);\n   return sortedlist46;\n}\n\n### File: func22.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func22(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist18 = func23(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist18->id);\n      free(params0.data);\n      sortedlist18->refC--;\n      if(sortedlist18->refC == 0){\n           cell_t* cell8 = sortedlist18->root;\n           cell_t* tmp8  = NULL;\n           while(cell8 != NULL) {\n               tmp8 = cell8->next;\n               free(cell8);\n               cell8 = tmp8;\n           }\n           free(sortedlist18);\n           DEBUG_FREE(sortedlist18->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist20 = func24(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist20->id);\n      free(params0.data);\n      sortedlist20->refC--;\n      if(sortedlist20->refC == 0){\n           cell_t* cell11 = sortedlist20->root;\n           cell_t* tmp11  = NULL;\n           while(cell11 != NULL) {\n               tmp11 = cell11->next;\n               free(cell11);\n               cell11 = tmp11;\n           }\n           free(sortedlist20);\n           DEBUG_FREE(sortedlist20->id);\n      }\n   }\n   sortedlist_t* sortedlist27;\n   if (pCounter > 0) {\n      sortedlist27 = vars->data[--pCounter];\n      sortedlist27->refC++;\n      DEBUG_COPY(sortedlist27->id);\n   } else {\n      sortedlist27 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist27->refC = 1;\n      sortedlist27->id = 27;\n      sortedlist27->n = 0;\n      sortedlist27->root = NULL;\n      DEBUG_NEW(sortedlist27->id);\n   }\n   return sortedlist27;\n}\n\n### File: func23.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func23(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist19;\n   if (pCounter > 0) {\n      sortedlist19 = vars->data[--pCounter];\n      sortedlist19->refC++;\n      DEBUG_COPY(sortedlist19->id);\n   } else {\n      sortedlist19 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist19->refC = 1;\n      sortedlist19->id = 19;\n      sortedlist19->n = 0;\n      sortedlist19->root = NULL;\n      DEBUG_NEW(sortedlist19->id);\n   }\n   unsigned int loop4 = 0;\n   unsigned int loopLimit4 = (rand()%loopsFactor)/3 + 1;\n   for(; loop4 < loopLimit4; loop4++) {\n      if(sortedlist19 != NULL && sortedlist19->n > 0)\n      {\n          cell_t* cell7 = sortedlist19->root;\n          if(cell7->val == 49)\n          {\n              cell7 = cell7->next;\n              sortedlist19->n--;\n          }else{\n              while(cell7->next != NULL && cell7->next->val != 49) cell7 = cell7->next;\n              if(cell7->next != NULL)\n              {\n                  cell7 = cell7->next->next;\n                  sortedlist19->n--;\n              }\n           }\n      }\n   }\n   return sortedlist19;\n}\n\n### File: func24.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func24(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist21 = func31(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist21->id);\n   free(params0.data);\n   return sortedlist21;\n}\n\n### File: func25.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func25(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist47 = func26(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist47->id);\n      free(params0.data);\n      sortedlist47->refC--;\n      if(sortedlist47->refC == 0){\n           cell_t* cell25 = sortedlist47->root;\n           cell_t* tmp25  = NULL;\n           while(cell25 != NULL) {\n               tmp25 = cell25->next;\n               free(cell25);\n               cell25 = tmp25;\n           }\n           free(sortedlist47);\n           DEBUG_FREE(sortedlist47->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist50 = func27(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist50->id);\n      free(params0.data);\n      sortedlist50->refC--;\n      if(sortedlist50->refC == 0){\n           cell_t* cell26 = sortedlist50->root;\n           cell_t* tmp26  = NULL;\n           while(cell26 != NULL) {\n               tmp26 = cell26->next;\n               free(cell26);\n               cell26 = tmp26;\n           }\n           free(sortedlist50);\n           DEBUG_FREE(sortedlist50->id);\n      }\n   }\n   sortedlist_t* sortedlist52;\n   if (pCounter > 0) {\n      sortedlist52 = vars->data[--pCounter];\n      sortedlist52->refC++;\n      DEBUG_COPY(sortedlist52->id);\n   } else {\n      sortedlist52 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist52->refC = 1;\n      sortedlist52->id = 52;\n      sortedlist52->n = 0;\n      sortedlist52->root = NULL;\n      DEBUG_NEW(sortedlist52->id);\n   }\n   return sortedlist52;\n}\n\n### File: func26.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func26(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop8 = 0;\n   unsigned int loopLimit8 = (rand()%loopsFactor)/2 + 1;\n   for(; loop8 < loopLimit8; loop8++) {\n      sortedlist_t* sortedlist48;\n      if (pCounter > 0) {\n         sortedlist48 = vars->data[--pCounter];\n         sortedlist48->refC++;\n         DEBUG_COPY(sortedlist48->id);\n      } else {\n         sortedlist48 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist48->refC = 1;\n         sortedlist48->id = 48;\n         sortedlist48->n = 0;\n         sortedlist48->root = NULL;\n         DEBUG_NEW(sortedlist48->id);\n      }\n      sortedlist48->refC--;\n      if(sortedlist48->refC == 0){\n           cell_t* cell24 = sortedlist48->root;\n           cell_t* tmp24  = NULL;\n           while(cell24 != NULL) {\n               tmp24 = cell24->next;\n               free(cell24);\n               cell24 = tmp24;\n           }\n           free(sortedlist48);\n           DEBUG_FREE(sortedlist48->id);\n      }\n   }\n   sortedlist_t* sortedlist49;\n   if (pCounter > 0) {\n      sortedlist49 = vars->data[--pCounter];\n      sortedlist49->refC++;\n      DEBUG_COPY(sortedlist49->id);\n   } else {\n      sortedlist49 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist49->refC = 1;\n      sortedlist49->id = 49;\n      sortedlist49->n = 0;\n      sortedlist49->root = NULL;\n      DEBUG_NEW(sortedlist49->id);\n   }\n   return sortedlist49;\n}\n\n### File: func27.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func27(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist51 = func28(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist51->id);\n   free(params0.data);\n   return sortedlist51;\n}\n\n### File: func28.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func28(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist10 = func29(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist10->id);\n      free(params0.data);\n      sortedlist10->refC--;\n      if(sortedlist10->refC == 0){\n           cell_t* cell2 = sortedlist10->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist10);\n           DEBUG_FREE(sortedlist10->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist12 = func30(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist12->id);\n      free(params0.data);\n      sortedlist12->refC--;\n      if(sortedlist12->refC == 0){\n           cell_t* cell3 = sortedlist12->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist12);\n           DEBUG_FREE(sortedlist12->id);\n      }\n   }\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func29.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func29(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist11;\n   if (pCounter > 0) {\n      sortedlist11 = vars->data[--pCounter];\n      sortedlist11->refC++;\n      DEBUG_COPY(sortedlist11->id);\n   } else {\n      sortedlist11 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist11->refC = 1;\n      sortedlist11->id = 11;\n      sortedlist11->n = 0;\n      sortedlist11->root = NULL;\n      DEBUG_NEW(sortedlist11->id);\n   }\n   return sortedlist11;\n}\n\n### File: func3.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist59 = func7(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist59->id);\n   free(params0.data);\n   return sortedlist59;\n}\n\n### File: func30.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func30(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist13;\n   if (pCounter > 0) {\n      sortedlist13 = vars->data[--pCounter];\n      sortedlist13->refC++;\n      DEBUG_COPY(sortedlist13->id);\n   } else {\n      sortedlist13 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist13->refC = 1;\n      sortedlist13->id = 13;\n      sortedlist13->n = 0;\n      sortedlist13->root = NULL;\n      DEBUG_NEW(sortedlist13->id);\n   }\n   return sortedlist13;\n}\n\n### File: func31.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func31(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist22 = func32(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist22->id);\n      free(params0.data);\n      sortedlist22->refC--;\n      if(sortedlist22->refC == 0){\n           cell_t* cell9 = sortedlist22->root;\n           cell_t* tmp9  = NULL;\n           while(cell9 != NULL) {\n               tmp9 = cell9->next;\n               free(cell9);\n               cell9 = tmp9;\n           }\n           free(sortedlist22);\n           DEBUG_FREE(sortedlist22->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist24 = func33(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist24->id);\n      free(params0.data);\n      sortedlist24->refC--;\n      if(sortedlist24->refC == 0){\n           cell_t* cell10 = sortedlist24->root;\n           cell_t* tmp10  = NULL;\n           while(cell10 != NULL) {\n               tmp10 = cell10->next;\n               free(cell10);\n               cell10 = tmp10;\n           }\n           free(sortedlist24);\n           DEBUG_FREE(sortedlist24->id);\n      }\n   }\n   sortedlist_t* sortedlist26;\n   if (pCounter > 0) {\n      sortedlist26 = vars->data[--pCounter];\n      sortedlist26->refC++;\n      DEBUG_COPY(sortedlist26->id);\n   } else {\n      sortedlist26 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist26->refC = 1;\n      sortedlist26->id = 26;\n      sortedlist26->n = 0;\n      sortedlist26->root = NULL;\n      DEBUG_NEW(sortedlist26->id);\n   }\n   return sortedlist26;\n}\n\n### File: func32.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func32(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist23;\n   if (pCounter > 0) {\n      sortedlist23 = vars->data[--pCounter];\n      sortedlist23->refC++;\n      DEBUG_COPY(sortedlist23->id);\n   } else {\n      sortedlist23 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist23->refC = 1;\n      sortedlist23->id = 23;\n      sortedlist23->n = 0;\n      sortedlist23->root = NULL;\n      DEBUG_NEW(sortedlist23->id);\n   }\n   return sortedlist23;\n}\n\n### File: func33.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func33(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist25;\n   if (pCounter > 0) {\n      sortedlist25 = vars->data[--pCounter];\n      sortedlist25->refC++;\n      DEBUG_COPY(sortedlist25->id);\n   } else {\n      sortedlist25 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist25->refC = 1;\n      sortedlist25->id = 25;\n      sortedlist25->n = 0;\n      sortedlist25->root = NULL;\n      DEBUG_NEW(sortedlist25->id);\n   }\n   return sortedlist25;\n}\n\n### File: func4.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist33 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist33->id);\n      free(params0.data);\n      sortedlist33->refC--;\n      if(sortedlist33->refC == 0){\n           cell_t* cell18 = sortedlist33->root;\n           cell_t* tmp18  = NULL;\n           while(cell18 != NULL) {\n               tmp18 = cell18->next;\n               free(cell18);\n               cell18 = tmp18;\n           }\n           free(sortedlist33);\n           DEBUG_FREE(sortedlist33->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist35 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist35->id);\n      free(params0.data);\n      sortedlist35->refC--;\n      if(sortedlist35->refC == 0){\n           cell_t* cell29 = sortedlist35->root;\n           cell_t* tmp29  = NULL;\n           while(cell29 != NULL) {\n               tmp29 = cell29->next;\n               free(cell29);\n               cell29 = tmp29;\n           }\n           free(sortedlist35);\n           DEBUG_FREE(sortedlist35->id);\n      }\n   }\n   sortedlist_t* sortedlist55;\n   if (pCounter > 0) {\n      sortedlist55 = vars->data[--pCounter];\n      sortedlist55->refC++;\n      DEBUG_COPY(sortedlist55->id);\n   } else {\n      sortedlist55 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist55->refC = 1;\n      sortedlist55->id = 55;\n      sortedlist55->n = 0;\n      sortedlist55->root = NULL;\n      DEBUG_NEW(sortedlist55->id);\n   }\n   return sortedlist55;\n}\n\n### File: func5.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist34;\n   if (pCounter > 0) {\n      sortedlist34 = vars->data[--pCounter];\n      sortedlist34->refC++;\n      DEBUG_COPY(sortedlist34->id);\n   } else {\n      sortedlist34 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist34->refC = 1;\n      sortedlist34->id = 34;\n      sortedlist34->n = 0;\n      sortedlist34->root = NULL;\n      DEBUG_NEW(sortedlist34->id);\n   }\n   unsigned int loop5 = 0;\n   unsigned int loopLimit5 = (rand()%loopsFactor)/2 + 1;\n   for(; loop5 < loopLimit5; loop5++) {\n      if(sortedlist34 != NULL && sortedlist34->n > 0)\n      {\n          cell_t* cell17 = sortedlist34->root;\n          if(cell17->val == 68)\n          {\n              cell17 = cell17->next;\n              sortedlist34->n--;\n          }else{\n              while(cell17->next != NULL && cell17->next->val != 68) cell17 = cell17->next;\n              if(cell17->next != NULL)\n              {\n                  cell17 = cell17->next->next;\n                  sortedlist34->n--;\n              }\n           }\n      }\n   }\n   return sortedlist34;\n}\n\n### File: func6.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist36 = func13(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist36->id);\n   free(params0.data);\n   return sortedlist36;\n}\n\n### File: func7.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist60 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist60->id);\n      free(params0.data);\n      sortedlist60->refC--;\n      if(sortedlist60->refC == 0){\n           cell_t* cell35 = sortedlist60->root;\n           cell_t* tmp35  = NULL;\n           while(cell35 != NULL) {\n               tmp35 = cell35->next;\n               free(cell35);\n               cell35 = tmp35;\n           }\n           free(sortedlist60);\n           DEBUG_FREE(sortedlist60->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist64 = func9(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist64->id);\n      free(params0.data);\n      sortedlist64->refC--;\n      if(sortedlist64->refC == 0){\n           cell_t* cell36 = sortedlist64->root;\n           cell_t* tmp36  = NULL;\n           while(cell36 != NULL) {\n               tmp36 = cell36->next;\n               free(cell36);\n               cell36 = tmp36;\n           }\n           free(sortedlist64);\n           DEBUG_FREE(sortedlist64->id);\n      }\n   }\n   sortedlist_t* sortedlist66;\n   if (pCounter > 0) {\n      sortedlist66 = vars->data[--pCounter];\n      sortedlist66->refC++;\n      DEBUG_COPY(sortedlist66->id);\n   } else {\n      sortedlist66 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist66->refC = 1;\n      sortedlist66->id = 66;\n      sortedlist66->n = 0;\n      sortedlist66->root = NULL;\n      DEBUG_NEW(sortedlist66->id);\n   }\n   return sortedlist66;\n}\n\n### File: func8.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop10 = 0;\n   unsigned int loopLimit10 = (rand()%loopsFactor)/2 + 1;\n   for(; loop10 < loopLimit10; loop10++) {\n      sortedlist_t* sortedlist61;\n      if (pCounter > 0) {\n         sortedlist61 = vars->data[--pCounter];\n         sortedlist61->refC++;\n         DEBUG_COPY(sortedlist61->id);\n      } else {\n         sortedlist61 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist61->refC = 1;\n         sortedlist61->id = 61;\n         sortedlist61->n = 0;\n         sortedlist61->root = NULL;\n         DEBUG_NEW(sortedlist61->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist61;\n      sortedlist_t* sortedlist62 = func19(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist62->id);\n      free(params0.data);\n      sortedlist62->refC--;\n      if(sortedlist62->refC == 0){\n           cell_t* cell33 = sortedlist62->root;\n           cell_t* tmp33  = NULL;\n           while(cell33 != NULL) {\n               tmp33 = cell33->next;\n               free(cell33);\n               cell33 = tmp33;\n           }\n           free(sortedlist62);\n           DEBUG_FREE(sortedlist62->id);\n      }\n      sortedlist61->refC--;\n      if(sortedlist61->refC == 0){\n           cell_t* cell34 = sortedlist61->root;\n           cell_t* tmp34  = NULL;\n           while(cell34 != NULL) {\n               tmp34 = cell34->next;\n               free(cell34);\n               cell34 = tmp34;\n           }\n           free(sortedlist61);\n           DEBUG_FREE(sortedlist61->id);\n      }\n   }\n   sortedlist_t* sortedlist63;\n   if (pCounter > 0) {\n      sortedlist63 = vars->data[--pCounter];\n      sortedlist63->refC++;\n      DEBUG_COPY(sortedlist63->id);\n   } else {\n      sortedlist63 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist63->refC = 1;\n      sortedlist63->id = 63;\n      sortedlist63->n = 0;\n      sortedlist63->root = NULL;\n      DEBUG_NEW(sortedlist63->id);\n   }\n   return sortedlist63;\n}\n\n### File: func9.c\n#include \"sortedlist5_19.h\" \nsortedlist_t* func9(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist65 = func10(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist65->id);\n   free(params0.data);\n   return sortedlist65;\n}\n\n### File: rng.c\n#include \"sortedlist5_19.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist5_19.c\n#include \"sortedlist5_19.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell16 = sortedlist0->root;\n              cell_t* tmp16  = NULL;\n              while(cell16 != NULL) {\n                  tmp16 = cell16->next;\n                  free(cell16);\n                  cell16 = tmp16;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist31 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist31->id);\n         free(params0.data);\n         sortedlist31->refC--;\n         if(sortedlist31->refC == 0){\n              cell_t* cell30 = sortedlist31->root;\n              cell_t* tmp30  = NULL;\n              while(cell30 != NULL) {\n                  tmp30 = cell30->next;\n                  free(cell30);\n                  cell30 = tmp30;\n              }\n              free(sortedlist31);\n              DEBUG_FREE(sortedlist31->id);\n         }\n      }\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist56 = func2(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist56->id);\n         free(params0.data);\n         sortedlist56->refC--;\n         if(sortedlist56->refC == 0){\n              cell_t* cell32 = sortedlist56->root;\n              cell_t* tmp32  = NULL;\n              while(cell32 != NULL) {\n                  tmp32 = cell32->next;\n                  free(cell32);\n                  cell32 = tmp32;\n              }\n              free(sortedlist56);\n              DEBUG_FREE(sortedlist56->id);\n         }\n      }\n      else {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist58 = func3(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist58->id);\n         free(params0.data);\n         sortedlist58->refC--;\n         if(sortedlist58->refC == 0){\n              cell_t* cell37 = sortedlist58->root;\n              cell_t* tmp37  = NULL;\n              while(cell37 != NULL) {\n                  tmp37 = cell37->next;\n                  free(cell37);\n                  cell37 = tmp37;\n              }\n              free(sortedlist58);\n              DEBUG_FREE(sortedlist58->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist5_19.h\n#ifndef sortedlist5_19\n#define sortedlist5_19\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func10(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func11(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func12(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func16(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func17(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func28(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func29(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func30(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func18(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func22(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func23(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func24(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func31(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func32(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func33(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func13(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func14(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func15(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func19(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func20(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func21(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func25(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func26(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func27(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func9(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2007640\n    - Instructions: 1412914\n    - Cache References: 93301\n    - Cache Misses: 34316\n    - Branch Instructions: 266267\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist6_17.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist6_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist6_17.c\n#include \"sortedlist6_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist6_17.h\n#ifndef sortedlist6_17\n#define sortedlist6_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 9114520\n    - Instructions: 14360362\n    - Cache References: 92893\n    - Cache Misses: 33839\n    - Branch Instructions: 2145513\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array2_14.c\n#include \"array2_14.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array2_14.h\n#ifndef array2_14\n#define array2_14\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array2_14.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array2_14.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 21189471\n    - Instructions: 33230973\n    - Cache References: 197287\n    - Cache Misses: 55970\n    - Branch Instructions: 6382509\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist13_6.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist13_6.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist13_6.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist13_6.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist13_6.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist13_6.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist13_6.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist13_6.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist13_6.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist13_6.c\n#include \"sortedlist13_6.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            sortedlist_t_param params0;\n            params0.size = 0;\n            params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n            sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n            DEBUG_RETURN(sortedlist9->id);\n            free(params0.data);\n            sortedlist9->refC--;\n            if(sortedlist9->refC == 0){\n                 cell_t* cell7 = sortedlist9->root;\n                 cell_t* tmp7  = NULL;\n                 while(cell7 != NULL) {\n                     tmp7 = cell7->next;\n                     free(cell7);\n                     cell7 = tmp7;\n                 }\n                 free(sortedlist9);\n                 DEBUG_FREE(sortedlist9->id);\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist13_6.h\n#ifndef sortedlist13_6\n#define sortedlist13_6\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7527299\n    - Instructions: 14393645\n    - Cache References: 76616\n    - Cache Misses: 22170\n    - Branch Instructions: 2150150\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array6_7.c\n#include \"array6_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array6_7.h\n#ifndef array6_7\n#define array6_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array6_7.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array6_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2644214\n    - Instructions: 2929714\n    - Cache References: 89950\n    - Cache Misses: 22608\n    - Branch Instructions: 555133\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array7_4.c\n#include \"array7_4.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      unsigned int loop0 = 0;\n      unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n      for(; loop0 < loopLimit0; loop0++) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n   }\n   else {\n      unsigned int loop2 = 0;\n      unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n      for(; loop2 < loopLimit2; loop2++) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(array9->id);\n         free(params0.data);\n         array9->refC--;\n         if(array9->refC == 0) {\n            free(array9->data);\n            free(array9);\n            DEBUG_FREE(array9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array7_4.h\n#ifndef array7_4\n#define array7_4\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array7_4.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array7_4.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array7_4.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array7_4.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array7_4.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array7_4.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array7_4.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array7_4.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array7_4.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 91089628\n    - Instructions: 199825631\n    - Cache References: 195010\n    - Cache Misses: 69885\n    - Branch Instructions: 29713595\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array7_1.c\n#include \"array7_1.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array7_1.h\n#ifndef array7_1\n#define array7_1\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array7_1.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array1 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array1->id);\n      free(params0.data);\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array3;\n   if (pCounter > 0) {\n      array3 = vars->data[--pCounter];\n      array3->refC++;\n      DEBUG_COPY(array3->id);\n   } else {\n      array3 = (array_t*)malloc(sizeof(array_t));\n      array3->size = 59;\n      array3->refC = 1;\n      array3->id = 3;\n      array3->data = (unsigned int*)malloc(array3->size*sizeof(unsigned int));\n      memset(array3->data, 0, array3->size*sizeof(unsigned int));\n      DEBUG_NEW(array3->id);\n   }\n   return array3;\n}\n\n### File: func1.c\n#include \"array7_1.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array2;\n   if (pCounter > 0) {\n      array2 = vars->data[--pCounter];\n      array2->refC++;\n      DEBUG_COPY(array2->id);\n   } else {\n      array2 = (array_t*)malloc(sizeof(array_t));\n      array2->size = 362;\n      array2->refC = 1;\n      array2->id = 2;\n      array2->data = (unsigned int*)malloc(array2->size*sizeof(unsigned int));\n      memset(array2->data, 0, array2->size*sizeof(unsigned int));\n      DEBUG_NEW(array2->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      for (int i = 0; i < array2->size; i++) {\n         array2->data[i]--;\n      }\n   }\n   return array2;\n}\n\n### File: rng.c\n#include \"array7_1.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1523389\n    - Instructions: 1117261\n    - Cache References: 68709\n    - Cache Misses: 26432\n    - Branch Instructions: 207390\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist5_11.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist5_11.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist5_11.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist5_11.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist5_11.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist5_11.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist5_11.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist5_11.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist5_11.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist5_11.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist5_11.c\n#include \"sortedlist5_11.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist16 = func2(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params0.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell8 = sortedlist16->root;\n        cell_t* tmp8  = NULL;\n        while(cell8 != NULL) {\n            tmp8 = cell8->next;\n            free(cell8);\n            cell8 = tmp8;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   return 0;\n}\n\n### File: sortedlist5_11.h\n#ifndef sortedlist5_11\n#define sortedlist5_11\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1932958\n    - Instructions: 1135235\n    - Cache References: 92291\n    - Cache Misses: 31200\n    - Branch Instructions: 210221\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array15_8.c\n#include \"array15_8.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   return 0;\n}\n\n### File: array15_8.h\n#ifndef array15_8\n#define array15_8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array15_8.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array15_8.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array15_8.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array15_8.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array15_8.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array15_8.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array15_8.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array15_8.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array15_8.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1926190\n    - Instructions: 1689708\n    - Cache References: 80176\n    - Cache Misses: 30436\n    - Branch Instructions: 322049\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist3_10.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist3_10.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist3_10.c\n#include \"sortedlist3_10.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist3_10.h\n#ifndef sortedlist3_10\n#define sortedlist3_10\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7542540\n    - Instructions: 15270890\n    - Cache References: 92535\n    - Cache Misses: 20895\n    - Branch Instructions: 3016153\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist3_1.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist1 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist1->id);\n      free(params0.data);\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell1 = sortedlist1->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist3;\n   if (pCounter > 0) {\n      sortedlist3 = vars->data[--pCounter];\n      sortedlist3->refC++;\n      DEBUG_COPY(sortedlist3->id);\n   } else {\n      sortedlist3 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist3->refC = 1;\n      sortedlist3->id = 3;\n      sortedlist3->n = 0;\n      sortedlist3->root = NULL;\n      DEBUG_NEW(sortedlist3->id);\n   }\n   return sortedlist3;\n}\n\n### File: func1.c\n#include \"sortedlist3_1.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist2 != NULL && sortedlist2->n > 0)\n      {\n          cell_t* cell0 = sortedlist2->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist2->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist2->n--;\n              }\n           }\n      }\n   }\n   return sortedlist2;\n}\n\n### File: rng.c\n#include \"sortedlist3_1.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist3_1.c\n#include \"sortedlist3_1.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist3_1.h\n#ifndef sortedlist3_1\n#define sortedlist3_1\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7652317\n    - Instructions: 13937904\n    - Cache References: 91448\n    - Cache Misses: 26043\n    - Branch Instructions: 2084868\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array2_12.c\n#include \"array2_12.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array2_12.h\n#ifndef array2_12\n#define array2_12\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array2_12.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array2_12.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1889567\n    - Instructions: 1677176\n    - Cache References: 74926\n    - Cache Misses: 26098\n    - Branch Instructions: 320009\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist4_10.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist4_10.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist4_10.c\n#include \"sortedlist4_10.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist4_10.h\n#ifndef sortedlist4_10\n#define sortedlist4_10\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7448975\n    - Instructions: 13957200\n    - Cache References: 103812\n    - Cache Misses: 23766\n    - Branch Instructions: 2088516\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array12_10.c\n#include \"array12_10.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array12_10.h\n#ifndef array12_10\n#define array12_10\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array12_10.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array12_10.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 21504690\n    - Instructions: 48069447\n    - Cache References: 130576\n    - Cache Misses: 32072\n    - Branch Instructions: 9276540\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array5_6.c\n#include \"array5_6.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            array_t_param params0;\n            params0.size = 0;\n            params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n            array_t* array9 = func1(&params0, loopsFactor);\n            DEBUG_RETURN(array9->id);\n            free(params0.data);\n            array9->refC--;\n            if(array9->refC == 0) {\n               free(array9->data);\n               free(array9);\n               DEBUG_FREE(array9->id);\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array5_6.h\n#ifndef array5_6\n#define array5_6\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array5_6.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array5_6.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array5_6.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array5_6.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array5_6.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array5_6.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array5_6.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array5_6.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array5_6.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 11281312\n    - Instructions: 24846096\n    - Cache References: 99462\n    - Cache Misses: 34019\n    - Branch Instructions: 4770490\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist1_6.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell0 = sortedlist1->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   return sortedlist2;\n}\n\n### File: func1.c\n#include \"sortedlist1_6.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist4 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist4->id);\n   free(params0.data);\n   return sortedlist4;\n}\n\n### File: func2.c\n#include \"sortedlist1_6.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell2 = sortedlist5->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist7 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist7->id);\n      free(params0.data);\n      sortedlist7->refC--;\n      if(sortedlist7->refC == 0){\n           cell_t* cell3 = sortedlist7->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist7);\n           DEBUG_FREE(sortedlist7->id);\n      }\n   }\n   sortedlist_t* sortedlist9;\n   if (pCounter > 0) {\n      sortedlist9 = vars->data[--pCounter];\n      sortedlist9->refC++;\n      DEBUG_COPY(sortedlist9->id);\n   } else {\n      sortedlist9 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist9->refC = 1;\n      sortedlist9->id = 9;\n      sortedlist9->n = 0;\n      sortedlist9->root = NULL;\n      DEBUG_NEW(sortedlist9->id);\n   }\n   return sortedlist9;\n}\n\n### File: func3.c\n#include \"sortedlist1_6.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: func4.c\n#include \"sortedlist1_6.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: rng.c\n#include \"sortedlist1_6.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist1_6.c\n#include \"sortedlist1_6.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            sortedlist_t_param params0;\n            params0.size = 0;\n            params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n            sortedlist_t* sortedlist3 = func1(&params0, loopsFactor);\n            DEBUG_RETURN(sortedlist3->id);\n            free(params0.data);\n            sortedlist3->refC--;\n            if(sortedlist3->refC == 0){\n                 cell_t* cell4 = sortedlist3->root;\n                 cell_t* tmp4  = NULL;\n                 while(cell4 != NULL) {\n                     tmp4 = cell4->next;\n                     free(cell4);\n                     cell4 = tmp4;\n                 }\n                 free(sortedlist3);\n                 DEBUG_FREE(sortedlist3->id);\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist1_6.h\n#ifndef sortedlist1_6\n#define sortedlist1_6\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7817805\n    - Instructions: 13898092\n    - Cache References: 101313\n    - Cache Misses: 40890\n    - Branch Instructions: 2078809\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array7_9.c\n#include \"array7_9.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array7_9.h\n#ifndef array7_9\n#define array7_9\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array7_9.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array7_9.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7454739\n    - Instructions: 14362359\n    - Cache References: 86535\n    - Cache Misses: 21235\n    - Branch Instructions: 2145758\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array15_7.c\n#include \"array15_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array15_7.h\n#ifndef array15_7\n#define array15_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array15_7.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array15_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1589661\n    - Instructions: 1113421\n    - Cache References: 68526\n    - Cache Misses: 22554\n    - Branch Instructions: 206542\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist10_2.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist10_2.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist10_2.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist10_2.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist10_2.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist10_2.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist10_2.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist10_2.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist10_2.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist10_2.c\n#include \"sortedlist10_2.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist10_2.h\n#ifndef sortedlist10_2\n#define sortedlist10_2\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1637076\n    - Instructions: 1395198\n    - Cache References: 68003\n    - Cache Misses: 15605\n    - Branch Instructions: 263395\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist2_17.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist2_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist2_17.c\n#include \"sortedlist2_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist2_17.h\n#ifndef sortedlist2_17\n#define sortedlist2_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1806210\n    - Instructions: 1166209\n    - Cache References: 95063\n    - Cache Misses: 39116\n    - Branch Instructions: 215584\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array14_8.c\n#include \"array14_8.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   return 0;\n}\n\n### File: array14_8.h\n#ifndef array14_8\n#define array14_8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array14_8.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array14_8.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array14_8.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array14_8.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array14_8.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array14_8.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array14_8.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array14_8.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array14_8.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7421991\n    - Instructions: 14335544\n    - Cache References: 73958\n    - Cache Misses: 18717\n    - Branch Instructions: 2141908\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array3_7.c\n#include \"array3_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array3_7.h\n#ifndef array3_7\n#define array3_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array3_7.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array3_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 358404760\n    - Instructions: 609571619\n    - Cache References: 1586819\n    - Cache Misses: 271416\n    - Branch Instructions: 94556854\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array3_20.c\n#include \"array3_20.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n         unsigned int loop4 = 0;\n         unsigned int loopLimit4 = (rand()%loopsFactor)/2 + 1;\n         for(; loop4 < loopLimit4; loop4++) {\n            if(rng() & 1) {\n               array_t_param params0;\n               params0.size = 0;\n               params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n               array_t* array10 = func1(&params0, loopsFactor);\n               DEBUG_RETURN(array10->id);\n               free(params0.data);\n               array10->refC--;\n               if(array10->refC == 0) {\n                  free(array10->data);\n                  free(array10);\n                  DEBUG_FREE(array10->id);\n               }\n            }\n            else {\n               array_t_param params0;\n               params0.size = 0;\n               params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n               array_t* array19 = func2(&params0, loopsFactor);\n               DEBUG_RETURN(array19->id);\n               free(params0.data);\n               array19->refC--;\n               if(array19->refC == 0) {\n                  free(array19->data);\n                  free(array19);\n                  DEBUG_FREE(array19->id);\n               }\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array3_20.h\n#ifndef array3_20\n#define array3_20\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array3_20.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array9;\n   if (pCounter > 0) {\n      array9 = vars->data[--pCounter];\n      array9->refC++;\n      DEBUG_COPY(array9->id);\n   } else {\n      array9 = (array_t*)malloc(sizeof(array_t));\n      array9->size = 123;\n      array9->refC = 1;\n      array9->id = 9;\n      array9->data = (unsigned int*)malloc(array9->size*sizeof(unsigned int));\n      memset(array9->data, 0, array9->size*sizeof(unsigned int));\n      DEBUG_NEW(array9->id);\n   }\n   return array9;\n}\n\n### File: func1.c\n#include \"array3_20.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array11 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array11->id);\n   free(params0.data);\n   return array11;\n}\n\n### File: func2.c\n#include \"array3_20.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array20;\n   if (pCounter > 0) {\n      array20 = vars->data[--pCounter];\n      array20->refC++;\n      DEBUG_COPY(array20->id);\n   } else {\n      array20 = (array_t*)malloc(sizeof(array_t));\n      array20->size = 305;\n      array20->refC = 1;\n      array20->id = 20;\n      array20->data = (unsigned int*)malloc(array20->size*sizeof(unsigned int));\n      memset(array20->data, 0, array20->size*sizeof(unsigned int));\n      DEBUG_NEW(array20->id);\n   }\n   unsigned int loop8 = 0;\n   unsigned int loopLimit8 = (rand()%loopsFactor)/3 + 1;\n   for(; loop8 < loopLimit8; loop8++) {\n      for (int i = 0; i < array20->size; i++) {\n         array20->data[i]--;\n      }\n   }\n   return array20;\n}\n\n### File: func3.c\n#include \"array3_20.h\" \narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array12 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array12->id);\n      free(params0.data);\n      array12->refC--;\n      if(array12->refC == 0) {\n         free(array12->data);\n         free(array12);\n         DEBUG_FREE(array12->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array14 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array14->id);\n      free(params0.data);\n      array14->refC--;\n      if(array14->refC == 0) {\n         free(array14->data);\n         free(array14);\n         DEBUG_FREE(array14->id);\n      }\n   }\n   array_t* array18;\n   if (pCounter > 0) {\n      array18 = vars->data[--pCounter];\n      array18->refC++;\n      DEBUG_COPY(array18->id);\n   } else {\n      array18 = (array_t*)malloc(sizeof(array_t));\n      array18->size = 980;\n      array18->refC = 1;\n      array18->id = 18;\n      array18->data = (unsigned int*)malloc(array18->size*sizeof(unsigned int));\n      memset(array18->data, 0, array18->size*sizeof(unsigned int));\n      DEBUG_NEW(array18->id);\n   }\n   return array18;\n}\n\n### File: func4.c\n#include \"array3_20.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array13;\n   if (pCounter > 0) {\n      array13 = vars->data[--pCounter];\n      array13->refC++;\n      DEBUG_COPY(array13->id);\n   } else {\n      array13 = (array_t*)malloc(sizeof(array_t));\n      array13->size = 373;\n      array13->refC = 1;\n      array13->id = 13;\n      array13->data = (unsigned int*)malloc(array13->size*sizeof(unsigned int));\n      memset(array13->data, 0, array13->size*sizeof(unsigned int));\n      DEBUG_NEW(array13->id);\n   }\n   unsigned int loop5 = 0;\n   unsigned int loopLimit5 = (rand()%loopsFactor)/3 + 1;\n   for(; loop5 < loopLimit5; loop5++) {\n      for (int i = 0; i < array13->size; i++) {\n         array13->data[i]--;\n      }\n   }\n   return array13;\n}\n\n### File: func5.c\n#include \"array3_20.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop6 = 0;\n   unsigned int loopLimit6 = (rand()%loopsFactor)/3 + 1;\n   for(; loop6 < loopLimit6; loop6++) {\n      array_t* array15;\n      if (pCounter > 0) {\n         array15 = vars->data[--pCounter];\n         array15->refC++;\n         DEBUG_COPY(array15->id);\n      } else {\n         array15 = (array_t*)malloc(sizeof(array_t));\n         array15->size = 315;\n         array15->refC = 1;\n         array15->id = 15;\n         array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n         memset(array15->data, 0, array15->size*sizeof(unsigned int));\n         DEBUG_NEW(array15->id);\n      }\n      array_t* array16;\n      if (pCounter > 0) {\n         array16 = vars->data[--pCounter];\n         array16->refC++;\n         DEBUG_COPY(array16->id);\n      } else {\n         array16 = (array_t*)malloc(sizeof(array_t));\n         array16->size = 370;\n         array16->refC = 1;\n         array16->id = 16;\n         array16->data = (unsigned int*)malloc(array16->size*sizeof(unsigned int));\n         memset(array16->data, 0, array16->size*sizeof(unsigned int));\n         DEBUG_NEW(array16->id);\n      }\n      unsigned int loop7 = 0;\n      unsigned int loopLimit7 = (rand()%loopsFactor)/4 + 1;\n      for(; loop7 < loopLimit7; loop7++) {\n         for (int i = 0; i < array16->size; i++) {\n            array16->data[i]--;\n         }\n      }\n      array16->refC--;\n      if(array16->refC == 0) {\n         free(array16->data);\n         free(array16);\n         DEBUG_FREE(array16->id);\n      }\n      array15->refC--;\n      if(array15->refC == 0) {\n         free(array15->data);\n         free(array15);\n         DEBUG_FREE(array15->id);\n      }\n   }\n   array_t* array17;\n   if (pCounter > 0) {\n      array17 = vars->data[--pCounter];\n      array17->refC++;\n      DEBUG_COPY(array17->id);\n   } else {\n      array17 = (array_t*)malloc(sizeof(array_t));\n      array17->size = 526;\n      array17->refC = 1;\n      array17->id = 17;\n      array17->data = (unsigned int*)malloc(array17->size*sizeof(unsigned int));\n      memset(array17->data, 0, array17->size*sizeof(unsigned int));\n      DEBUG_NEW(array17->id);\n   }\n   return array17;\n}\n\n### File: func6.c\n#include \"array3_20.h\" \narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func7.c\n#include \"array3_20.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      for (int i = 0; i < array4->size; i++) {\n         array4->data[i]--;\n      }\n   }\n   return array4;\n}\n\n### File: func8.c\n#include \"array3_20.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/3 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      array_t* array6;\n      if (pCounter > 0) {\n         array6 = vars->data[--pCounter];\n         array6->refC++;\n         DEBUG_COPY(array6->id);\n      } else {\n         array6 = (array_t*)malloc(sizeof(array_t));\n         array6->size = 567;\n         array6->refC = 1;\n         array6->id = 6;\n         array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n         memset(array6->data, 0, array6->size*sizeof(unsigned int));\n         DEBUG_NEW(array6->id);\n      }\n      array6->refC--;\n      if(array6->refC == 0) {\n         free(array6->data);\n         free(array6);\n         DEBUG_FREE(array6->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: rng.c\n#include \"array3_20.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 3512541\n    - Instructions: 2986611\n    - Cache References: 120340\n    - Cache Misses: 33814\n    - Branch Instructions: 564590\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array11_4.c\n#include \"array11_4.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      unsigned int loop0 = 0;\n      unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n      for(; loop0 < loopLimit0; loop0++) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n   }\n   else {\n      unsigned int loop2 = 0;\n      unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n      for(; loop2 < loopLimit2; loop2++) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(array9->id);\n         free(params0.data);\n         array9->refC--;\n         if(array9->refC == 0) {\n            free(array9->data);\n            free(array9);\n            DEBUG_FREE(array9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array11_4.h\n#ifndef array11_4\n#define array11_4\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array11_4.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array11_4.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array11_4.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array11_4.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array11_4.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array11_4.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array11_4.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array11_4.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array11_4.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 8634516\n    - Instructions: 15283794\n    - Cache References: 118617\n    - Cache Misses: 30915\n    - Branch Instructions: 3018090\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist14_1.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist1 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist1->id);\n      free(params0.data);\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell1 = sortedlist1->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist3;\n   if (pCounter > 0) {\n      sortedlist3 = vars->data[--pCounter];\n      sortedlist3->refC++;\n      DEBUG_COPY(sortedlist3->id);\n   } else {\n      sortedlist3 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist3->refC = 1;\n      sortedlist3->id = 3;\n      sortedlist3->n = 0;\n      sortedlist3->root = NULL;\n      DEBUG_NEW(sortedlist3->id);\n   }\n   return sortedlist3;\n}\n\n### File: func1.c\n#include \"sortedlist14_1.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist2 != NULL && sortedlist2->n > 0)\n      {\n          cell_t* cell0 = sortedlist2->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist2->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist2->n--;\n              }\n           }\n      }\n   }\n   return sortedlist2;\n}\n\n### File: rng.c\n#include \"sortedlist14_1.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist14_1.c\n#include \"sortedlist14_1.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist14_1.h\n#ifndef sortedlist14_1\n#define sortedlist14_1\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2464207\n    - Instructions: 2283402\n    - Cache References: 96579\n    - Cache Misses: 28637\n    - Branch Instructions: 434463\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist11_5.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell3 = sortedlist2->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell4 = sortedlist1->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist11_5.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist11_5.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/1 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      if(sortedlist17 != NULL && sortedlist17->n > 0)\n      {\n          cell_t* cell8 = sortedlist17->root;\n          if(cell8->val == 59)\n          {\n              cell8 = cell8->next;\n              sortedlist17->n--;\n          }else{\n              while(cell8->next != NULL && cell8->next->val != 59) cell8 = cell8->next;\n              if(cell8->next != NULL)\n              {\n                  cell8 = cell8->next->next;\n                  sortedlist17->n--;\n              }\n           }\n      }\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist11_5.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell6 = sortedlist11->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell7 = sortedlist13->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist11_5.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist12 != NULL && sortedlist12->n > 0)\n      {\n          cell_t* cell5 = sortedlist12->root;\n          if(cell5->val == 92)\n          {\n              cell5 = cell5->next;\n              sortedlist12->n--;\n          }else{\n              while(cell5->next != NULL && cell5->next->val != 92) cell5 = cell5->next;\n              if(cell5->next != NULL)\n              {\n                  cell5 = cell5->next->next;\n                  sortedlist12->n--;\n              }\n           }\n      }\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist11_5.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist11_5.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell1 = sortedlist3->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell2 = sortedlist5->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist11_5.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist4 != NULL && sortedlist4->n > 0)\n      {\n          cell_t* cell0 = sortedlist4->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist4->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist4->n--;\n              }\n           }\n      }\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist11_5.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist11_5.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist11_5.c\n#include \"sortedlist11_5.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist0->id);\n   free(params0.data);\n   sortedlist_t_param params1;\n   params1.size = 1;\n   params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n   params1.data[0] = sortedlist0;\n   sortedlist_t* sortedlist9 = func1(&params1, loopsFactor);\n   DEBUG_RETURN(sortedlist9->id);\n   free(params1.data);\n   sortedlist_t_param params2;\n   params2.size = 2;\n   params2.data = (sortedlist_t**)malloc(params2.size*sizeof(sortedlist_t*));\n   params2.data[0] = sortedlist0;\n   params2.data[1] = sortedlist9;\n   sortedlist_t* sortedlist16 = func2(&params2, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params2.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell9 = sortedlist16->root;\n        cell_t* tmp9  = NULL;\n        while(cell9 != NULL) {\n            tmp9 = cell9->next;\n            free(cell9);\n            cell9 = tmp9;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   sortedlist9->refC--;\n   if(sortedlist9->refC == 0){\n        cell_t* cell10 = sortedlist9->root;\n        cell_t* tmp10  = NULL;\n        while(cell10 != NULL) {\n            tmp10 = cell10->next;\n            free(cell10);\n            cell10 = tmp10;\n        }\n        free(sortedlist9);\n        DEBUG_FREE(sortedlist9->id);\n   }\n   sortedlist0->refC--;\n   if(sortedlist0->refC == 0){\n        cell_t* cell11 = sortedlist0->root;\n        cell_t* tmp11  = NULL;\n        while(cell11 != NULL) {\n            tmp11 = cell11->next;\n            free(cell11);\n            cell11 = tmp11;\n        }\n        free(sortedlist0);\n        DEBUG_FREE(sortedlist0->id);\n   }\n   return 0;\n}\n\n### File: sortedlist11_5.h\n#ifndef sortedlist11_5\n#define sortedlist11_5\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 13792753\n    - Instructions: 19819855\n    - Cache References: 137790\n    - Cache Misses: 32730\n    - Branch Instructions: 3797275\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array5_18.c\n#include \"array5_18.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(array9->id);\n         free(params0.data);\n         array9->refC--;\n         if(array9->refC == 0) {\n            free(array9->data);\n            free(array9);\n            DEBUG_FREE(array9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array5_18.h\n#ifndef array5_18\n#define array5_18\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array5_18.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array5_18.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array5_18.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array5_18.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array5_18.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array5_18.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array5_18.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array5_18.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array5_18.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7432823\n    - Instructions: 14356991\n    - Cache References: 76903\n    - Cache Misses: 18146\n    - Branch Instructions: 2144571\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array1_7.c\n#include \"array1_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array1_7.h\n#ifndef array1_7\n#define array1_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array1_7.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array1_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7309778\n    - Instructions: 13919484\n    - Cache References: 87598\n    - Cache Misses: 19815\n    - Branch Instructions: 2082179\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array14_12.c\n#include \"array14_12.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array14_12.h\n#ifndef array14_12\n#define array14_12\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array14_12.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array14_12.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2090768\n    - Instructions: 2258249\n    - Cache References: 73719\n    - Cache Misses: 23000\n    - Branch Instructions: 429007\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist5_5.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell3 = sortedlist2->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell4 = sortedlist1->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist5_5.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist5_5.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/1 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      if(sortedlist17 != NULL && sortedlist17->n > 0)\n      {\n          cell_t* cell8 = sortedlist17->root;\n          if(cell8->val == 59)\n          {\n              cell8 = cell8->next;\n              sortedlist17->n--;\n          }else{\n              while(cell8->next != NULL && cell8->next->val != 59) cell8 = cell8->next;\n              if(cell8->next != NULL)\n              {\n                  cell8 = cell8->next->next;\n                  sortedlist17->n--;\n              }\n           }\n      }\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist5_5.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell6 = sortedlist11->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell7 = sortedlist13->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist5_5.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist12 != NULL && sortedlist12->n > 0)\n      {\n          cell_t* cell5 = sortedlist12->root;\n          if(cell5->val == 92)\n          {\n              cell5 = cell5->next;\n              sortedlist12->n--;\n          }else{\n              while(cell5->next != NULL && cell5->next->val != 92) cell5 = cell5->next;\n              if(cell5->next != NULL)\n              {\n                  cell5 = cell5->next->next;\n                  sortedlist12->n--;\n              }\n           }\n      }\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist5_5.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist5_5.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell1 = sortedlist3->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell2 = sortedlist5->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist5_5.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist4 != NULL && sortedlist4->n > 0)\n      {\n          cell_t* cell0 = sortedlist4->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist4->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist4->n--;\n              }\n           }\n      }\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist5_5.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist5_5.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist5_5.c\n#include \"sortedlist5_5.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist0->id);\n   free(params0.data);\n   sortedlist_t_param params1;\n   params1.size = 1;\n   params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n   params1.data[0] = sortedlist0;\n   sortedlist_t* sortedlist9 = func1(&params1, loopsFactor);\n   DEBUG_RETURN(sortedlist9->id);\n   free(params1.data);\n   sortedlist_t_param params2;\n   params2.size = 2;\n   params2.data = (sortedlist_t**)malloc(params2.size*sizeof(sortedlist_t*));\n   params2.data[0] = sortedlist0;\n   params2.data[1] = sortedlist9;\n   sortedlist_t* sortedlist16 = func2(&params2, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params2.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell9 = sortedlist16->root;\n        cell_t* tmp9  = NULL;\n        while(cell9 != NULL) {\n            tmp9 = cell9->next;\n            free(cell9);\n            cell9 = tmp9;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   sortedlist9->refC--;\n   if(sortedlist9->refC == 0){\n        cell_t* cell10 = sortedlist9->root;\n        cell_t* tmp10  = NULL;\n        while(cell10 != NULL) {\n            tmp10 = cell10->next;\n            free(cell10);\n            cell10 = tmp10;\n        }\n        free(sortedlist9);\n        DEBUG_FREE(sortedlist9->id);\n   }\n   sortedlist0->refC--;\n   if(sortedlist0->refC == 0){\n        cell_t* cell11 = sortedlist0->root;\n        cell_t* tmp11  = NULL;\n        while(cell11 != NULL) {\n            tmp11 = cell11->next;\n            free(cell11);\n            cell11 = tmp11;\n        }\n        free(sortedlist0);\n        DEBUG_FREE(sortedlist0->id);\n   }\n   return 0;\n}\n\n### File: sortedlist5_5.h\n#ifndef sortedlist5_5\n#define sortedlist5_5\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 753636354\n    - Instructions: 1532166090\n    - Cache References: 1586120\n    - Cache Misses: 280361\n    - Branch Instructions: 229071843\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array13_20.c\n#include \"array13_20.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n         unsigned int loop5 = 0;\n         unsigned int loopLimit5 = (rand()%loopsFactor)/2 + 1;\n         for(; loop5 < loopLimit5; loop5++) {\n            if(rng() & 1) {\n               array_t_param params0;\n               params0.size = 0;\n               params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n               array_t* array11 = func1(&params0, loopsFactor);\n               DEBUG_RETURN(array11->id);\n               free(params0.data);\n               array11->refC--;\n               if(array11->refC == 0) {\n                  free(array11->data);\n                  free(array11);\n                  DEBUG_FREE(array11->id);\n               }\n            }\n            else {\n               array_t_param params0;\n               params0.size = 0;\n               params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n               array_t* array20 = func2(&params0, loopsFactor);\n               DEBUG_RETURN(array20->id);\n               free(params0.data);\n               array20->refC--;\n               if(array20->refC == 0) {\n                  free(array20->data);\n                  free(array20);\n                  DEBUG_FREE(array20->id);\n               }\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array13_20.h\n#ifndef array13_20\n#define array13_20\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array13_20.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array10;\n   if (pCounter > 0) {\n      array10 = vars->data[--pCounter];\n      array10->refC++;\n      DEBUG_COPY(array10->id);\n   } else {\n      array10 = (array_t*)malloc(sizeof(array_t));\n      array10->size = 135;\n      array10->refC = 1;\n      array10->id = 10;\n      array10->data = (unsigned int*)malloc(array10->size*sizeof(unsigned int));\n      memset(array10->data, 0, array10->size*sizeof(unsigned int));\n      DEBUG_NEW(array10->id);\n   }\n   return array10;\n}\n\n### File: func1.c\n#include \"array13_20.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array12 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array12->id);\n   free(params0.data);\n   return array12;\n}\n\n### File: func2.c\n#include \"array13_20.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array21;\n   if (pCounter > 0) {\n      array21 = vars->data[--pCounter];\n      array21->refC++;\n      DEBUG_COPY(array21->id);\n   } else {\n      array21 = (array_t*)malloc(sizeof(array_t));\n      array21->size = 84;\n      array21->refC = 1;\n      array21->id = 21;\n      array21->data = (unsigned int*)malloc(array21->size*sizeof(unsigned int));\n      memset(array21->data, 0, array21->size*sizeof(unsigned int));\n      DEBUG_NEW(array21->id);\n   }\n   unsigned int loop9 = 0;\n   unsigned int loopLimit9 = (rand()%loopsFactor)/3 + 1;\n   for(; loop9 < loopLimit9; loop9++) {\n      for (int i = 0; i < array21->size; i++) {\n         array21->data[i]--;\n      }\n   }\n   return array21;\n}\n\n### File: func3.c\n#include \"array13_20.h\" \narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array15 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array15->id);\n      free(params0.data);\n      array15->refC--;\n      if(array15->refC == 0) {\n         free(array15->data);\n         free(array15);\n         DEBUG_FREE(array15->id);\n      }\n   }\n   array_t* array19;\n   if (pCounter > 0) {\n      array19 = vars->data[--pCounter];\n      array19->refC++;\n      DEBUG_COPY(array19->id);\n   } else {\n      array19 = (array_t*)malloc(sizeof(array_t));\n      array19->size = 873;\n      array19->refC = 1;\n      array19->id = 19;\n      array19->data = (unsigned int*)malloc(array19->size*sizeof(unsigned int));\n      memset(array19->data, 0, array19->size*sizeof(unsigned int));\n      DEBUG_NEW(array19->id);\n   }\n   return array19;\n}\n\n### File: func4.c\n#include \"array13_20.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 919;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   unsigned int loop6 = 0;\n   unsigned int loopLimit6 = (rand()%loopsFactor)/3 + 1;\n   for(; loop6 < loopLimit6; loop6++) {\n      for (int i = 0; i < array14->size; i++) {\n         array14->data[i]--;\n      }\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array13_20.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop7 = 0;\n   unsigned int loopLimit7 = (rand()%loopsFactor)/3 + 1;\n   for(; loop7 < loopLimit7; loop7++) {\n      array_t* array16;\n      if (pCounter > 0) {\n         array16 = vars->data[--pCounter];\n         array16->refC++;\n         DEBUG_COPY(array16->id);\n      } else {\n         array16 = (array_t*)malloc(sizeof(array_t));\n         array16->size = 413;\n         array16->refC = 1;\n         array16->id = 16;\n         array16->data = (unsigned int*)malloc(array16->size*sizeof(unsigned int));\n         memset(array16->data, 0, array16->size*sizeof(unsigned int));\n         DEBUG_NEW(array16->id);\n      }\n      array_t* array17;\n      if (pCounter > 0) {\n         array17 = vars->data[--pCounter];\n         array17->refC++;\n         DEBUG_COPY(array17->id);\n      } else {\n         array17 = (array_t*)malloc(sizeof(array_t));\n         array17->size = 526;\n         array17->refC = 1;\n         array17->id = 17;\n         array17->data = (unsigned int*)malloc(array17->size*sizeof(unsigned int));\n         memset(array17->data, 0, array17->size*sizeof(unsigned int));\n         DEBUG_NEW(array17->id);\n      }\n      unsigned int loop8 = 0;\n      unsigned int loopLimit8 = (rand()%loopsFactor)/4 + 1;\n      for(; loop8 < loopLimit8; loop8++) {\n         for (int i = 0; i < array17->size; i++) {\n            array17->data[i]--;\n         }\n      }\n      array17->refC--;\n      if(array17->refC == 0) {\n         free(array17->data);\n         free(array17);\n         DEBUG_FREE(array17->id);\n      }\n      array16->refC--;\n      if(array16->refC == 0) {\n         free(array16->data);\n         free(array16);\n         DEBUG_FREE(array16->id);\n      }\n   }\n   array_t* array18;\n   if (pCounter > 0) {\n      array18 = vars->data[--pCounter];\n      array18->refC++;\n      DEBUG_COPY(array18->id);\n   } else {\n      array18 = (array_t*)malloc(sizeof(array_t));\n      array18->size = 980;\n      array18->refC = 1;\n      array18->id = 18;\n      array18->data = (unsigned int*)malloc(array18->size*sizeof(unsigned int));\n      memset(array18->data, 0, array18->size*sizeof(unsigned int));\n      DEBUG_NEW(array18->id);\n   }\n   return array18;\n}\n\n### File: func6.c\n#include \"array13_20.h\" \narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array9;\n   if (pCounter > 0) {\n      array9 = vars->data[--pCounter];\n      array9->refC++;\n      DEBUG_COPY(array9->id);\n   } else {\n      array9 = (array_t*)malloc(sizeof(array_t));\n      array9->size = 123;\n      array9->refC = 1;\n      array9->id = 9;\n      array9->data = (unsigned int*)malloc(array9->size*sizeof(unsigned int));\n      memset(array9->data, 0, array9->size*sizeof(unsigned int));\n      DEBUG_NEW(array9->id);\n   }\n   return array9;\n}\n\n### File: func7.c\n#include \"array13_20.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      for (int i = 0; i < array4->size; i++) {\n         array4->data[i]--;\n      }\n   }\n   return array4;\n}\n\n### File: func8.c\n#include \"array13_20.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/3 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      array_t* array6;\n      if (pCounter > 0) {\n         array6 = vars->data[--pCounter];\n         array6->refC++;\n         DEBUG_COPY(array6->id);\n      } else {\n         array6 = (array_t*)malloc(sizeof(array_t));\n         array6->size = 567;\n         array6->refC = 1;\n         array6->id = 6;\n         array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n         memset(array6->data, 0, array6->size*sizeof(unsigned int));\n         DEBUG_NEW(array6->id);\n      }\n      array_t* array7;\n      if (pCounter > 0) {\n         array7 = vars->data[--pCounter];\n         array7->refC++;\n         DEBUG_COPY(array7->id);\n      } else {\n         array7 = (array_t*)malloc(sizeof(array_t));\n         array7->size = 429;\n         array7->refC = 1;\n         array7->id = 7;\n         array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n         memset(array7->data, 0, array7->size*sizeof(unsigned int));\n         DEBUG_NEW(array7->id);\n      }\n      unsigned int loop4 = 0;\n      unsigned int loopLimit4 = (rand()%loopsFactor)/4 + 1;\n      for(; loop4 < loopLimit4; loop4++) {\n         for (int i = 0; i < array6->size; i++) {\n            array6->data[i]--;\n         }\n      }\n      array7->refC--;\n      if(array7->refC == 0) {\n         free(array7->data);\n         free(array7);\n         DEBUG_FREE(array7->id);\n      }\n      array6->refC--;\n      if(array6->refC == 0) {\n         free(array6->data);\n         free(array6);\n         DEBUG_FREE(array6->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: rng.c\n#include \"array13_20.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 8163399\n    - Instructions: 15811308\n    - Cache References: 94710\n    - Cache Misses: 22866\n    - Branch Instructions: 2395462\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array13_5.c\n#include \"array13_5.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array0 = func0(&params0, loopsFactor);\n   DEBUG_RETURN(array0->id);\n   free(params0.data);\n   array_t_param params1;\n   params1.size = 1;\n   params1.data = (array_t**)malloc(params1.size*sizeof(array_t*));\n   params1.data[0] = array0;\n   array_t* array9 = func1(&params1, loopsFactor);\n   DEBUG_RETURN(array9->id);\n   free(params1.data);\n   array_t_param params2;\n   params2.size = 2;\n   params2.data = (array_t**)malloc(params2.size*sizeof(array_t*));\n   params2.data[0] = array0;\n   params2.data[1] = array9;\n   array_t* array16 = func2(&params2, loopsFactor);\n   DEBUG_RETURN(array16->id);\n   free(params2.data);\n   array16->refC--;\n   if(array16->refC == 0) {\n      free(array16->data);\n      free(array16);\n      DEBUG_FREE(array16->id);\n   }\n   array9->refC--;\n   if(array9->refC == 0) {\n      free(array9->data);\n      free(array9);\n      DEBUG_FREE(array9->id);\n   }\n   array0->refC--;\n   if(array0->refC == 0) {\n      free(array0->data);\n      free(array0);\n      DEBUG_FREE(array0->id);\n   }\n   return 0;\n}\n\n### File: array13_5.h\n#ifndef array13_5\n#define array13_5\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array13_5.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 862;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array13_5.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array13_5.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array17;\n   if (pCounter > 0) {\n      array17 = vars->data[--pCounter];\n      array17->refC++;\n      DEBUG_COPY(array17->id);\n   } else {\n      array17 = (array_t*)malloc(sizeof(array_t));\n      array17->size = 862;\n      array17->refC = 1;\n      array17->id = 17;\n      array17->data = (unsigned int*)malloc(array17->size*sizeof(unsigned int));\n      memset(array17->data, 0, array17->size*sizeof(unsigned int));\n      DEBUG_NEW(array17->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/1 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      for (int i = 0; i < array17->size; i++) {\n         array17->data[i]--;\n      }\n   }\n   return array17;\n}\n\n### File: func3.c\n#include \"array13_5.h\" \narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 370;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func4.c\n#include \"array13_5.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 229;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      for (int i = 0; i < array12->size; i++) {\n         array12->data[i]--;\n      }\n   }\n   return array12;\n}\n\n### File: func5.c\n#include \"array13_5.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 324;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func6.c\n#include \"array13_5.h\" \narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 782;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func7.c\n#include \"array13_5.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array4->size; i++) {\n         array4->data[i]--;\n      }\n   }\n   return array4;\n}\n\n### File: func8.c\n#include \"array13_5.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 567;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array13_5.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1755299\n    - Instructions: 1126703\n    - Cache References: 80129\n    - Cache Misses: 26171\n    - Branch Instructions: 208747\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array9_8.c\n#include \"array9_8.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   return 0;\n}\n\n### File: array9_8.h\n#ifndef array9_8\n#define array9_8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array9_8.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array9_8.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array9_8.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array9_8.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array9_8.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array9_8.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array9_8.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array9_8.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array9_8.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4070861\n    - Instructions: 6781195\n    - Cache References: 80311\n    - Cache Misses: 20555\n    - Branch Instructions: 1039793\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array13_16.c\n#include \"array13_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array13_16.h\n#ifndef array13_16\n#define array13_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array13_16.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array13_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1798041\n    - Instructions: 1703361\n    - Cache References: 81538\n    - Cache Misses: 18607\n    - Branch Instructions: 324695\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist15_7.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist15_7.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist15_7.c\n#include \"sortedlist15_7.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist15_7.h\n#ifndef sortedlist15_7\n#define sortedlist15_7\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 9837741\n    - Instructions: 15243412\n    - Cache References: 86362\n    - Cache Misses: 23137\n    - Branch Instructions: 3011740\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist8_1.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist1 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist1->id);\n      free(params0.data);\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell1 = sortedlist1->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist3;\n   if (pCounter > 0) {\n      sortedlist3 = vars->data[--pCounter];\n      sortedlist3->refC++;\n      DEBUG_COPY(sortedlist3->id);\n   } else {\n      sortedlist3 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist3->refC = 1;\n      sortedlist3->id = 3;\n      sortedlist3->n = 0;\n      sortedlist3->root = NULL;\n      DEBUG_NEW(sortedlist3->id);\n   }\n   return sortedlist3;\n}\n\n### File: func1.c\n#include \"sortedlist8_1.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist2 != NULL && sortedlist2->n > 0)\n      {\n          cell_t* cell0 = sortedlist2->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist2->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist2->n--;\n              }\n           }\n      }\n   }\n   return sortedlist2;\n}\n\n### File: rng.c\n#include \"sortedlist8_1.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist8_1.c\n#include \"sortedlist8_1.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist8_1.h\n#ifndef sortedlist8_1\n#define sortedlist8_1\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1568301\n    - Instructions: 1151979\n    - Cache References: 72599\n    - Cache Misses: 19508\n    - Branch Instructions: 213099\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array8_11.c\n#include \"array8_11.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array16 = func2(&params0, loopsFactor);\n   DEBUG_RETURN(array16->id);\n   free(params0.data);\n   array16->refC--;\n   if(array16->refC == 0) {\n      free(array16->data);\n      free(array16);\n      DEBUG_FREE(array16->id);\n   }\n   return 0;\n}\n\n### File: array8_11.h\n#ifndef array8_11\n#define array8_11\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array8_11.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array8_11.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array8_11.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array17;\n   if (pCounter > 0) {\n      array17 = vars->data[--pCounter];\n      array17->refC++;\n      DEBUG_COPY(array17->id);\n   } else {\n      array17 = (array_t*)malloc(sizeof(array_t));\n      array17->size = 956;\n      array17->refC = 1;\n      array17->id = 17;\n      array17->data = (unsigned int*)malloc(array17->size*sizeof(unsigned int));\n      memset(array17->data, 0, array17->size*sizeof(unsigned int));\n      DEBUG_NEW(array17->id);\n   }\n   return array17;\n}\n\n### File: func3.c\n#include \"array8_11.h\" \narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func4.c\n#include \"array8_11.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func5.c\n#include \"array8_11.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func6.c\n#include \"array8_11.h\" \narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func7.c\n#include \"array8_11.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func8.c\n#include \"array8_11.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array8_11.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7316748\n    - Instructions: 13938234\n    - Cache References: 92766\n    - Cache Misses: 25852\n    - Branch Instructions: 2085258\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array12_9.c\n#include \"array12_9.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array12_9.h\n#ifndef array12_9\n#define array12_9\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array12_9.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array12_9.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2015435\n    - Instructions: 2296591\n    - Cache References: 85817\n    - Cache Misses: 16694\n    - Branch Instructions: 435313\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist12_5.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell3 = sortedlist2->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell4 = sortedlist1->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist12_5.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist12_5.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/1 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      if(sortedlist17 != NULL && sortedlist17->n > 0)\n      {\n          cell_t* cell8 = sortedlist17->root;\n          if(cell8->val == 59)\n          {\n              cell8 = cell8->next;\n              sortedlist17->n--;\n          }else{\n              while(cell8->next != NULL && cell8->next->val != 59) cell8 = cell8->next;\n              if(cell8->next != NULL)\n              {\n                  cell8 = cell8->next->next;\n                  sortedlist17->n--;\n              }\n           }\n      }\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist12_5.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell6 = sortedlist11->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell7 = sortedlist13->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist12_5.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist12 != NULL && sortedlist12->n > 0)\n      {\n          cell_t* cell5 = sortedlist12->root;\n          if(cell5->val == 92)\n          {\n              cell5 = cell5->next;\n              sortedlist12->n--;\n          }else{\n              while(cell5->next != NULL && cell5->next->val != 92) cell5 = cell5->next;\n              if(cell5->next != NULL)\n              {\n                  cell5 = cell5->next->next;\n                  sortedlist12->n--;\n              }\n           }\n      }\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist12_5.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist12_5.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell1 = sortedlist3->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell2 = sortedlist5->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist12_5.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist4 != NULL && sortedlist4->n > 0)\n      {\n          cell_t* cell0 = sortedlist4->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist4->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist4->n--;\n              }\n           }\n      }\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist12_5.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist12_5.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist12_5.c\n#include \"sortedlist12_5.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist0->id);\n   free(params0.data);\n   sortedlist_t_param params1;\n   params1.size = 1;\n   params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n   params1.data[0] = sortedlist0;\n   sortedlist_t* sortedlist9 = func1(&params1, loopsFactor);\n   DEBUG_RETURN(sortedlist9->id);\n   free(params1.data);\n   sortedlist_t_param params2;\n   params2.size = 2;\n   params2.data = (sortedlist_t**)malloc(params2.size*sizeof(sortedlist_t*));\n   params2.data[0] = sortedlist0;\n   params2.data[1] = sortedlist9;\n   sortedlist_t* sortedlist16 = func2(&params2, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params2.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell9 = sortedlist16->root;\n        cell_t* tmp9  = NULL;\n        while(cell9 != NULL) {\n            tmp9 = cell9->next;\n            free(cell9);\n            cell9 = tmp9;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   sortedlist9->refC--;\n   if(sortedlist9->refC == 0){\n        cell_t* cell10 = sortedlist9->root;\n        cell_t* tmp10  = NULL;\n        while(cell10 != NULL) {\n            tmp10 = cell10->next;\n            free(cell10);\n            cell10 = tmp10;\n        }\n        free(sortedlist9);\n        DEBUG_FREE(sortedlist9->id);\n   }\n   sortedlist0->refC--;\n   if(sortedlist0->refC == 0){\n        cell_t* cell11 = sortedlist0->root;\n        cell_t* tmp11  = NULL;\n        while(cell11 != NULL) {\n            tmp11 = cell11->next;\n            free(cell11);\n            cell11 = tmp11;\n        }\n        free(sortedlist0);\n        DEBUG_FREE(sortedlist0->id);\n   }\n   return 0;\n}\n\n### File: sortedlist12_5.h\n#ifndef sortedlist12_5\n#define sortedlist12_5\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2053438\n    - Instructions: 1454925\n    - Cache References: 82433\n    - Cache Misses: 18981\n    - Branch Instructions: 273834\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist3_16.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist3_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist3_16.c\n#include \"sortedlist3_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist3_16.h\n#ifndef sortedlist3_16\n#define sortedlist3_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1540431\n    - Instructions: 1123245\n    - Cache References: 66768\n    - Cache Misses: 18113\n    - Branch Instructions: 208339\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist6_2.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist6_2.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist6_2.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist6_2.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist6_2.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist6_2.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist6_2.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist6_2.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist6_2.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist6_2.c\n#include \"sortedlist6_2.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist6_2.h\n#ifndef sortedlist6_2\n#define sortedlist6_2\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1733065\n    - Instructions: 1659435\n    - Cache References: 68852\n    - Cache Misses: 18934\n    - Branch Instructions: 314678\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist10_13.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n   }\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   return sortedlist2;\n}\n\n### File: rng.c\n#include \"sortedlist10_13.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist10_13.c\n#include \"sortedlist10_13.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist0 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist0->refC = 1;\n      sortedlist0->id = 0;\n      sortedlist0->n = 0;\n      sortedlist0->root = NULL;\n      DEBUG_NEW(sortedlist0->id);\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist0;\n      sortedlist_t* sortedlist1 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist1->id);\n      free(params0.data);\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell0 = sortedlist1->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist10_13.h\n#ifndef sortedlist10_13\n#define sortedlist10_13\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1568055\n    - Instructions: 1145997\n    - Cache References: 77041\n    - Cache Misses: 15301\n    - Branch Instructions: 211830\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist15_2.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist15_2.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist15_2.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist15_2.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist15_2.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist15_2.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist15_2.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist15_2.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist15_2.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist15_2.c\n#include \"sortedlist15_2.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist15_2.h\n#ifndef sortedlist15_2\n#define sortedlist15_2\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2658762\n    - Instructions: 3034537\n    - Cache References: 114962\n    - Cache Misses: 31604\n    - Branch Instructions: 574553\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array12_4.c\n#include \"array12_4.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      unsigned int loop0 = 0;\n      unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n      for(; loop0 < loopLimit0; loop0++) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n   }\n   else {\n      unsigned int loop2 = 0;\n      unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n      for(; loop2 < loopLimit2; loop2++) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(array9->id);\n         free(params0.data);\n         array9->refC--;\n         if(array9->refC == 0) {\n            free(array9->data);\n            free(array9);\n            DEBUG_FREE(array9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array12_4.h\n#ifndef array12_4\n#define array12_4\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array12_4.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array12_4.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array12_4.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array12_4.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array12_4.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array12_4.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array12_4.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array12_4.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array12_4.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 5300843\n    - Instructions: 6831685\n    - Cache References: 114318\n    - Cache Misses: 46360\n    - Branch Instructions: 1047974\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array12_16.c\n#include \"array12_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array12_16.h\n#ifndef array12_16\n#define array12_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array12_16.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array12_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 762565083\n    - Instructions: 1533962141\n    - Cache References: 2027657\n    - Cache Misses: 447818\n    - Branch Instructions: 229364344\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array11_20.c\n#include \"array11_20.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n         unsigned int loop5 = 0;\n         unsigned int loopLimit5 = (rand()%loopsFactor)/2 + 1;\n         for(; loop5 < loopLimit5; loop5++) {\n            if(rng() & 1) {\n               array_t_param params0;\n               params0.size = 0;\n               params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n               array_t* array11 = func1(&params0, loopsFactor);\n               DEBUG_RETURN(array11->id);\n               free(params0.data);\n               array11->refC--;\n               if(array11->refC == 0) {\n                  free(array11->data);\n                  free(array11);\n                  DEBUG_FREE(array11->id);\n               }\n            }\n            else {\n               array_t_param params0;\n               params0.size = 0;\n               params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n               array_t* array20 = func2(&params0, loopsFactor);\n               DEBUG_RETURN(array20->id);\n               free(params0.data);\n               array20->refC--;\n               if(array20->refC == 0) {\n                  free(array20->data);\n                  free(array20);\n                  DEBUG_FREE(array20->id);\n               }\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array11_20.h\n#ifndef array11_20\n#define array11_20\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array11_20.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array10;\n   if (pCounter > 0) {\n      array10 = vars->data[--pCounter];\n      array10->refC++;\n      DEBUG_COPY(array10->id);\n   } else {\n      array10 = (array_t*)malloc(sizeof(array_t));\n      array10->size = 135;\n      array10->refC = 1;\n      array10->id = 10;\n      array10->data = (unsigned int*)malloc(array10->size*sizeof(unsigned int));\n      memset(array10->data, 0, array10->size*sizeof(unsigned int));\n      DEBUG_NEW(array10->id);\n   }\n   return array10;\n}\n\n### File: func1.c\n#include \"array11_20.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array12 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array12->id);\n   free(params0.data);\n   return array12;\n}\n\n### File: func2.c\n#include \"array11_20.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array21;\n   if (pCounter > 0) {\n      array21 = vars->data[--pCounter];\n      array21->refC++;\n      DEBUG_COPY(array21->id);\n   } else {\n      array21 = (array_t*)malloc(sizeof(array_t));\n      array21->size = 84;\n      array21->refC = 1;\n      array21->id = 21;\n      array21->data = (unsigned int*)malloc(array21->size*sizeof(unsigned int));\n      memset(array21->data, 0, array21->size*sizeof(unsigned int));\n      DEBUG_NEW(array21->id);\n   }\n   unsigned int loop9 = 0;\n   unsigned int loopLimit9 = (rand()%loopsFactor)/3 + 1;\n   for(; loop9 < loopLimit9; loop9++) {\n      for (int i = 0; i < array21->size; i++) {\n         array21->data[i]--;\n      }\n   }\n   return array21;\n}\n\n### File: func3.c\n#include \"array11_20.h\" \narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array15 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array15->id);\n      free(params0.data);\n      array15->refC--;\n      if(array15->refC == 0) {\n         free(array15->data);\n         free(array15);\n         DEBUG_FREE(array15->id);\n      }\n   }\n   array_t* array19;\n   if (pCounter > 0) {\n      array19 = vars->data[--pCounter];\n      array19->refC++;\n      DEBUG_COPY(array19->id);\n   } else {\n      array19 = (array_t*)malloc(sizeof(array_t));\n      array19->size = 873;\n      array19->refC = 1;\n      array19->id = 19;\n      array19->data = (unsigned int*)malloc(array19->size*sizeof(unsigned int));\n      memset(array19->data, 0, array19->size*sizeof(unsigned int));\n      DEBUG_NEW(array19->id);\n   }\n   return array19;\n}\n\n### File: func4.c\n#include \"array11_20.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 919;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   unsigned int loop6 = 0;\n   unsigned int loopLimit6 = (rand()%loopsFactor)/3 + 1;\n   for(; loop6 < loopLimit6; loop6++) {\n      for (int i = 0; i < array14->size; i++) {\n         array14->data[i]--;\n      }\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array11_20.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop7 = 0;\n   unsigned int loopLimit7 = (rand()%loopsFactor)/3 + 1;\n   for(; loop7 < loopLimit7; loop7++) {\n      array_t* array16;\n      if (pCounter > 0) {\n         array16 = vars->data[--pCounter];\n         array16->refC++;\n         DEBUG_COPY(array16->id);\n      } else {\n         array16 = (array_t*)malloc(sizeof(array_t));\n         array16->size = 413;\n         array16->refC = 1;\n         array16->id = 16;\n         array16->data = (unsigned int*)malloc(array16->size*sizeof(unsigned int));\n         memset(array16->data, 0, array16->size*sizeof(unsigned int));\n         DEBUG_NEW(array16->id);\n      }\n      array_t* array17;\n      if (pCounter > 0) {\n         array17 = vars->data[--pCounter];\n         array17->refC++;\n         DEBUG_COPY(array17->id);\n      } else {\n         array17 = (array_t*)malloc(sizeof(array_t));\n         array17->size = 526;\n         array17->refC = 1;\n         array17->id = 17;\n         array17->data = (unsigned int*)malloc(array17->size*sizeof(unsigned int));\n         memset(array17->data, 0, array17->size*sizeof(unsigned int));\n         DEBUG_NEW(array17->id);\n      }\n      unsigned int loop8 = 0;\n      unsigned int loopLimit8 = (rand()%loopsFactor)/4 + 1;\n      for(; loop8 < loopLimit8; loop8++) {\n         for (int i = 0; i < array17->size; i++) {\n            array17->data[i]--;\n         }\n      }\n      array17->refC--;\n      if(array17->refC == 0) {\n         free(array17->data);\n         free(array17);\n         DEBUG_FREE(array17->id);\n      }\n      array16->refC--;\n      if(array16->refC == 0) {\n         free(array16->data);\n         free(array16);\n         DEBUG_FREE(array16->id);\n      }\n   }\n   array_t* array18;\n   if (pCounter > 0) {\n      array18 = vars->data[--pCounter];\n      array18->refC++;\n      DEBUG_COPY(array18->id);\n   } else {\n      array18 = (array_t*)malloc(sizeof(array_t));\n      array18->size = 980;\n      array18->refC = 1;\n      array18->id = 18;\n      array18->data = (unsigned int*)malloc(array18->size*sizeof(unsigned int));\n      memset(array18->data, 0, array18->size*sizeof(unsigned int));\n      DEBUG_NEW(array18->id);\n   }\n   return array18;\n}\n\n### File: func6.c\n#include \"array11_20.h\" \narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array9;\n   if (pCounter > 0) {\n      array9 = vars->data[--pCounter];\n      array9->refC++;\n      DEBUG_COPY(array9->id);\n   } else {\n      array9 = (array_t*)malloc(sizeof(array_t));\n      array9->size = 123;\n      array9->refC = 1;\n      array9->id = 9;\n      array9->data = (unsigned int*)malloc(array9->size*sizeof(unsigned int));\n      memset(array9->data, 0, array9->size*sizeof(unsigned int));\n      DEBUG_NEW(array9->id);\n   }\n   return array9;\n}\n\n### File: func7.c\n#include \"array11_20.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      for (int i = 0; i < array4->size; i++) {\n         array4->data[i]--;\n      }\n   }\n   return array4;\n}\n\n### File: func8.c\n#include \"array11_20.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/3 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      array_t* array6;\n      if (pCounter > 0) {\n         array6 = vars->data[--pCounter];\n         array6->refC++;\n         DEBUG_COPY(array6->id);\n      } else {\n         array6 = (array_t*)malloc(sizeof(array_t));\n         array6->size = 567;\n         array6->refC = 1;\n         array6->id = 6;\n         array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n         memset(array6->data, 0, array6->size*sizeof(unsigned int));\n         DEBUG_NEW(array6->id);\n      }\n      array_t* array7;\n      if (pCounter > 0) {\n         array7 = vars->data[--pCounter];\n         array7->refC++;\n         DEBUG_COPY(array7->id);\n      } else {\n         array7 = (array_t*)malloc(sizeof(array_t));\n         array7->size = 429;\n         array7->refC = 1;\n         array7->id = 7;\n         array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n         memset(array7->data, 0, array7->size*sizeof(unsigned int));\n         DEBUG_NEW(array7->id);\n      }\n      unsigned int loop4 = 0;\n      unsigned int loopLimit4 = (rand()%loopsFactor)/4 + 1;\n      for(; loop4 < loopLimit4; loop4++) {\n         for (int i = 0; i < array6->size; i++) {\n            array6->data[i]--;\n         }\n      }\n      array7->refC--;\n      if(array7->refC == 0) {\n         free(array7->data);\n         free(array7);\n         DEBUG_FREE(array7->id);\n      }\n      array6->refC--;\n      if(array6->refC == 0) {\n         free(array6->data);\n         free(array6);\n         DEBUG_FREE(array6->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: rng.c\n#include \"array11_20.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2204394\n    - Instructions: 2259575\n    - Cache References: 79457\n    - Cache Misses: 21156\n    - Branch Instructions: 428660\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist8_5.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell3 = sortedlist2->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell4 = sortedlist1->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist8_5.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist8_5.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/1 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      if(sortedlist17 != NULL && sortedlist17->n > 0)\n      {\n          cell_t* cell8 = sortedlist17->root;\n          if(cell8->val == 59)\n          {\n              cell8 = cell8->next;\n              sortedlist17->n--;\n          }else{\n              while(cell8->next != NULL && cell8->next->val != 59) cell8 = cell8->next;\n              if(cell8->next != NULL)\n              {\n                  cell8 = cell8->next->next;\n                  sortedlist17->n--;\n              }\n           }\n      }\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist8_5.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell6 = sortedlist11->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell7 = sortedlist13->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist8_5.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist12 != NULL && sortedlist12->n > 0)\n      {\n          cell_t* cell5 = sortedlist12->root;\n          if(cell5->val == 92)\n          {\n              cell5 = cell5->next;\n              sortedlist12->n--;\n          }else{\n              while(cell5->next != NULL && cell5->next->val != 92) cell5 = cell5->next;\n              if(cell5->next != NULL)\n              {\n                  cell5 = cell5->next->next;\n                  sortedlist12->n--;\n              }\n           }\n      }\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist8_5.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist8_5.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell1 = sortedlist3->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell2 = sortedlist5->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist8_5.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist4 != NULL && sortedlist4->n > 0)\n      {\n          cell_t* cell0 = sortedlist4->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist4->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist4->n--;\n              }\n           }\n      }\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist8_5.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist8_5.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist8_5.c\n#include \"sortedlist8_5.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist0->id);\n   free(params0.data);\n   sortedlist_t_param params1;\n   params1.size = 1;\n   params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n   params1.data[0] = sortedlist0;\n   sortedlist_t* sortedlist9 = func1(&params1, loopsFactor);\n   DEBUG_RETURN(sortedlist9->id);\n   free(params1.data);\n   sortedlist_t_param params2;\n   params2.size = 2;\n   params2.data = (sortedlist_t**)malloc(params2.size*sizeof(sortedlist_t*));\n   params2.data[0] = sortedlist0;\n   params2.data[1] = sortedlist9;\n   sortedlist_t* sortedlist16 = func2(&params2, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params2.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell9 = sortedlist16->root;\n        cell_t* tmp9  = NULL;\n        while(cell9 != NULL) {\n            tmp9 = cell9->next;\n            free(cell9);\n            cell9 = tmp9;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   sortedlist9->refC--;\n   if(sortedlist9->refC == 0){\n        cell_t* cell10 = sortedlist9->root;\n        cell_t* tmp10  = NULL;\n        while(cell10 != NULL) {\n            tmp10 = cell10->next;\n            free(cell10);\n            cell10 = tmp10;\n        }\n        free(sortedlist9);\n        DEBUG_FREE(sortedlist9->id);\n   }\n   sortedlist0->refC--;\n   if(sortedlist0->refC == 0){\n        cell_t* cell11 = sortedlist0->root;\n        cell_t* tmp11  = NULL;\n        while(cell11 != NULL) {\n            tmp11 = cell11->next;\n            free(cell11);\n            cell11 = tmp11;\n        }\n        free(sortedlist0);\n        DEBUG_FREE(sortedlist0->id);\n   }\n   return 0;\n}\n\n### File: sortedlist8_5.h\n#ifndef sortedlist8_5\n#define sortedlist8_5\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1575843\n    - Instructions: 1390924\n    - Cache References: 63557\n    - Cache Misses: 13577\n    - Branch Instructions: 262487\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist4_16.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist4_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist4_16.c\n#include \"sortedlist4_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist4_16.h\n#ifndef sortedlist4_16\n#define sortedlist4_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1762736\n    - Instructions: 1115222\n    - Cache References: 81270\n    - Cache Misses: 28416\n    - Branch Instructions: 207147\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array8_8.c\n#include \"array8_8.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   return 0;\n}\n\n### File: array8_8.h\n#ifndef array8_8\n#define array8_8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array8_8.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array8_8.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array8_8.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array8_8.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array8_8.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array8_8.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array8_8.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array8_8.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array8_8.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 3214364\n    - Instructions: 3093194\n    - Cache References: 106251\n    - Cache Misses: 33603\n    - Branch Instructions: 591904\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist15_15.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: func1.c\n#include \"sortedlist15_15.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist3 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist3->id);\n   free(params0.data);\n   return sortedlist3;\n}\n\n### File: func2.c\n#include \"sortedlist15_15.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist4 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist4->id);\n      free(params0.data);\n      sortedlist4->refC--;\n      if(sortedlist4->refC == 0){\n           cell_t* cell2 = sortedlist4->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist4);\n           DEBUG_FREE(sortedlist4->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist6 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist6->id);\n      free(params0.data);\n      sortedlist6->refC--;\n      if(sortedlist6->refC == 0){\n           cell_t* cell3 = sortedlist6->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist6);\n           DEBUG_FREE(sortedlist6->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func3.c\n#include \"sortedlist15_15.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist5;\n   if (pCounter > 0) {\n      sortedlist5 = vars->data[--pCounter];\n      sortedlist5->refC++;\n      DEBUG_COPY(sortedlist5->id);\n   } else {\n      sortedlist5 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist5->refC = 1;\n      sortedlist5->id = 5;\n      sortedlist5->n = 0;\n      sortedlist5->root = NULL;\n      DEBUG_NEW(sortedlist5->id);\n   }\n   return sortedlist5;\n}\n\n### File: func4.c\n#include \"sortedlist15_15.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: rng.c\n#include \"sortedlist15_15.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist15_15.c\n#include \"sortedlist15_15.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist_t_param params1;\n      params1.size = 1;\n      params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n      params1.data[0] = sortedlist0;\n      sortedlist_t* sortedlist2 = func1(&params1, loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params1.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell4 = sortedlist2->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell5 = sortedlist0->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist15_15.h\n#ifndef sortedlist15_15\n#define sortedlist15_15\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1793062\n    - Instructions: 1145022\n    - Cache References: 96808\n    - Cache Misses: 37086\n    - Branch Instructions: 211315\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist12_8.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist12_8.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist12_8.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist12_8.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist12_8.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist12_8.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist12_8.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist12_8.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist12_8.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist12_8.c\n#include \"sortedlist12_8.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist12_8.h\n#ifndef sortedlist12_8\n#define sortedlist12_8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2612495\n    - Instructions: 2309001\n    - Cache References: 103065\n    - Cache Misses: 37901\n    - Branch Instructions: 437419\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist14_5.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell3 = sortedlist2->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell4 = sortedlist1->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist14_5.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist14_5.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/1 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      if(sortedlist17 != NULL && sortedlist17->n > 0)\n      {\n          cell_t* cell8 = sortedlist17->root;\n          if(cell8->val == 59)\n          {\n              cell8 = cell8->next;\n              sortedlist17->n--;\n          }else{\n              while(cell8->next != NULL && cell8->next->val != 59) cell8 = cell8->next;\n              if(cell8->next != NULL)\n              {\n                  cell8 = cell8->next->next;\n                  sortedlist17->n--;\n              }\n           }\n      }\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist14_5.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell6 = sortedlist11->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell7 = sortedlist13->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist14_5.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist12 != NULL && sortedlist12->n > 0)\n      {\n          cell_t* cell5 = sortedlist12->root;\n          if(cell5->val == 92)\n          {\n              cell5 = cell5->next;\n              sortedlist12->n--;\n          }else{\n              while(cell5->next != NULL && cell5->next->val != 92) cell5 = cell5->next;\n              if(cell5->next != NULL)\n              {\n                  cell5 = cell5->next->next;\n                  sortedlist12->n--;\n              }\n           }\n      }\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist14_5.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist14_5.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell1 = sortedlist3->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell2 = sortedlist5->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist14_5.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist4 != NULL && sortedlist4->n > 0)\n      {\n          cell_t* cell0 = sortedlist4->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist4->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist4->n--;\n              }\n           }\n      }\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist14_5.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist14_5.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist14_5.c\n#include \"sortedlist14_5.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist0->id);\n   free(params0.data);\n   sortedlist_t_param params1;\n   params1.size = 1;\n   params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n   params1.data[0] = sortedlist0;\n   sortedlist_t* sortedlist9 = func1(&params1, loopsFactor);\n   DEBUG_RETURN(sortedlist9->id);\n   free(params1.data);\n   sortedlist_t_param params2;\n   params2.size = 2;\n   params2.data = (sortedlist_t**)malloc(params2.size*sizeof(sortedlist_t*));\n   params2.data[0] = sortedlist0;\n   params2.data[1] = sortedlist9;\n   sortedlist_t* sortedlist16 = func2(&params2, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params2.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell9 = sortedlist16->root;\n        cell_t* tmp9  = NULL;\n        while(cell9 != NULL) {\n            tmp9 = cell9->next;\n            free(cell9);\n            cell9 = tmp9;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   sortedlist9->refC--;\n   if(sortedlist9->refC == 0){\n        cell_t* cell10 = sortedlist9->root;\n        cell_t* tmp10  = NULL;\n        while(cell10 != NULL) {\n            tmp10 = cell10->next;\n            free(cell10);\n            cell10 = tmp10;\n        }\n        free(sortedlist9);\n        DEBUG_FREE(sortedlist9->id);\n   }\n   sortedlist0->refC--;\n   if(sortedlist0->refC == 0){\n        cell_t* cell11 = sortedlist0->root;\n        cell_t* tmp11  = NULL;\n        while(cell11 != NULL) {\n            tmp11 = cell11->next;\n            free(cell11);\n            cell11 = tmp11;\n        }\n        free(sortedlist0);\n        DEBUG_FREE(sortedlist0->id);\n   }\n   return 0;\n}\n\n### File: sortedlist14_5.h\n#ifndef sortedlist14_5\n#define sortedlist14_5\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7230294\n    - Instructions: 13902141\n    - Cache References: 81221\n    - Cache Misses: 23860\n    - Branch Instructions: 2079849\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array4_10.c\n#include \"array4_10.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array4_10.h\n#ifndef array4_10\n#define array4_10\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array4_10.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array4_10.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 21520483\n    - Instructions: 48343309\n    - Cache References: 106311\n    - Cache Misses: 21347\n    - Branch Instructions: 9285213\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array2_6.c\n#include \"array2_6.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            array_t_param params0;\n            params0.size = 0;\n            params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n            array_t* array9 = func1(&params0, loopsFactor);\n            DEBUG_RETURN(array9->id);\n            free(params0.data);\n            array9->refC--;\n            if(array9->refC == 0) {\n               free(array9->data);\n               free(array9);\n               DEBUG_FREE(array9->id);\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array2_6.h\n#ifndef array2_6\n#define array2_6\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array2_6.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array2_6.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array2_6.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array2_6.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array2_6.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array2_6.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array2_6.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array2_6.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array2_6.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1447974853\n    - Instructions: 3279596219\n    - Cache References: 2772714\n    - Cache Misses: 257995\n    - Branch Instructions: 567179688\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array10_19.c\n#include \"array10_19.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array90 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(array90->id);\n         free(params0.data);\n         array90->refC--;\n         if(array90->refC == 0) {\n            free(array90->data);\n            free(array90);\n            DEBUG_FREE(array90->id);\n         }\n      }\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array116 = func2(&params0, loopsFactor);\n         DEBUG_RETURN(array116->id);\n         free(params0.data);\n         array116->refC--;\n         if(array116->refC == 0) {\n            free(array116->data);\n            free(array116);\n            DEBUG_FREE(array116->id);\n         }\n      }\n      else {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array118 = func3(&params0, loopsFactor);\n         DEBUG_RETURN(array118->id);\n         free(params0.data);\n         array118->refC--;\n         if(array118->refC == 0) {\n            free(array118->data);\n            free(array118);\n            DEBUG_FREE(array118->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array10_19.h\n#ifndef array10_19\n#define array10_19\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func10(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func11(array_t_param* vars, int loopsFactor);\narray_t* func12(array_t_param* vars, int loopsFactor);\narray_t* func16(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func17(array_t_param* vars, int loopsFactor);\narray_t* func28(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func29(array_t_param* vars, int loopsFactor);\narray_t* func30(array_t_param* vars, int loopsFactor);\narray_t* func34(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func35(array_t_param* vars, int loopsFactor);\narray_t* func46(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func47(array_t_param* vars, int loopsFactor);\narray_t* func48(array_t_param* vars, int loopsFactor);\narray_t* func52(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func53(array_t_param* vars, int loopsFactor);\narray_t* func54(array_t_param* vars, int loopsFactor);\narray_t* func58(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func59(array_t_param* vars, int loopsFactor);\narray_t* func60(array_t_param* vars, int loopsFactor);\narray_t* func36(array_t_param* vars, int loopsFactor);\narray_t* func40(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func41(array_t_param* vars, int loopsFactor);\narray_t* func42(array_t_param* vars, int loopsFactor);\narray_t* func49(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func50(array_t_param* vars, int loopsFactor);\narray_t* func51(array_t_param* vars, int loopsFactor);\narray_t* func55(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func56(array_t_param* vars, int loopsFactor);\narray_t* func57(array_t_param* vars, int loopsFactor);\narray_t* func61(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func62(array_t_param* vars, int loopsFactor);\narray_t* func63(array_t_param* vars, int loopsFactor);\narray_t* func18(array_t_param* vars, int loopsFactor);\narray_t* func22(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func23(array_t_param* vars, int loopsFactor);\narray_t* func24(array_t_param* vars, int loopsFactor);\narray_t* func31(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func32(array_t_param* vars, int loopsFactor);\narray_t* func33(array_t_param* vars, int loopsFactor);\narray_t* func37(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func38(array_t_param* vars, int loopsFactor);\narray_t* func39(array_t_param* vars, int loopsFactor);\narray_t* func43(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func44(array_t_param* vars, int loopsFactor);\narray_t* func45(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func13(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func14(array_t_param* vars, int loopsFactor);\narray_t* func15(array_t_param* vars, int loopsFactor);\narray_t* func19(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func20(array_t_param* vars, int loopsFactor);\narray_t* func21(array_t_param* vars, int loopsFactor);\narray_t* func25(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func26(array_t_param* vars, int loopsFactor);\narray_t* func27(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func9(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array10_19.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func10(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array89;\n   if (pCounter > 0) {\n      array89 = vars->data[--pCounter];\n      array89->refC++;\n      DEBUG_COPY(array89->id);\n   } else {\n      array89 = (array_t*)malloc(sizeof(array_t));\n      array89->size = 163;\n      array89->refC = 1;\n      array89->id = 89;\n      array89->data = (unsigned int*)malloc(array89->size*sizeof(unsigned int));\n      memset(array89->data, 0, array89->size*sizeof(unsigned int));\n      DEBUG_NEW(array89->id);\n   }\n   return array89;\n}\n\n### File: func1.c\n#include \"array10_19.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array91 = func4(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array91->id);\n   free(params0.data);\n   return array91;\n}\n\n### File: func10.c\n#include \"array10_19.h\" \narray_t* func10(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func11(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func12(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array88;\n   if (pCounter > 0) {\n      array88 = vars->data[--pCounter];\n      array88->refC++;\n      DEBUG_COPY(array88->id);\n   } else {\n      array88 = (array_t*)malloc(sizeof(array_t));\n      array88->size = 894;\n      array88->refC = 1;\n      array88->id = 88;\n      array88->data = (unsigned int*)malloc(array88->size*sizeof(unsigned int));\n      memset(array88->data, 0, array88->size*sizeof(unsigned int));\n      DEBUG_NEW(array88->id);\n   }\n   return array88;\n}\n\n### File: func11.c\n#include \"array10_19.h\" \narray_t* func11(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      for (int i = 0; i < array4->size; i++) {\n         array4->data[i]--;\n      }\n   }\n   return array4;\n}\n\n### File: func12.c\n#include \"array10_19.h\" \narray_t* func12(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array6 = func16(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array6->id);\n   free(params0.data);\n   return array6;\n}\n\n### File: func13.c\n#include \"array10_19.h\" \narray_t* func13(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array96 = func14(&params0, loopsFactor);\n      DEBUG_RETURN(array96->id);\n      free(params0.data);\n      array96->refC--;\n      if(array96->refC == 0) {\n         free(array96->data);\n         free(array96);\n         DEBUG_FREE(array96->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array100 = func15(&params0, loopsFactor);\n      DEBUG_RETURN(array100->id);\n      free(params0.data);\n      array100->refC--;\n      if(array100->refC == 0) {\n         free(array100->data);\n         free(array100);\n         DEBUG_FREE(array100->id);\n      }\n   }\n   array_t* array114;\n   if (pCounter > 0) {\n      array114 = vars->data[--pCounter];\n      array114->refC++;\n      DEBUG_COPY(array114->id);\n   } else {\n      array114 = (array_t*)malloc(sizeof(array_t));\n      array114->size = 209;\n      array114->refC = 1;\n      array114->id = 114;\n      array114->data = (unsigned int*)malloc(array114->size*sizeof(unsigned int));\n      memset(array114->data, 0, array114->size*sizeof(unsigned int));\n      DEBUG_NEW(array114->id);\n   }\n   return array114;\n}\n\n### File: func14.c\n#include \"array10_19.h\" \narray_t* func14(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop16 = 0;\n   unsigned int loopLimit16 = (rand()%loopsFactor)/2 + 1;\n   for(; loop16 < loopLimit16; loop16++) {\n      array_t* array97;\n      if (pCounter > 0) {\n         array97 = vars->data[--pCounter];\n         array97->refC++;\n         DEBUG_COPY(array97->id);\n      } else {\n         array97 = (array_t*)malloc(sizeof(array_t));\n         array97->size = 659;\n         array97->refC = 1;\n         array97->id = 97;\n         array97->data = (unsigned int*)malloc(array97->size*sizeof(unsigned int));\n         memset(array97->data, 0, array97->size*sizeof(unsigned int));\n         DEBUG_NEW(array97->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array97;\n      array_t* array98 = func22(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array98->id);\n      free(params0.data);\n      array98->refC--;\n      if(array98->refC == 0) {\n         free(array98->data);\n         free(array98);\n         DEBUG_FREE(array98->id);\n      }\n      array97->refC--;\n      if(array97->refC == 0) {\n         free(array97->data);\n         free(array97);\n         DEBUG_FREE(array97->id);\n      }\n   }\n   array_t* array99;\n   if (pCounter > 0) {\n      array99 = vars->data[--pCounter];\n      array99->refC++;\n      DEBUG_COPY(array99->id);\n   } else {\n      array99 = (array_t*)malloc(sizeof(array_t));\n      array99->size = 210;\n      array99->refC = 1;\n      array99->id = 99;\n      array99->data = (unsigned int*)malloc(array99->size*sizeof(unsigned int));\n      memset(array99->data, 0, array99->size*sizeof(unsigned int));\n      DEBUG_NEW(array99->id);\n   }\n   return array99;\n}\n\n### File: func15.c\n#include \"array10_19.h\" \narray_t* func15(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array101 = func19(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array101->id);\n   free(params0.data);\n   return array101;\n}\n\n### File: func16.c\n#include \"array10_19.h\" \narray_t* func16(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array7 = func17(&params0, loopsFactor);\n      DEBUG_RETURN(array7->id);\n      free(params0.data);\n      array7->refC--;\n      if(array7->refC == 0) {\n         free(array7->data);\n         free(array7);\n         DEBUG_FREE(array7->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array61 = func18(&params0, loopsFactor);\n      DEBUG_RETURN(array61->id);\n      free(params0.data);\n      array61->refC--;\n      if(array61->refC == 0) {\n         free(array61->data);\n         free(array61);\n         DEBUG_FREE(array61->id);\n      }\n   }\n   array_t* array87;\n   if (pCounter > 0) {\n      array87 = vars->data[--pCounter];\n      array87->refC++;\n      DEBUG_COPY(array87->id);\n   } else {\n      array87 = (array_t*)malloc(sizeof(array_t));\n      array87->size = 881;\n      array87->refC = 1;\n      array87->id = 87;\n      array87->data = (unsigned int*)malloc(array87->size*sizeof(unsigned int));\n      memset(array87->data, 0, array87->size*sizeof(unsigned int));\n      DEBUG_NEW(array87->id);\n   }\n   return array87;\n}\n\n### File: func17.c\n#include \"array10_19.h\" \narray_t* func17(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/3 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      array_t* array8;\n      if (pCounter > 0) {\n         array8 = vars->data[--pCounter];\n         array8->refC++;\n         DEBUG_COPY(array8->id);\n      } else {\n         array8 = (array_t*)malloc(sizeof(array_t));\n         array8->size = 929;\n         array8->refC = 1;\n         array8->id = 8;\n         array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n         memset(array8->data, 0, array8->size*sizeof(unsigned int));\n         DEBUG_NEW(array8->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array8;\n      array_t* array9 = func28(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n      array8->refC--;\n      if(array8->refC == 0) {\n         free(array8->data);\n         free(array8);\n         DEBUG_FREE(array8->id);\n      }\n   }\n   array_t* array60;\n   if (pCounter > 0) {\n      array60 = vars->data[--pCounter];\n      array60->refC++;\n      DEBUG_COPY(array60->id);\n   } else {\n      array60 = (array_t*)malloc(sizeof(array_t));\n      array60->size = 428;\n      array60->refC = 1;\n      array60->id = 60;\n      array60->data = (unsigned int*)malloc(array60->size*sizeof(unsigned int));\n      memset(array60->data, 0, array60->size*sizeof(unsigned int));\n      DEBUG_NEW(array60->id);\n   }\n   return array60;\n}\n\n### File: func18.c\n#include \"array10_19.h\" \narray_t* func18(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array62 = func22(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array62->id);\n   free(params0.data);\n   return array62;\n}\n\n### File: func19.c\n#include \"array10_19.h\" \narray_t* func19(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array102 = func20(&params0, loopsFactor);\n      DEBUG_RETURN(array102->id);\n      free(params0.data);\n      array102->refC--;\n      if(array102->refC == 0) {\n         free(array102->data);\n         free(array102);\n         DEBUG_FREE(array102->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array104 = func21(&params0, loopsFactor);\n      DEBUG_RETURN(array104->id);\n      free(params0.data);\n      array104->refC--;\n      if(array104->refC == 0) {\n         free(array104->data);\n         free(array104);\n         DEBUG_FREE(array104->id);\n      }\n   }\n   array_t* array113;\n   if (pCounter > 0) {\n      array113 = vars->data[--pCounter];\n      array113->refC++;\n      DEBUG_COPY(array113->id);\n   } else {\n      array113 = (array_t*)malloc(sizeof(array_t));\n      array113->size = 190;\n      array113->refC = 1;\n      array113->id = 113;\n      array113->data = (unsigned int*)malloc(array113->size*sizeof(unsigned int));\n      memset(array113->data, 0, array113->size*sizeof(unsigned int));\n      DEBUG_NEW(array113->id);\n   }\n   return array113;\n}\n\n### File: func2.c\n#include \"array10_19.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array117;\n   if (pCounter > 0) {\n      array117 = vars->data[--pCounter];\n      array117->refC++;\n      DEBUG_COPY(array117->id);\n   } else {\n      array117 = (array_t*)malloc(sizeof(array_t));\n      array117->size = 273;\n      array117->refC = 1;\n      array117->id = 117;\n      array117->data = (unsigned int*)malloc(array117->size*sizeof(unsigned int));\n      memset(array117->data, 0, array117->size*sizeof(unsigned int));\n      DEBUG_NEW(array117->id);\n   }\n   unsigned int loop19 = 0;\n   unsigned int loopLimit19 = (rand()%loopsFactor)/2 + 1;\n   for(; loop19 < loopLimit19; loop19++) {\n      for (int i = 0; i < array117->size; i++) {\n         array117->data[i]--;\n      }\n   }\n   return array117;\n}\n\n### File: func20.c\n#include \"array10_19.h\" \narray_t* func20(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array103;\n   if (pCounter > 0) {\n      array103 = vars->data[--pCounter];\n      array103->refC++;\n      DEBUG_COPY(array103->id);\n   } else {\n      array103 = (array_t*)malloc(sizeof(array_t));\n      array103->size = 811;\n      array103->refC = 1;\n      array103->id = 103;\n      array103->data = (unsigned int*)malloc(array103->size*sizeof(unsigned int));\n      memset(array103->data, 0, array103->size*sizeof(unsigned int));\n      DEBUG_NEW(array103->id);\n   }\n   unsigned int loop17 = 0;\n   unsigned int loopLimit17 = (rand()%loopsFactor)/2 + 1;\n   for(; loop17 < loopLimit17; loop17++) {\n      for (int i = 0; i < array103->size; i++) {\n         array103->data[i]--;\n      }\n   }\n   return array103;\n}\n\n### File: func21.c\n#include \"array10_19.h\" \narray_t* func21(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array105 = func25(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array105->id);\n   free(params0.data);\n   return array105;\n}\n\n### File: func22.c\n#include \"array10_19.h\" \narray_t* func22(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array63 = func23(&params0, loopsFactor);\n      DEBUG_RETURN(array63->id);\n      free(params0.data);\n      array63->refC--;\n      if(array63->refC == 0) {\n         free(array63->data);\n         free(array63);\n         DEBUG_FREE(array63->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array65 = func24(&params0, loopsFactor);\n      DEBUG_RETURN(array65->id);\n      free(params0.data);\n      array65->refC--;\n      if(array65->refC == 0) {\n         free(array65->data);\n         free(array65);\n         DEBUG_FREE(array65->id);\n      }\n   }\n   array_t* array86;\n   if (pCounter > 0) {\n      array86 = vars->data[--pCounter];\n      array86->refC++;\n      DEBUG_COPY(array86->id);\n   } else {\n      array86 = (array_t*)malloc(sizeof(array_t));\n      array86->size = 71;\n      array86->refC = 1;\n      array86->id = 86;\n      array86->data = (unsigned int*)malloc(array86->size*sizeof(unsigned int));\n      memset(array86->data, 0, array86->size*sizeof(unsigned int));\n      DEBUG_NEW(array86->id);\n   }\n   return array86;\n}\n\n### File: func23.c\n#include \"array10_19.h\" \narray_t* func23(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array64;\n   if (pCounter > 0) {\n      array64 = vars->data[--pCounter];\n      array64->refC++;\n      DEBUG_COPY(array64->id);\n   } else {\n      array64 = (array_t*)malloc(sizeof(array_t));\n      array64->size = 818;\n      array64->refC = 1;\n      array64->id = 64;\n      array64->data = (unsigned int*)malloc(array64->size*sizeof(unsigned int));\n      memset(array64->data, 0, array64->size*sizeof(unsigned int));\n      DEBUG_NEW(array64->id);\n   }\n   unsigned int loop11 = 0;\n   unsigned int loopLimit11 = (rand()%loopsFactor)/3 + 1;\n   for(; loop11 < loopLimit11; loop11++) {\n      for (int i = 0; i < array64->size; i++) {\n         array64->data[i]--;\n      }\n   }\n   return array64;\n}\n\n### File: func24.c\n#include \"array10_19.h\" \narray_t* func24(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array66 = func31(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array66->id);\n   free(params0.data);\n   return array66;\n}\n\n### File: func25.c\n#include \"array10_19.h\" \narray_t* func25(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array106 = func26(&params0, loopsFactor);\n      DEBUG_RETURN(array106->id);\n      free(params0.data);\n      array106->refC--;\n      if(array106->refC == 0) {\n         free(array106->data);\n         free(array106);\n         DEBUG_FREE(array106->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array110 = func27(&params0, loopsFactor);\n      DEBUG_RETURN(array110->id);\n      free(params0.data);\n      array110->refC--;\n      if(array110->refC == 0) {\n         free(array110->data);\n         free(array110);\n         DEBUG_FREE(array110->id);\n      }\n   }\n   array_t* array112;\n   if (pCounter > 0) {\n      array112 = vars->data[--pCounter];\n      array112->refC++;\n      DEBUG_COPY(array112->id);\n   } else {\n      array112 = (array_t*)malloc(sizeof(array_t));\n      array112->size = 898;\n      array112->refC = 1;\n      array112->id = 112;\n      array112->data = (unsigned int*)malloc(array112->size*sizeof(unsigned int));\n      memset(array112->data, 0, array112->size*sizeof(unsigned int));\n      DEBUG_NEW(array112->id);\n   }\n   return array112;\n}\n\n### File: func26.c\n#include \"array10_19.h\" \narray_t* func26(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop18 = 0;\n   unsigned int loopLimit18 = (rand()%loopsFactor)/2 + 1;\n   for(; loop18 < loopLimit18; loop18++) {\n      array_t* array107;\n      if (pCounter > 0) {\n         array107 = vars->data[--pCounter];\n         array107->refC++;\n         DEBUG_COPY(array107->id);\n      } else {\n         array107 = (array_t*)malloc(sizeof(array_t));\n         array107->size = 630;\n         array107->refC = 1;\n         array107->id = 107;\n         array107->data = (unsigned int*)malloc(array107->size*sizeof(unsigned int));\n         memset(array107->data, 0, array107->size*sizeof(unsigned int));\n         DEBUG_NEW(array107->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array107;\n      array_t* array108 = func37(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array108->id);\n      free(params0.data);\n      array108->refC--;\n      if(array108->refC == 0) {\n         free(array108->data);\n         free(array108);\n         DEBUG_FREE(array108->id);\n      }\n      array107->refC--;\n      if(array107->refC == 0) {\n         free(array107->data);\n         free(array107);\n         DEBUG_FREE(array107->id);\n      }\n   }\n   array_t* array109;\n   if (pCounter > 0) {\n      array109 = vars->data[--pCounter];\n      array109->refC++;\n      DEBUG_COPY(array109->id);\n   } else {\n      array109 = (array_t*)malloc(sizeof(array_t));\n      array109->size = 972;\n      array109->refC = 1;\n      array109->id = 109;\n      array109->data = (unsigned int*)malloc(array109->size*sizeof(unsigned int));\n      memset(array109->data, 0, array109->size*sizeof(unsigned int));\n      DEBUG_NEW(array109->id);\n   }\n   return array109;\n}\n\n### File: func27.c\n#include \"array10_19.h\" \narray_t* func27(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array111 = func28(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array111->id);\n   free(params0.data);\n   return array111;\n}\n\n### File: func28.c\n#include \"array10_19.h\" \narray_t* func28(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array10 = func29(&params0, loopsFactor);\n      DEBUG_RETURN(array10->id);\n      free(params0.data);\n      array10->refC--;\n      if(array10->refC == 0) {\n         free(array10->data);\n         free(array10);\n         DEBUG_FREE(array10->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array12 = func30(&params0, loopsFactor);\n      DEBUG_RETURN(array12->id);\n      free(params0.data);\n      array12->refC--;\n      if(array12->refC == 0) {\n         free(array12->data);\n         free(array12);\n         DEBUG_FREE(array12->id);\n      }\n   }\n   array_t* array59;\n   if (pCounter > 0) {\n      array59 = vars->data[--pCounter];\n      array59->refC++;\n      DEBUG_COPY(array59->id);\n   } else {\n      array59 = (array_t*)malloc(sizeof(array_t));\n      array59->size = 793;\n      array59->refC = 1;\n      array59->id = 59;\n      array59->data = (unsigned int*)malloc(array59->size*sizeof(unsigned int));\n      memset(array59->data, 0, array59->size*sizeof(unsigned int));\n      DEBUG_NEW(array59->id);\n   }\n   return array59;\n}\n\n### File: func29.c\n#include \"array10_19.h\" \narray_t* func29(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array11;\n   if (pCounter > 0) {\n      array11 = vars->data[--pCounter];\n      array11->refC++;\n      DEBUG_COPY(array11->id);\n   } else {\n      array11 = (array_t*)malloc(sizeof(array_t));\n      array11->size = 42;\n      array11->refC = 1;\n      array11->id = 11;\n      array11->data = (unsigned int*)malloc(array11->size*sizeof(unsigned int));\n      memset(array11->data, 0, array11->size*sizeof(unsigned int));\n      DEBUG_NEW(array11->id);\n   }\n   unsigned int loop4 = 0;\n   unsigned int loopLimit4 = (rand()%loopsFactor)/4 + 1;\n   for(; loop4 < loopLimit4; loop4++) {\n      for (int i = 0; i < array11->size; i++) {\n         array11->data[i]--;\n      }\n   }\n   return array11;\n}\n\n### File: func3.c\n#include \"array10_19.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array119 = func7(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array119->id);\n   free(params0.data);\n   return array119;\n}\n\n### File: func30.c\n#include \"array10_19.h\" \narray_t* func30(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array13 = func34(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array13->id);\n   free(params0.data);\n   return array13;\n}\n\n### File: func31.c\n#include \"array10_19.h\" \narray_t* func31(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array67 = func32(&params0, loopsFactor);\n      DEBUG_RETURN(array67->id);\n      free(params0.data);\n      array67->refC--;\n      if(array67->refC == 0) {\n         free(array67->data);\n         free(array67);\n         DEBUG_FREE(array67->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array71 = func33(&params0, loopsFactor);\n      DEBUG_RETURN(array71->id);\n      free(params0.data);\n      array71->refC--;\n      if(array71->refC == 0) {\n         free(array71->data);\n         free(array71);\n         DEBUG_FREE(array71->id);\n      }\n   }\n   array_t* array85;\n   if (pCounter > 0) {\n      array85 = vars->data[--pCounter];\n      array85->refC++;\n      DEBUG_COPY(array85->id);\n   } else {\n      array85 = (array_t*)malloc(sizeof(array_t));\n      array85->size = 379;\n      array85->refC = 1;\n      array85->id = 85;\n      array85->data = (unsigned int*)malloc(array85->size*sizeof(unsigned int));\n      memset(array85->data, 0, array85->size*sizeof(unsigned int));\n      DEBUG_NEW(array85->id);\n   }\n   return array85;\n}\n\n### File: func32.c\n#include \"array10_19.h\" \narray_t* func32(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop12 = 0;\n   unsigned int loopLimit12 = (rand()%loopsFactor)/3 + 1;\n   for(; loop12 < loopLimit12; loop12++) {\n      array_t* array68;\n      if (pCounter > 0) {\n         array68 = vars->data[--pCounter];\n         array68->refC++;\n         DEBUG_COPY(array68->id);\n      } else {\n         array68 = (array_t*)malloc(sizeof(array_t));\n         array68->size = 644;\n         array68->refC = 1;\n         array68->id = 68;\n         array68->data = (unsigned int*)malloc(array68->size*sizeof(unsigned int));\n         memset(array68->data, 0, array68->size*sizeof(unsigned int));\n         DEBUG_NEW(array68->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array68;\n      array_t* array69 = func40(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array69->id);\n      free(params0.data);\n      array69->refC--;\n      if(array69->refC == 0) {\n         free(array69->data);\n         free(array69);\n         DEBUG_FREE(array69->id);\n      }\n      array68->refC--;\n      if(array68->refC == 0) {\n         free(array68->data);\n         free(array68);\n         DEBUG_FREE(array68->id);\n      }\n   }\n   array_t* array70;\n   if (pCounter > 0) {\n      array70 = vars->data[--pCounter];\n      array70->refC++;\n      DEBUG_COPY(array70->id);\n   } else {\n      array70 = (array_t*)malloc(sizeof(array_t));\n      array70->size = 139;\n      array70->refC = 1;\n      array70->id = 70;\n      array70->data = (unsigned int*)malloc(array70->size*sizeof(unsigned int));\n      memset(array70->data, 0, array70->size*sizeof(unsigned int));\n      DEBUG_NEW(array70->id);\n   }\n   return array70;\n}\n\n### File: func33.c\n#include \"array10_19.h\" \narray_t* func33(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array72 = func37(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array72->id);\n   free(params0.data);\n   return array72;\n}\n\n### File: func34.c\n#include \"array10_19.h\" \narray_t* func34(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array14 = func35(&params0, loopsFactor);\n      DEBUG_RETURN(array14->id);\n      free(params0.data);\n      array14->refC--;\n      if(array14->refC == 0) {\n         free(array14->data);\n         free(array14);\n         DEBUG_FREE(array14->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array34 = func36(&params0, loopsFactor);\n      DEBUG_RETURN(array34->id);\n      free(params0.data);\n      array34->refC--;\n      if(array34->refC == 0) {\n         free(array34->data);\n         free(array34);\n         DEBUG_FREE(array34->id);\n      }\n   }\n   array_t* array58;\n   if (pCounter > 0) {\n      array58 = vars->data[--pCounter];\n      array58->refC++;\n      DEBUG_COPY(array58->id);\n   } else {\n      array58 = (array_t*)malloc(sizeof(array_t));\n      array58->size = 29;\n      array58->refC = 1;\n      array58->id = 58;\n      array58->data = (unsigned int*)malloc(array58->size*sizeof(unsigned int));\n      memset(array58->data, 0, array58->size*sizeof(unsigned int));\n      DEBUG_NEW(array58->id);\n   }\n   return array58;\n}\n\n### File: func35.c\n#include \"array10_19.h\" \narray_t* func35(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop5 = 0;\n   unsigned int loopLimit5 = (rand()%loopsFactor)/4 + 1;\n   for(; loop5 < loopLimit5; loop5++) {\n      array_t* array15;\n      if (pCounter > 0) {\n         array15 = vars->data[--pCounter];\n         array15->refC++;\n         DEBUG_COPY(array15->id);\n      } else {\n         array15 = (array_t*)malloc(sizeof(array_t));\n         array15->size = 956;\n         array15->refC = 1;\n         array15->id = 15;\n         array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n         memset(array15->data, 0, array15->size*sizeof(unsigned int));\n         DEBUG_NEW(array15->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array15;\n      array_t* array16 = func46(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array16->id);\n      free(params0.data);\n      array16->refC--;\n      if(array16->refC == 0) {\n         free(array16->data);\n         free(array16);\n         DEBUG_FREE(array16->id);\n      }\n      array15->refC--;\n      if(array15->refC == 0) {\n         free(array15->data);\n         free(array15);\n         DEBUG_FREE(array15->id);\n      }\n   }\n   array_t* array33;\n   if (pCounter > 0) {\n      array33 = vars->data[--pCounter];\n      array33->refC++;\n      DEBUG_COPY(array33->id);\n   } else {\n      array33 = (array_t*)malloc(sizeof(array_t));\n      array33->size = 492;\n      array33->refC = 1;\n      array33->id = 33;\n      array33->data = (unsigned int*)malloc(array33->size*sizeof(unsigned int));\n      memset(array33->data, 0, array33->size*sizeof(unsigned int));\n      DEBUG_NEW(array33->id);\n   }\n   return array33;\n}\n\n### File: func36.c\n#include \"array10_19.h\" \narray_t* func36(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array35 = func40(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array35->id);\n   free(params0.data);\n   return array35;\n}\n\n### File: func37.c\n#include \"array10_19.h\" \narray_t* func37(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array73 = func38(&params0, loopsFactor);\n      DEBUG_RETURN(array73->id);\n      free(params0.data);\n      array73->refC--;\n      if(array73->refC == 0) {\n         free(array73->data);\n         free(array73);\n         DEBUG_FREE(array73->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array75 = func39(&params0, loopsFactor);\n      DEBUG_RETURN(array75->id);\n      free(params0.data);\n      array75->refC--;\n      if(array75->refC == 0) {\n         free(array75->data);\n         free(array75);\n         DEBUG_FREE(array75->id);\n      }\n   }\n   array_t* array84;\n   if (pCounter > 0) {\n      array84 = vars->data[--pCounter];\n      array84->refC++;\n      DEBUG_COPY(array84->id);\n   } else {\n      array84 = (array_t*)malloc(sizeof(array_t));\n      array84->size = 36;\n      array84->refC = 1;\n      array84->id = 84;\n      array84->data = (unsigned int*)malloc(array84->size*sizeof(unsigned int));\n      memset(array84->data, 0, array84->size*sizeof(unsigned int));\n      DEBUG_NEW(array84->id);\n   }\n   return array84;\n}\n\n### File: func38.c\n#include \"array10_19.h\" \narray_t* func38(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array74;\n   if (pCounter > 0) {\n      array74 = vars->data[--pCounter];\n      array74->refC++;\n      DEBUG_COPY(array74->id);\n   } else {\n      array74 = (array_t*)malloc(sizeof(array_t));\n      array74->size = 828;\n      array74->refC = 1;\n      array74->id = 74;\n      array74->data = (unsigned int*)malloc(array74->size*sizeof(unsigned int));\n      memset(array74->data, 0, array74->size*sizeof(unsigned int));\n      DEBUG_NEW(array74->id);\n   }\n   unsigned int loop13 = 0;\n   unsigned int loopLimit13 = (rand()%loopsFactor)/3 + 1;\n   for(; loop13 < loopLimit13; loop13++) {\n      for (int i = 0; i < array74->size; i++) {\n         array74->data[i]--;\n      }\n   }\n   return array74;\n}\n\n### File: func39.c\n#include \"array10_19.h\" \narray_t* func39(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array76 = func43(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array76->id);\n   free(params0.data);\n   return array76;\n}\n\n### File: func4.c\n#include \"array10_19.h\" \narray_t* func4(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array92 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array92->id);\n      free(params0.data);\n      array92->refC--;\n      if(array92->refC == 0) {\n         free(array92->data);\n         free(array92);\n         DEBUG_FREE(array92->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array94 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array94->id);\n      free(params0.data);\n      array94->refC--;\n      if(array94->refC == 0) {\n         free(array94->data);\n         free(array94);\n         DEBUG_FREE(array94->id);\n      }\n   }\n   array_t* array115;\n   if (pCounter > 0) {\n      array115 = vars->data[--pCounter];\n      array115->refC++;\n      DEBUG_COPY(array115->id);\n   } else {\n      array115 = (array_t*)malloc(sizeof(array_t));\n      array115->size = 336;\n      array115->refC = 1;\n      array115->id = 115;\n      array115->data = (unsigned int*)malloc(array115->size*sizeof(unsigned int));\n      memset(array115->data, 0, array115->size*sizeof(unsigned int));\n      DEBUG_NEW(array115->id);\n   }\n   return array115;\n}\n\n### File: func40.c\n#include \"array10_19.h\" \narray_t* func40(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array36 = func41(&params0, loopsFactor);\n      DEBUG_RETURN(array36->id);\n      free(params0.data);\n      array36->refC--;\n      if(array36->refC == 0) {\n         free(array36->data);\n         free(array36);\n         DEBUG_FREE(array36->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array38 = func42(&params0, loopsFactor);\n      DEBUG_RETURN(array38->id);\n      free(params0.data);\n      array38->refC--;\n      if(array38->refC == 0) {\n         free(array38->data);\n         free(array38);\n         DEBUG_FREE(array38->id);\n      }\n   }\n   array_t* array57;\n   if (pCounter > 0) {\n      array57 = vars->data[--pCounter];\n      array57->refC++;\n      DEBUG_COPY(array57->id);\n   } else {\n      array57 = (array_t*)malloc(sizeof(array_t));\n      array57->size = 121;\n      array57->refC = 1;\n      array57->id = 57;\n      array57->data = (unsigned int*)malloc(array57->size*sizeof(unsigned int));\n      memset(array57->data, 0, array57->size*sizeof(unsigned int));\n      DEBUG_NEW(array57->id);\n   }\n   return array57;\n}\n\n### File: func41.c\n#include \"array10_19.h\" \narray_t* func41(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array37;\n   if (pCounter > 0) {\n      array37 = vars->data[--pCounter];\n      array37->refC++;\n      DEBUG_COPY(array37->id);\n   } else {\n      array37 = (array_t*)malloc(sizeof(array_t));\n      array37->size = 117;\n      array37->refC = 1;\n      array37->id = 37;\n      array37->data = (unsigned int*)malloc(array37->size*sizeof(unsigned int));\n      memset(array37->data, 0, array37->size*sizeof(unsigned int));\n      DEBUG_NEW(array37->id);\n   }\n   unsigned int loop8 = 0;\n   unsigned int loopLimit8 = (rand()%loopsFactor)/4 + 1;\n   for(; loop8 < loopLimit8; loop8++) {\n      for (int i = 0; i < array37->size; i++) {\n         array37->data[i]--;\n      }\n   }\n   return array37;\n}\n\n### File: func42.c\n#include \"array10_19.h\" \narray_t* func42(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array39 = func49(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array39->id);\n   free(params0.data);\n   return array39;\n}\n\n### File: func43.c\n#include \"array10_19.h\" \narray_t* func43(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array77 = func44(&params0, loopsFactor);\n      DEBUG_RETURN(array77->id);\n      free(params0.data);\n      array77->refC--;\n      if(array77->refC == 0) {\n         free(array77->data);\n         free(array77);\n         DEBUG_FREE(array77->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array81 = func45(&params0, loopsFactor);\n      DEBUG_RETURN(array81->id);\n      free(params0.data);\n      array81->refC--;\n      if(array81->refC == 0) {\n         free(array81->data);\n         free(array81);\n         DEBUG_FREE(array81->id);\n      }\n   }\n   array_t* array83;\n   if (pCounter > 0) {\n      array83 = vars->data[--pCounter];\n      array83->refC++;\n      DEBUG_COPY(array83->id);\n   } else {\n      array83 = (array_t*)malloc(sizeof(array_t));\n      array83->size = 62;\n      array83->refC = 1;\n      array83->id = 83;\n      array83->data = (unsigned int*)malloc(array83->size*sizeof(unsigned int));\n      memset(array83->data, 0, array83->size*sizeof(unsigned int));\n      DEBUG_NEW(array83->id);\n   }\n   return array83;\n}\n\n### File: func44.c\n#include \"array10_19.h\" \narray_t* func44(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop14 = 0;\n   unsigned int loopLimit14 = (rand()%loopsFactor)/3 + 1;\n   for(; loop14 < loopLimit14; loop14++) {\n      array_t* array78;\n      if (pCounter > 0) {\n         array78 = vars->data[--pCounter];\n         array78->refC++;\n         DEBUG_COPY(array78->id);\n      } else {\n         array78 = (array_t*)malloc(sizeof(array_t));\n         array78->size = 320;\n         array78->refC = 1;\n         array78->id = 78;\n         array78->data = (unsigned int*)malloc(array78->size*sizeof(unsigned int));\n         memset(array78->data, 0, array78->size*sizeof(unsigned int));\n         DEBUG_NEW(array78->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array78;\n      array_t* array79 = func55(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array79->id);\n      free(params0.data);\n      array79->refC--;\n      if(array79->refC == 0) {\n         free(array79->data);\n         free(array79);\n         DEBUG_FREE(array79->id);\n      }\n      array78->refC--;\n      if(array78->refC == 0) {\n         free(array78->data);\n         free(array78);\n         DEBUG_FREE(array78->id);\n      }\n   }\n   array_t* array80;\n   if (pCounter > 0) {\n      array80 = vars->data[--pCounter];\n      array80->refC++;\n      DEBUG_COPY(array80->id);\n   } else {\n      array80 = (array_t*)malloc(sizeof(array_t));\n      array80->size = 626;\n      array80->refC = 1;\n      array80->id = 80;\n      array80->data = (unsigned int*)malloc(array80->size*sizeof(unsigned int));\n      memset(array80->data, 0, array80->size*sizeof(unsigned int));\n      DEBUG_NEW(array80->id);\n   }\n   return array80;\n}\n\n### File: func45.c\n#include \"array10_19.h\" \narray_t* func45(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array82 = func46(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array82->id);\n   free(params0.data);\n   return array82;\n}\n\n### File: func46.c\n#include \"array10_19.h\" \narray_t* func46(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array17 = func47(&params0, loopsFactor);\n      DEBUG_RETURN(array17->id);\n      free(params0.data);\n      array17->refC--;\n      if(array17->refC == 0) {\n         free(array17->data);\n         free(array17);\n         DEBUG_FREE(array17->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array19 = func48(&params0, loopsFactor);\n      DEBUG_RETURN(array19->id);\n      free(params0.data);\n      array19->refC--;\n      if(array19->refC == 0) {\n         free(array19->data);\n         free(array19);\n         DEBUG_FREE(array19->id);\n      }\n   }\n   array_t* array32;\n   if (pCounter > 0) {\n      array32 = vars->data[--pCounter];\n      array32->refC++;\n      DEBUG_COPY(array32->id);\n   } else {\n      array32 = (array_t*)malloc(sizeof(array_t));\n      array32->size = 902;\n      array32->refC = 1;\n      array32->id = 32;\n      array32->data = (unsigned int*)malloc(array32->size*sizeof(unsigned int));\n      memset(array32->data, 0, array32->size*sizeof(unsigned int));\n      DEBUG_NEW(array32->id);\n   }\n   return array32;\n}\n\n### File: func47.c\n#include \"array10_19.h\" \narray_t* func47(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array18;\n   if (pCounter > 0) {\n      array18 = vars->data[--pCounter];\n      array18->refC++;\n      DEBUG_COPY(array18->id);\n   } else {\n      array18 = (array_t*)malloc(sizeof(array_t));\n      array18->size = 327;\n      array18->refC = 1;\n      array18->id = 18;\n      array18->data = (unsigned int*)malloc(array18->size*sizeof(unsigned int));\n      memset(array18->data, 0, array18->size*sizeof(unsigned int));\n      DEBUG_NEW(array18->id);\n   }\n   unsigned int loop6 = 0;\n   unsigned int loopLimit6 = (rand()%loopsFactor)/5 + 1;\n   for(; loop6 < loopLimit6; loop6++) {\n      for (int i = 0; i < array18->size; i++) {\n         array18->data[i]--;\n      }\n   }\n   return array18;\n}\n\n### File: func48.c\n#include \"array10_19.h\" \narray_t* func48(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array20 = func52(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array20->id);\n   free(params0.data);\n   return array20;\n}\n\n### File: func49.c\n#include \"array10_19.h\" \narray_t* func49(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array40 = func50(&params0, loopsFactor);\n      DEBUG_RETURN(array40->id);\n      free(params0.data);\n      array40->refC--;\n      if(array40->refC == 0) {\n         free(array40->data);\n         free(array40);\n         DEBUG_FREE(array40->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array44 = func51(&params0, loopsFactor);\n      DEBUG_RETURN(array44->id);\n      free(params0.data);\n      array44->refC--;\n      if(array44->refC == 0) {\n         free(array44->data);\n         free(array44);\n         DEBUG_FREE(array44->id);\n      }\n   }\n   array_t* array56;\n   if (pCounter > 0) {\n      array56 = vars->data[--pCounter];\n      array56->refC++;\n      DEBUG_COPY(array56->id);\n   } else {\n      array56 = (array_t*)malloc(sizeof(array_t));\n      array56->size = 275;\n      array56->refC = 1;\n      array56->id = 56;\n      array56->data = (unsigned int*)malloc(array56->size*sizeof(unsigned int));\n      memset(array56->data, 0, array56->size*sizeof(unsigned int));\n      DEBUG_NEW(array56->id);\n   }\n   return array56;\n}\n\n### File: func5.c\n#include \"array10_19.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array93;\n   if (pCounter > 0) {\n      array93 = vars->data[--pCounter];\n      array93->refC++;\n      DEBUG_COPY(array93->id);\n   } else {\n      array93 = (array_t*)malloc(sizeof(array_t));\n      array93->size = 340;\n      array93->refC = 1;\n      array93->id = 93;\n      array93->data = (unsigned int*)malloc(array93->size*sizeof(unsigned int));\n      memset(array93->data, 0, array93->size*sizeof(unsigned int));\n      DEBUG_NEW(array93->id);\n   }\n   unsigned int loop15 = 0;\n   unsigned int loopLimit15 = (rand()%loopsFactor)/2 + 1;\n   for(; loop15 < loopLimit15; loop15++) {\n      for (int i = 0; i < array93->size; i++) {\n         array93->data[i]--;\n      }\n   }\n   return array93;\n}\n\n### File: func50.c\n#include \"array10_19.h\" \narray_t* func50(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop9 = 0;\n   unsigned int loopLimit9 = (rand()%loopsFactor)/4 + 1;\n   for(; loop9 < loopLimit9; loop9++) {\n      array_t* array41;\n      if (pCounter > 0) {\n         array41 = vars->data[--pCounter];\n         array41->refC++;\n         DEBUG_COPY(array41->id);\n      } else {\n         array41 = (array_t*)malloc(sizeof(array_t));\n         array41->size = 219;\n         array41->refC = 1;\n         array41->id = 41;\n         array41->data = (unsigned int*)malloc(array41->size*sizeof(unsigned int));\n         memset(array41->data, 0, array41->size*sizeof(unsigned int));\n         DEBUG_NEW(array41->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array41;\n      array_t* array42 = func58(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array42->id);\n      free(params0.data);\n      array42->refC--;\n      if(array42->refC == 0) {\n         free(array42->data);\n         free(array42);\n         DEBUG_FREE(array42->id);\n      }\n      array41->refC--;\n      if(array41->refC == 0) {\n         free(array41->data);\n         free(array41);\n         DEBUG_FREE(array41->id);\n      }\n   }\n   array_t* array43;\n   if (pCounter > 0) {\n      array43 = vars->data[--pCounter];\n      array43->refC++;\n      DEBUG_COPY(array43->id);\n   } else {\n      array43 = (array_t*)malloc(sizeof(array_t));\n      array43->size = 871;\n      array43->refC = 1;\n      array43->id = 43;\n      array43->data = (unsigned int*)malloc(array43->size*sizeof(unsigned int));\n      memset(array43->data, 0, array43->size*sizeof(unsigned int));\n      DEBUG_NEW(array43->id);\n   }\n   return array43;\n}\n\n### File: func51.c\n#include \"array10_19.h\" \narray_t* func51(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array45 = func55(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array45->id);\n   free(params0.data);\n   return array45;\n}\n\n### File: func52.c\n#include \"array10_19.h\" \narray_t* func52(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array21 = func53(&params0, loopsFactor);\n      DEBUG_RETURN(array21->id);\n      free(params0.data);\n      array21->refC--;\n      if(array21->refC == 0) {\n         free(array21->data);\n         free(array21);\n         DEBUG_FREE(array21->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array24 = func54(&params0, loopsFactor);\n      DEBUG_RETURN(array24->id);\n      free(params0.data);\n      array24->refC--;\n      if(array24->refC == 0) {\n         free(array24->data);\n         free(array24);\n         DEBUG_FREE(array24->id);\n      }\n   }\n   array_t* array31;\n   if (pCounter > 0) {\n      array31 = vars->data[--pCounter];\n      array31->refC++;\n      DEBUG_COPY(array31->id);\n   } else {\n      array31 = (array_t*)malloc(sizeof(array_t));\n      array31->size = 467;\n      array31->refC = 1;\n      array31->id = 31;\n      array31->data = (unsigned int*)malloc(array31->size*sizeof(unsigned int));\n      memset(array31->data, 0, array31->size*sizeof(unsigned int));\n      DEBUG_NEW(array31->id);\n   }\n   return array31;\n}\n\n### File: func53.c\n#include \"array10_19.h\" \narray_t* func53(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop7 = 0;\n   unsigned int loopLimit7 = (rand()%loopsFactor)/5 + 1;\n   for(; loop7 < loopLimit7; loop7++) {\n      array_t* array22;\n      if (pCounter > 0) {\n         array22 = vars->data[--pCounter];\n         array22->refC++;\n         DEBUG_COPY(array22->id);\n      } else {\n         array22 = (array_t*)malloc(sizeof(array_t));\n         array22->size = 43;\n         array22->refC = 1;\n         array22->id = 22;\n         array22->data = (unsigned int*)malloc(array22->size*sizeof(unsigned int));\n         memset(array22->data, 0, array22->size*sizeof(unsigned int));\n         DEBUG_NEW(array22->id);\n      }\n      array22->refC--;\n      if(array22->refC == 0) {\n         free(array22->data);\n         free(array22);\n         DEBUG_FREE(array22->id);\n      }\n   }\n   array_t* array23;\n   if (pCounter > 0) {\n      array23 = vars->data[--pCounter];\n      array23->refC++;\n      DEBUG_COPY(array23->id);\n   } else {\n      array23 = (array_t*)malloc(sizeof(array_t));\n      array23->size = 750;\n      array23->refC = 1;\n      array23->id = 23;\n      array23->data = (unsigned int*)malloc(array23->size*sizeof(unsigned int));\n      memset(array23->data, 0, array23->size*sizeof(unsigned int));\n      DEBUG_NEW(array23->id);\n   }\n   return array23;\n}\n\n### File: func54.c\n#include \"array10_19.h\" \narray_t* func54(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array25 = func58(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array25->id);\n   free(params0.data);\n   return array25;\n}\n\n### File: func55.c\n#include \"array10_19.h\" \narray_t* func55(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array46 = func56(&params0, loopsFactor);\n      DEBUG_RETURN(array46->id);\n      free(params0.data);\n      array46->refC--;\n      if(array46->refC == 0) {\n         free(array46->data);\n         free(array46);\n         DEBUG_FREE(array46->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array48 = func57(&params0, loopsFactor);\n      DEBUG_RETURN(array48->id);\n      free(params0.data);\n      array48->refC--;\n      if(array48->refC == 0) {\n         free(array48->data);\n         free(array48);\n         DEBUG_FREE(array48->id);\n      }\n   }\n   array_t* array55;\n   if (pCounter > 0) {\n      array55 = vars->data[--pCounter];\n      array55->refC++;\n      DEBUG_COPY(array55->id);\n   } else {\n      array55 = (array_t*)malloc(sizeof(array_t));\n      array55->size = 551;\n      array55->refC = 1;\n      array55->id = 55;\n      array55->data = (unsigned int*)malloc(array55->size*sizeof(unsigned int));\n      memset(array55->data, 0, array55->size*sizeof(unsigned int));\n      DEBUG_NEW(array55->id);\n   }\n   return array55;\n}\n\n### File: func56.c\n#include \"array10_19.h\" \narray_t* func56(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array47;\n   if (pCounter > 0) {\n      array47 = vars->data[--pCounter];\n      array47->refC++;\n      DEBUG_COPY(array47->id);\n   } else {\n      array47 = (array_t*)malloc(sizeof(array_t));\n      array47->size = 245;\n      array47->refC = 1;\n      array47->id = 47;\n      array47->data = (unsigned int*)malloc(array47->size*sizeof(unsigned int));\n      memset(array47->data, 0, array47->size*sizeof(unsigned int));\n      DEBUG_NEW(array47->id);\n   }\n   unsigned int loop10 = 0;\n   unsigned int loopLimit10 = (rand()%loopsFactor)/4 + 1;\n   for(; loop10 < loopLimit10; loop10++) {\n      for (int i = 0; i < array47->size; i++) {\n         array47->data[i]--;\n      }\n   }\n   return array47;\n}\n\n### File: func57.c\n#include \"array10_19.h\" \narray_t* func57(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array49 = func61(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array49->id);\n   free(params0.data);\n   return array49;\n}\n\n### File: func58.c\n#include \"array10_19.h\" \narray_t* func58(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array26 = func59(&params0, loopsFactor);\n      DEBUG_RETURN(array26->id);\n      free(params0.data);\n      array26->refC--;\n      if(array26->refC == 0) {\n         free(array26->data);\n         free(array26);\n         DEBUG_FREE(array26->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array28 = func60(&params0, loopsFactor);\n      DEBUG_RETURN(array28->id);\n      free(params0.data);\n      array28->refC--;\n      if(array28->refC == 0) {\n         free(array28->data);\n         free(array28);\n         DEBUG_FREE(array28->id);\n      }\n   }\n   array_t* array30;\n   if (pCounter > 0) {\n      array30 = vars->data[--pCounter];\n      array30->refC++;\n      DEBUG_COPY(array30->id);\n   } else {\n      array30 = (array_t*)malloc(sizeof(array_t));\n      array30->size = 570;\n      array30->refC = 1;\n      array30->id = 30;\n      array30->data = (unsigned int*)malloc(array30->size*sizeof(unsigned int));\n      memset(array30->data, 0, array30->size*sizeof(unsigned int));\n      DEBUG_NEW(array30->id);\n   }\n   return array30;\n}\n\n### File: func59.c\n#include \"array10_19.h\" \narray_t* func59(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array27;\n   if (pCounter > 0) {\n      array27 = vars->data[--pCounter];\n      array27->refC++;\n      DEBUG_COPY(array27->id);\n   } else {\n      array27 = (array_t*)malloc(sizeof(array_t));\n      array27->size = 368;\n      array27->refC = 1;\n      array27->id = 27;\n      array27->data = (unsigned int*)malloc(array27->size*sizeof(unsigned int));\n      memset(array27->data, 0, array27->size*sizeof(unsigned int));\n      DEBUG_NEW(array27->id);\n   }\n   return array27;\n}\n\n### File: func6.c\n#include \"array10_19.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array95 = func13(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array95->id);\n   free(params0.data);\n   return array95;\n}\n\n### File: func60.c\n#include \"array10_19.h\" \narray_t* func60(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array29;\n   if (pCounter > 0) {\n      array29 = vars->data[--pCounter];\n      array29->refC++;\n      DEBUG_COPY(array29->id);\n   } else {\n      array29 = (array_t*)malloc(sizeof(array_t));\n      array29->size = 539;\n      array29->refC = 1;\n      array29->id = 29;\n      array29->data = (unsigned int*)malloc(array29->size*sizeof(unsigned int));\n      memset(array29->data, 0, array29->size*sizeof(unsigned int));\n      DEBUG_NEW(array29->id);\n   }\n   return array29;\n}\n\n### File: func61.c\n#include \"array10_19.h\" \narray_t* func61(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array50 = func62(&params0, loopsFactor);\n      DEBUG_RETURN(array50->id);\n      free(params0.data);\n      array50->refC--;\n      if(array50->refC == 0) {\n         free(array50->data);\n         free(array50);\n         DEBUG_FREE(array50->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array52 = func63(&params0, loopsFactor);\n      DEBUG_RETURN(array52->id);\n      free(params0.data);\n      array52->refC--;\n      if(array52->refC == 0) {\n         free(array52->data);\n         free(array52);\n         DEBUG_FREE(array52->id);\n      }\n   }\n   array_t* array54;\n   if (pCounter > 0) {\n      array54 = vars->data[--pCounter];\n      array54->refC++;\n      DEBUG_COPY(array54->id);\n   } else {\n      array54 = (array_t*)malloc(sizeof(array_t));\n      array54->size = 859;\n      array54->refC = 1;\n      array54->id = 54;\n      array54->data = (unsigned int*)malloc(array54->size*sizeof(unsigned int));\n      memset(array54->data, 0, array54->size*sizeof(unsigned int));\n      DEBUG_NEW(array54->id);\n   }\n   return array54;\n}\n\n### File: func62.c\n#include \"array10_19.h\" \narray_t* func62(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array51;\n   if (pCounter > 0) {\n      array51 = vars->data[--pCounter];\n      array51->refC++;\n      DEBUG_COPY(array51->id);\n   } else {\n      array51 = (array_t*)malloc(sizeof(array_t));\n      array51->size = 124;\n      array51->refC = 1;\n      array51->id = 51;\n      array51->data = (unsigned int*)malloc(array51->size*sizeof(unsigned int));\n      memset(array51->data, 0, array51->size*sizeof(unsigned int));\n      DEBUG_NEW(array51->id);\n   }\n   return array51;\n}\n\n### File: func63.c\n#include \"array10_19.h\" \narray_t* func63(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array53;\n   if (pCounter > 0) {\n      array53 = vars->data[--pCounter];\n      array53->refC++;\n      DEBUG_COPY(array53->id);\n   } else {\n      array53 = (array_t*)malloc(sizeof(array_t));\n      array53->size = 227;\n      array53->refC = 1;\n      array53->id = 53;\n      array53->data = (unsigned int*)malloc(array53->size*sizeof(unsigned int));\n      memset(array53->data, 0, array53->size*sizeof(unsigned int));\n      DEBUG_NEW(array53->id);\n   }\n   return array53;\n}\n\n### File: func7.c\n#include \"array10_19.h\" \narray_t* func7(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array120 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array120->id);\n      free(params0.data);\n      array120->refC--;\n      if(array120->refC == 0) {\n         free(array120->data);\n         free(array120);\n         DEBUG_FREE(array120->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array124 = func9(&params0, loopsFactor);\n      DEBUG_RETURN(array124->id);\n      free(params0.data);\n      array124->refC--;\n      if(array124->refC == 0) {\n         free(array124->data);\n         free(array124);\n         DEBUG_FREE(array124->id);\n      }\n   }\n   array_t* array126;\n   if (pCounter > 0) {\n      array126 = vars->data[--pCounter];\n      array126->refC++;\n      DEBUG_COPY(array126->id);\n   } else {\n      array126 = (array_t*)malloc(sizeof(array_t));\n      array126->size = 189;\n      array126->refC = 1;\n      array126->id = 126;\n      array126->data = (unsigned int*)malloc(array126->size*sizeof(unsigned int));\n      memset(array126->data, 0, array126->size*sizeof(unsigned int));\n      DEBUG_NEW(array126->id);\n   }\n   return array126;\n}\n\n### File: func8.c\n#include \"array10_19.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop20 = 0;\n   unsigned int loopLimit20 = (rand()%loopsFactor)/2 + 1;\n   for(; loop20 < loopLimit20; loop20++) {\n      array_t* array121;\n      if (pCounter > 0) {\n         array121 = vars->data[--pCounter];\n         array121->refC++;\n         DEBUG_COPY(array121->id);\n      } else {\n         array121 = (array_t*)malloc(sizeof(array_t));\n         array121->size = 754;\n         array121->refC = 1;\n         array121->id = 121;\n         array121->data = (unsigned int*)malloc(array121->size*sizeof(unsigned int));\n         memset(array121->data, 0, array121->size*sizeof(unsigned int));\n         DEBUG_NEW(array121->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array121;\n      array_t* array122 = func19(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array122->id);\n      free(params0.data);\n      array122->refC--;\n      if(array122->refC == 0) {\n         free(array122->data);\n         free(array122);\n         DEBUG_FREE(array122->id);\n      }\n      array121->refC--;\n      if(array121->refC == 0) {\n         free(array121->data);\n         free(array121);\n         DEBUG_FREE(array121->id);\n      }\n   }\n   array_t* array123;\n   if (pCounter > 0) {\n      array123 = vars->data[--pCounter];\n      array123->refC++;\n      DEBUG_COPY(array123->id);\n   } else {\n      array123 = (array_t*)malloc(sizeof(array_t));\n      array123->size = 944;\n      array123->refC = 1;\n      array123->id = 123;\n      array123->data = (unsigned int*)malloc(array123->size*sizeof(unsigned int));\n      memset(array123->data, 0, array123->size*sizeof(unsigned int));\n      DEBUG_NEW(array123->id);\n   }\n   return array123;\n}\n\n### File: func9.c\n#include \"array10_19.h\" \narray_t* func9(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array125 = func10(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array125->id);\n   free(params0.data);\n   return array125;\n}\n\n### File: rng.c\n#include \"array10_19.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2900876\n    - Instructions: 1973859\n    - Cache References: 103269\n    - Cache Misses: 34961\n    - Branch Instructions: 375110\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array6_13.c\n#include \"array6_13.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array0;\n      array0 = (array_t*)malloc(sizeof(array_t));\n      array0->size = 777;\n      array0->refC = 1;\n         array0->id = 0;\n      array0->data = (unsigned int*)malloc(array0->size*sizeof(unsigned int));\n      memset(array0->data, 0, array0->size*sizeof(unsigned int));\n      DEBUG_NEW(array0->id);\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array0;\n      array_t* array1 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array1->id);\n      free(params0.data);\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array6_13.h\n#ifndef array6_13\n#define array6_13\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array6_13.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n   }\n   array_t* array2;\n   if (pCounter > 0) {\n      array2 = vars->data[--pCounter];\n      array2->refC++;\n      DEBUG_COPY(array2->id);\n   } else {\n      array2 = (array_t*)malloc(sizeof(array_t));\n      array2->size = 492;\n      array2->refC = 1;\n      array2->id = 2;\n      array2->data = (unsigned int*)malloc(array2->size*sizeof(unsigned int));\n      memset(array2->data, 0, array2->size*sizeof(unsigned int));\n      DEBUG_NEW(array2->id);\n   }\n   return array2;\n}\n\n### File: rng.c\n#include \"array6_13.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1574880\n    - Instructions: 1170402\n    - Cache References: 84661\n    - Cache Misses: 22175\n    - Branch Instructions: 216545\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist13_11.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist13_11.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist13_11.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist13_11.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist13_11.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist13_11.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist13_11.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist13_11.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist13_11.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist13_11.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist13_11.c\n#include \"sortedlist13_11.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist16 = func2(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params0.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell8 = sortedlist16->root;\n        cell_t* tmp8  = NULL;\n        while(cell8 != NULL) {\n            tmp8 = cell8->next;\n            free(cell8);\n            cell8 = tmp8;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   return 0;\n}\n\n### File: sortedlist13_11.h\n#ifndef sortedlist13_11\n#define sortedlist13_11\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 9381110\n    - Instructions: 19633881\n    - Cache References: 92140\n    - Cache Misses: 21906\n    - Branch Instructions: 3780917\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array10_18.c\n#include \"array10_18.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(array9->id);\n         free(params0.data);\n         array9->refC--;\n         if(array9->refC == 0) {\n            free(array9->data);\n            free(array9);\n            DEBUG_FREE(array9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array10_18.h\n#ifndef array10_18\n#define array10_18\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array10_18.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array10_18.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array10_18.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array10_18.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array10_18.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array10_18.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array10_18.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array10_18.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array10_18.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1664677\n    - Instructions: 1394319\n    - Cache References: 69597\n    - Cache Misses: 17063\n    - Branch Instructions: 263126\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist9_17.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist9_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist9_17.c\n#include \"sortedlist9_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist9_17.h\n#ifndef sortedlist9_17\n#define sortedlist9_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 14912386\n    - Instructions: 33082554\n    - Cache References: 101686\n    - Cache Misses: 24229\n    - Branch Instructions: 6363069\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist10_6.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist10_6.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist10_6.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist10_6.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist10_6.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist10_6.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist10_6.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist10_6.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist10_6.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist10_6.c\n#include \"sortedlist10_6.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            sortedlist_t_param params0;\n            params0.size = 0;\n            params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n            sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n            DEBUG_RETURN(sortedlist9->id);\n            free(params0.data);\n            sortedlist9->refC--;\n            if(sortedlist9->refC == 0){\n                 cell_t* cell7 = sortedlist9->root;\n                 cell_t* tmp7  = NULL;\n                 while(cell7 != NULL) {\n                     tmp7 = cell7->next;\n                     free(cell7);\n                     cell7 = tmp7;\n                 }\n                 free(sortedlist9);\n                 DEBUG_FREE(sortedlist9->id);\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist10_6.h\n#ifndef sortedlist10_6\n#define sortedlist10_6\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2327419\n    - Instructions: 2909100\n    - Cache References: 75921\n    - Cache Misses: 29416\n    - Branch Instructions: 552537\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array8_4.c\n#include \"array8_4.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      unsigned int loop0 = 0;\n      unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n      for(; loop0 < loopLimit0; loop0++) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n   }\n   else {\n      unsigned int loop2 = 0;\n      unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n      for(; loop2 < loopLimit2; loop2++) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(array9->id);\n         free(params0.data);\n         array9->refC--;\n         if(array9->refC == 0) {\n            free(array9->data);\n            free(array9);\n            DEBUG_FREE(array9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: array8_4.h\n#ifndef array8_4\n#define array8_4\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array8_4.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array8_4.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array8_4.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array8_4.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array8_4.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array8_4.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array8_4.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array8_4.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array8_4.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1696700\n    - Instructions: 1411464\n    - Cache References: 83601\n    - Cache Misses: 25575\n    - Branch Instructions: 265571\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist11_17.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0) {\n           cell_t* cell0 = sortedlist1->root;\n           if(sortedlist1->n == 0) {\n               sortedlist1->root = (cell_t*)malloc(sizeof(cell_t));\n               sortedlist1->root->val  = 86;\n               sortedlist1->root->next = NULL;\n               sortedlist1->n++;\n           } else {\n               while(cell0 != NULL)\n               {\n                   if(cell0->next == NULL && cell0->val < 86) {\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = NULL;\n                       cell0->next->val  = 86;\n                       sortedlist1->n++;\n                       break;\n                   } else if(86 < cell0->val) {\n                       cell_t* tmp0 = cell0->next;\n                       cell0->next = (cell_t*)malloc(sizeof(cell_t));\n                       cell0->next->next = tmp0;\n                       int tmp_val0 = cell0->val;\n                       cell0->val = 86;\n                       cell0->next->val = tmp_val0;\n                       sortedlist1->n++;\n                       break;\n                   }\n                   cell0 = cell0->next;\n               }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist11_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist11_17.c\n#include \"sortedlist11_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist11_17.h\n#ifndef sortedlist11_17\n#define sortedlist11_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 8531905\n    - Instructions: 15274347\n    - Cache References: 119772\n    - Cache Misses: 42130\n    - Branch Instructions: 3016480\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist11_1.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist1 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist1->id);\n      free(params0.data);\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell1 = sortedlist1->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist3;\n   if (pCounter > 0) {\n      sortedlist3 = vars->data[--pCounter];\n      sortedlist3->refC++;\n      DEBUG_COPY(sortedlist3->id);\n   } else {\n      sortedlist3 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist3->refC = 1;\n      sortedlist3->id = 3;\n      sortedlist3->n = 0;\n      sortedlist3->root = NULL;\n      DEBUG_NEW(sortedlist3->id);\n   }\n   return sortedlist3;\n}\n\n### File: func1.c\n#include \"sortedlist11_1.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist2 != NULL && sortedlist2->n > 0)\n      {\n          cell_t* cell0 = sortedlist2->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist2->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist2->n--;\n              }\n           }\n      }\n   }\n   return sortedlist2;\n}\n\n### File: rng.c\n#include \"sortedlist11_1.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist11_1.c\n#include \"sortedlist11_1.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist11_1.h\n#ifndef sortedlist11_1\n#define sortedlist11_1\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1533577\n    - Instructions: 1121836\n    - Cache References: 71472\n    - Cache Misses: 26281\n    - Branch Instructions: 208192\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist10_11.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist10_11.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist10_11.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist10_11.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist10_11.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist10_11.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist10_11.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist10_11.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist10_11.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist10_11.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist10_11.c\n#include \"sortedlist10_11.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist16 = func2(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params0.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell8 = sortedlist16->root;\n        cell_t* tmp8  = NULL;\n        while(cell8 != NULL) {\n            tmp8 = cell8->next;\n            free(cell8);\n            cell8 = tmp8;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   return 0;\n}\n\n### File: sortedlist10_11.h\n#ifndef sortedlist10_11\n#define sortedlist10_11\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1568714\n    - Instructions: 1154065\n    - Cache References: 74126\n    - Cache Misses: 21166\n    - Branch Instructions: 213180\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array6_11.c\n#include \"array6_11.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array16 = func2(&params0, loopsFactor);\n   DEBUG_RETURN(array16->id);\n   free(params0.data);\n   array16->refC--;\n   if(array16->refC == 0) {\n      free(array16->data);\n      free(array16);\n      DEBUG_FREE(array16->id);\n   }\n   return 0;\n}\n\n### File: array6_11.h\n#ifndef array6_11\n#define array6_11\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func8(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array6_11.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array6_11.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array6_11.h\" \narray_t* func2(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array17;\n   if (pCounter > 0) {\n      array17 = vars->data[--pCounter];\n      array17->refC++;\n      DEBUG_COPY(array17->id);\n   } else {\n      array17 = (array_t*)malloc(sizeof(array_t));\n      array17->size = 956;\n      array17->refC = 1;\n      array17->id = 17;\n      array17->data = (unsigned int*)malloc(array17->size*sizeof(unsigned int));\n      memset(array17->data, 0, array17->size*sizeof(unsigned int));\n      DEBUG_NEW(array17->id);\n   }\n   return array17;\n}\n\n### File: func3.c\n#include \"array6_11.h\" \narray_t* func3(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func4.c\n#include \"array6_11.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func5.c\n#include \"array6_11.h\" \narray_t* func5(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func6.c\n#include \"array6_11.h\" \narray_t* func6(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func7.c\n#include \"array6_11.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func8.c\n#include \"array6_11.h\" \narray_t* func8(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array6_11.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1833047\n    - Instructions: 1695088\n    - Cache References: 72327\n    - Cache Misses: 27712\n    - Branch Instructions: 323324\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist1_9.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist1_9.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist1_9.c\n#include \"sortedlist1_9.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell1 = sortedlist0->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist1_9.h\n#ifndef sortedlist1_9\n#define sortedlist1_9\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 10181454\n    - Instructions: 13920482\n    - Cache References: 125258\n    - Cache Misses: 48105\n    - Branch Instructions: 2082649\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array10_10.c\n#include \"array10_10.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array10_10.h\n#ifndef array10_10\n#define array10_10\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array10_10.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array10_10.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1600472\n    - Instructions: 1125027\n    - Cache References: 71402\n    - Cache Misses: 19608\n    - Branch Instructions: 208316\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array2_2.c\n#include \"array2_2.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   return 0;\n}\n\n### File: array2_2.h\n#ifndef array2_2\n#define array2_2\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array2_2.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array2_2.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array2_2.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array2_2.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array2_2.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array2_2.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array2_2.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array2_2.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array2_2.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1583136\n    - Instructions: 1132858\n    - Cache References: 78957\n    - Cache Misses: 22803\n    - Branch Instructions: 209905\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist15_8.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist15_8.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist15_8.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist15_8.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist15_8.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist15_8.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist15_8.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist15_8.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist15_8.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist15_8.c\n#include \"sortedlist15_8.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist15_8.h\n#ifndef sortedlist15_8\n#define sortedlist15_8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7491617\n    - Instructions: 14347248\n    - Cache References: 80359\n    - Cache Misses: 22671\n    - Branch Instructions: 2142846\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array8_3.c\n#include \"array8_3.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array8_3.h\n#ifndef array8_3\n#define array8_3\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array8_3.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array8_3.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1559664\n    - Instructions: 1131135\n    - Cache References: 77951\n    - Cache Misses: 20370\n    - Branch Instructions: 209020\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist14_8.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist14_8.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist14_8.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist14_8.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist14_8.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist14_8.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist14_8.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist14_8.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist14_8.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist14_8.c\n#include \"sortedlist14_8.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell4 = sortedlist0->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist9->id);\n      free(params0.data);\n      sortedlist9->refC--;\n      if(sortedlist9->refC == 0){\n           cell_t* cell7 = sortedlist9->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist9);\n           DEBUG_FREE(sortedlist9->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist14_8.h\n#ifndef sortedlist14_8\n#define sortedlist14_8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2984069\n    - Instructions: 2248731\n    - Cache References: 90785\n    - Cache Misses: 26947\n    - Branch Instructions: 427110\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist10_5.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func6(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell3 = sortedlist2->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell4 = sortedlist1->root;\n           cell_t* tmp4  = NULL;\n           while(cell4 != NULL) {\n               tmp4 = cell4->next;\n               free(cell4);\n               cell4 = tmp4;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist10_5.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func3(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist10_5.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist17;\n   if (pCounter > 0) {\n      sortedlist17 = vars->data[--pCounter];\n      sortedlist17->refC++;\n      DEBUG_COPY(sortedlist17->id);\n   } else {\n      sortedlist17 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist17->refC = 1;\n      sortedlist17->id = 17;\n      sortedlist17->n = 0;\n      sortedlist17->root = NULL;\n      DEBUG_NEW(sortedlist17->id);\n   }\n   unsigned int loop3 = 0;\n   unsigned int loopLimit3 = (rand()%loopsFactor)/1 + 1;\n   for(; loop3 < loopLimit3; loop3++) {\n      if(sortedlist17 != NULL && sortedlist17->n > 0)\n      {\n          cell_t* cell8 = sortedlist17->root;\n          if(cell8->val == 59)\n          {\n              cell8 = cell8->next;\n              sortedlist17->n--;\n          }else{\n              while(cell8->next != NULL && cell8->next->val != 59) cell8 = cell8->next;\n              if(cell8->next != NULL)\n              {\n                  cell8 = cell8->next->next;\n                  sortedlist17->n--;\n              }\n           }\n      }\n   }\n   return sortedlist17;\n}\n\n### File: func3.c\n#include \"sortedlist10_5.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell6 = sortedlist11->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func5(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell7 = sortedlist13->root;\n           cell_t* tmp7  = NULL;\n           while(cell7 != NULL) {\n               tmp7 = cell7->next;\n               free(cell7);\n               cell7 = tmp7;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func4.c\n#include \"sortedlist10_5.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist12 != NULL && sortedlist12->n > 0)\n      {\n          cell_t* cell5 = sortedlist12->root;\n          if(cell5->val == 92)\n          {\n              cell5 = cell5->next;\n              sortedlist12->n--;\n          }else{\n              while(cell5->next != NULL && cell5->next->val != 92) cell5 = cell5->next;\n              if(cell5->next != NULL)\n              {\n                  cell5 = cell5->next->next;\n                  sortedlist12->n--;\n              }\n           }\n      }\n   }\n   return sortedlist12;\n}\n\n### File: func5.c\n#include \"sortedlist10_5.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func6.c\n#include \"sortedlist10_5.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell1 = sortedlist3->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func8(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell2 = sortedlist5->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func7.c\n#include \"sortedlist10_5.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist4 != NULL && sortedlist4->n > 0)\n      {\n          cell_t* cell0 = sortedlist4->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist4->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist4->n--;\n              }\n           }\n      }\n   }\n   return sortedlist4;\n}\n\n### File: func8.c\n#include \"sortedlist10_5.h\" \nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist10_5.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist10_5.c\n#include \"sortedlist10_5.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n   DEBUG_RETURN(sortedlist0->id);\n   free(params0.data);\n   sortedlist_t_param params1;\n   params1.size = 1;\n   params1.data = (sortedlist_t**)malloc(params1.size*sizeof(sortedlist_t*));\n   params1.data[0] = sortedlist0;\n   sortedlist_t* sortedlist9 = func1(&params1, loopsFactor);\n   DEBUG_RETURN(sortedlist9->id);\n   free(params1.data);\n   sortedlist_t_param params2;\n   params2.size = 2;\n   params2.data = (sortedlist_t**)malloc(params2.size*sizeof(sortedlist_t*));\n   params2.data[0] = sortedlist0;\n   params2.data[1] = sortedlist9;\n   sortedlist_t* sortedlist16 = func2(&params2, loopsFactor);\n   DEBUG_RETURN(sortedlist16->id);\n   free(params2.data);\n   sortedlist16->refC--;\n   if(sortedlist16->refC == 0){\n        cell_t* cell9 = sortedlist16->root;\n        cell_t* tmp9  = NULL;\n        while(cell9 != NULL) {\n            tmp9 = cell9->next;\n            free(cell9);\n            cell9 = tmp9;\n        }\n        free(sortedlist16);\n        DEBUG_FREE(sortedlist16->id);\n   }\n   sortedlist9->refC--;\n   if(sortedlist9->refC == 0){\n        cell_t* cell10 = sortedlist9->root;\n        cell_t* tmp10  = NULL;\n        while(cell10 != NULL) {\n            tmp10 = cell10->next;\n            free(cell10);\n            cell10 = tmp10;\n        }\n        free(sortedlist9);\n        DEBUG_FREE(sortedlist9->id);\n   }\n   sortedlist0->refC--;\n   if(sortedlist0->refC == 0){\n        cell_t* cell11 = sortedlist0->root;\n        cell_t* tmp11  = NULL;\n        while(cell11 != NULL) {\n            tmp11 = cell11->next;\n            free(cell11);\n            cell11 = tmp11;\n        }\n        free(sortedlist0);\n        DEBUG_FREE(sortedlist0->id);\n   }\n   return 0;\n}\n\n### File: sortedlist10_5.h\n#ifndef sortedlist10_5\n#define sortedlist10_5\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func8(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 9524598\n    - Instructions: 16586432\n    - Cache References: 118889\n    - Cache Misses: 39215\n    - Branch Instructions: 2562226\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array11_15.c\n#include \"array11_15.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array_t_param params1;\n      params1.size = 1;\n      params1.data = (array_t**)malloc(params1.size*sizeof(array_t*));\n      params1.data[0] = array0;\n      array_t* array2 = func1(&params1, loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params1.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array11_15.h\n#ifndef array11_15\n#define array11_15\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array11_15.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: func1.c\n#include \"array11_15.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array3 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array3->id);\n   free(params0.data);\n   return array3;\n}\n\n### File: func2.c\n#include \"array11_15.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array4 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array4->id);\n      free(params0.data);\n      array4->refC--;\n      if(array4->refC == 0) {\n         free(array4->data);\n         free(array4);\n         DEBUG_FREE(array4->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array6 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array6->id);\n      free(params0.data);\n      array6->refC--;\n      if(array6->refC == 0) {\n         free(array6->data);\n         free(array6);\n         DEBUG_FREE(array6->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 929;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func3.c\n#include \"array11_15.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array5;\n   if (pCounter > 0) {\n      array5 = vars->data[--pCounter];\n      array5->refC++;\n      DEBUG_COPY(array5->id);\n   } else {\n      array5 = (array_t*)malloc(sizeof(array_t));\n      array5->size = 567;\n      array5->refC = 1;\n      array5->id = 5;\n      array5->data = (unsigned int*)malloc(array5->size*sizeof(unsigned int));\n      memset(array5->data, 0, array5->size*sizeof(unsigned int));\n      DEBUG_NEW(array5->id);\n   }\n   return array5;\n}\n\n### File: func4.c\n#include \"array11_15.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 67;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: rng.c\n#include \"array11_15.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 4824128\n    - Instructions: 6845907\n    - Cache References: 92041\n    - Cache Misses: 31233\n    - Branch Instructions: 1050436\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array7_17.c\n#include \"array7_17.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         array_t_param params0;\n         params0.size = 0;\n         params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n         array_t* array0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(array0->id);\n         free(params0.data);\n         array0->refC--;\n         if(array0->refC == 0) {\n            free(array0->data);\n            free(array0);\n            DEBUG_FREE(array0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: array7_17.h\n#ifndef array7_17\n#define array7_17\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array7_17.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]++;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array7_17.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7673788\n    - Instructions: 14357504\n    - Cache References: 87785\n    - Cache Misses: 28796\n    - Branch Instructions: 2144250\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array6_14.c\n#include \"array6_14.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array6_14.h\n#ifndef array6_14\n#define array6_14\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array6_14.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array6_14.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1784069\n    - Instructions: 1175442\n    - Cache References: 88022\n    - Cache Misses: 30703\n    - Branch Instructions: 216306\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array1_8.c\n#include \"array1_8.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   return 0;\n}\n\n### File: array1_8.h\n#ifndef array1_8\n#define array1_8\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array1_8.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array2;\n   if (pCounter > 0) {\n      array2 = vars->data[--pCounter];\n      array2->refC++;\n      DEBUG_COPY(array2->id);\n   } else {\n      array2 = (array_t*)malloc(sizeof(array_t));\n      array2->size = 492;\n      array2->refC = 1;\n      array2->id = 2;\n      array2->data = (unsigned int*)malloc(array2->size*sizeof(unsigned int));\n      memset(array2->data, 0, array2->size*sizeof(unsigned int));\n      DEBUG_NEW(array2->id);\n   }\n   return array2;\n}\n\n### File: func1.c\n#include \"array1_8.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array4 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array4->id);\n   free(params0.data);\n   return array4;\n}\n\n### File: func2.c\n#include \"array1_8.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array7 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array7->id);\n      free(params0.data);\n      array7->refC--;\n      if(array7->refC == 0) {\n         free(array7->data);\n         free(array7);\n         DEBUG_FREE(array7->id);\n      }\n   }\n   array_t* array9;\n   if (pCounter > 0) {\n      array9 = vars->data[--pCounter];\n      array9->refC++;\n      DEBUG_COPY(array9->id);\n   } else {\n      array9 = (array_t*)malloc(sizeof(array_t));\n      array9->size = 135;\n      array9->refC = 1;\n      array9->id = 9;\n      array9->data = (unsigned int*)malloc(array9->size*sizeof(unsigned int));\n      memset(array9->data, 0, array9->size*sizeof(unsigned int));\n      DEBUG_NEW(array9->id);\n   }\n   return array9;\n}\n\n### File: func3.c\n#include \"array1_8.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: func4.c\n#include \"array1_8.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 123;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: rng.c\n#include \"array1_8.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1537265\n    - Instructions: 1126444\n    - Cache References: 62742\n    - Cache Misses: 18129\n    - Branch Instructions: 208006\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array5_2.c\n#include \"array5_2.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   return 0;\n}\n\n### File: array5_2.h\n#ifndef array5_2\n#define array5_2\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array5_2.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array5_2.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array5_2.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array5_2.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array5_2.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array5_2.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array5_2.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array5_2.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array5_2.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 7476369\n    - Instructions: 13898439\n    - Cache References: 87558\n    - Cache Misses: 27597\n    - Branch Instructions: 2078747\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array3_9.c\n#include \"array3_9.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array3_9.h\n#ifndef array3_9\n#define array3_9\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array3_9.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array3_9.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 9185639\n    - Instructions: 13943061\n    - Cache References: 104974\n    - Cache Misses: 30923\n    - Branch Instructions: 2086480\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array11_12.c\n#include \"array11_12.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array11_12.h\n#ifndef array11_12\n#define array11_12\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array11_12.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array11_12.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 2143878\n    - Instructions: 2365586\n    - Cache References: 72504\n    - Cache Misses: 17895\n    - Branch Instructions: 448097\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist2_4.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist2_4.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist2_4.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist2_4.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist2_4.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist2_4.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist2_4.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist2_4.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist2_4.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist2_4.c\n#include \"sortedlist2_4.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      unsigned int loop0 = 0;\n      unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n      for(; loop0 < loopLimit0; loop0++) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n   }\n   else {\n      unsigned int loop2 = 0;\n      unsigned int loopLimit2 = (rand()%loopsFactor)/1 + 1;\n      for(; loop2 < loopLimit2; loop2++) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist9->id);\n         free(params0.data);\n         sortedlist9->refC--;\n         if(sortedlist9->refC == 0){\n              cell_t* cell7 = sortedlist9->root;\n              cell_t* tmp7  = NULL;\n              while(cell7 != NULL) {\n                  tmp7 = cell7->next;\n                  free(cell7);\n                  cell7 = tmp7;\n              }\n              free(sortedlist9);\n              DEBUG_FREE(sortedlist9->id);\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist2_4.h\n#ifndef sortedlist2_4\n#define sortedlist2_4\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1559174\n    - Instructions: 1144138\n    - Cache References: 82647\n    - Cache Misses: 23068\n    - Branch Instructions: 211882\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array13_2.c\n#include \"array13_2.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   if(rng() & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array9 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(array9->id);\n      free(params0.data);\n      array9->refC--;\n      if(array9->refC == 0) {\n         free(array9->data);\n         free(array9);\n         DEBUG_FREE(array9->id);\n      }\n   }\n   return 0;\n}\n\n### File: array13_2.h\n#ifndef array13_2\n#define array13_2\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func6(array_t_param* vars, int loopsFactor);\narray_t* func7(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array13_2.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t* array1;\n      if (pCounter > 0) {\n         array1 = vars->data[--pCounter];\n         array1->refC++;\n         DEBUG_COPY(array1->id);\n      } else {\n         array1 = (array_t*)malloc(sizeof(array_t));\n         array1->size = 386;\n         array1->refC = 1;\n         array1->id = 1;\n         array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n         memset(array1->data, 0, array1->size*sizeof(unsigned int));\n         DEBUG_NEW(array1->id);\n      }\n      array_t_param params0;\n      params0.size = 1;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      params0.data[0] = array1;\n      array_t* array2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params0.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array1->refC--;\n      if(array1->refC == 0) {\n         free(array1->data);\n         free(array1);\n         DEBUG_FREE(array1->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 530;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func1.c\n#include \"array13_2.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array10->id);\n   free(params0.data);\n   return array10;\n}\n\n### File: func2.c\n#include \"array13_2.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array11->id);\n      free(params0.data);\n      array11->refC--;\n      if(array11->refC == 0) {\n         free(array11->data);\n         free(array11);\n         DEBUG_FREE(array11->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array13->id);\n      free(params0.data);\n      array13->refC--;\n      if(array13->refC == 0) {\n         free(array13->data);\n         free(array13);\n         DEBUG_FREE(array13->id);\n      }\n   }\n   array_t* array15;\n   if (pCounter > 0) {\n      array15 = vars->data[--pCounter];\n      array15->refC++;\n      DEBUG_COPY(array15->id);\n   } else {\n      array15 = (array_t*)malloc(sizeof(array_t));\n      array15->size = 324;\n      array15->refC = 1;\n      array15->id = 15;\n      array15->data = (unsigned int*)malloc(array15->size*sizeof(unsigned int));\n      memset(array15->data, 0, array15->size*sizeof(unsigned int));\n      DEBUG_NEW(array15->id);\n   }\n   return array15;\n}\n\n### File: func3.c\n#include \"array13_2.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array12;\n   if (pCounter > 0) {\n      array12 = vars->data[--pCounter];\n      array12->refC++;\n      DEBUG_COPY(array12->id);\n   } else {\n      array12 = (array_t*)malloc(sizeof(array_t));\n      array12->size = 42;\n      array12->refC = 1;\n      array12->id = 12;\n      array12->data = (unsigned int*)malloc(array12->size*sizeof(unsigned int));\n      memset(array12->data, 0, array12->size*sizeof(unsigned int));\n      DEBUG_NEW(array12->id);\n   }\n   return array12;\n}\n\n### File: func4.c\n#include \"array13_2.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array14;\n   if (pCounter > 0) {\n      array14 = vars->data[--pCounter];\n      array14->refC++;\n      DEBUG_COPY(array14->id);\n   } else {\n      array14 = (array_t*)malloc(sizeof(array_t));\n      array14->size = 537;\n      array14->refC = 1;\n      array14->id = 14;\n      array14->data = (unsigned int*)malloc(array14->size*sizeof(unsigned int));\n      memset(array14->data, 0, array14->size*sizeof(unsigned int));\n      DEBUG_NEW(array14->id);\n   }\n   return array14;\n}\n\n### File: func5.c\n#include \"array13_2.h\" \narray_t* func5(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(array3->id);\n      free(params0.data);\n      array3->refC--;\n      if(array3->refC == 0) {\n         free(array3->data);\n         free(array3);\n         DEBUG_FREE(array3->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(array5->id);\n      free(params0.data);\n      array5->refC--;\n      if(array5->refC == 0) {\n         free(array5->data);\n         free(array5);\n         DEBUG_FREE(array5->id);\n      }\n   }\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 429;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: func6.c\n#include \"array13_2.h\" \narray_t* func6(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array4;\n   if (pCounter > 0) {\n      array4 = vars->data[--pCounter];\n      array4->refC++;\n      DEBUG_COPY(array4->id);\n   } else {\n      array4 = (array_t*)malloc(sizeof(array_t));\n      array4->size = 926;\n      array4->refC = 1;\n      array4->id = 4;\n      array4->data = (unsigned int*)malloc(array4->size*sizeof(unsigned int));\n      memset(array4->data, 0, array4->size*sizeof(unsigned int));\n      DEBUG_NEW(array4->id);\n   }\n   return array4;\n}\n\n### File: func7.c\n#include \"array13_2.h\" \narray_t* func7(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array6;\n   if (pCounter > 0) {\n      array6 = vars->data[--pCounter];\n      array6->refC++;\n      DEBUG_COPY(array6->id);\n   } else {\n      array6 = (array_t*)malloc(sizeof(array_t));\n      array6->size = 368;\n      array6->refC = 1;\n      array6->id = 6;\n      array6->data = (unsigned int*)malloc(array6->size*sizeof(unsigned int));\n      memset(array6->data, 0, array6->size*sizeof(unsigned int));\n      DEBUG_NEW(array6->id);\n   }\n   return array6;\n}\n\n### File: rng.c\n#include \"array13_2.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1802758\n    - Instructions: 1678488\n    - Cache References: 71396\n    - Cache Misses: 22360\n    - Branch Instructions: 320509\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist6_3.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist6_3.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist6_3.c\n#include \"sortedlist6_3.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      if(sortedlist0 != NULL && sortedlist0->n > 0)\n      {\n          cell_t* cell1 = sortedlist0->root;\n          if(cell1->val == 93)\n          {\n              cell1 = cell1->next;\n              sortedlist0->n--;\n          }else{\n              while(cell1->next != NULL && cell1->next->val != 93) cell1 = cell1->next;\n              if(cell1->next != NULL)\n              {\n                  cell1 = cell1->next->next;\n                  sortedlist0->n--;\n              }\n           }\n      }\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist6_3.h\n#ifndef sortedlist6_3\n#define sortedlist6_3\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 1790267\n    - Instructions: 1408702\n    - Cache References: 75161\n    - Cache Misses: 31064\n    - Branch Instructions: 265482\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist2_16.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist1;\n   if (pCounter > 0) {\n      sortedlist1 = vars->data[--pCounter];\n      sortedlist1->refC++;\n      DEBUG_COPY(sortedlist1->id);\n   } else {\n      sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist1->refC = 1;\n      sortedlist1->id = 1;\n      sortedlist1->n = 0;\n      sortedlist1->root = NULL;\n      DEBUG_NEW(sortedlist1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      if(sortedlist1 != NULL && sortedlist1->n > 0)\n      {\n          cell_t* cell0 = sortedlist1->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist1->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist1->n--;\n              }\n           }\n      }\n   }\n   return sortedlist1;\n}\n\n### File: rng.c\n#include \"sortedlist2_16.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist2_16.c\n#include \"sortedlist2_16.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell1 = sortedlist0->root;\n              cell_t* tmp1  = NULL;\n              while(cell1 != NULL) {\n                  tmp1 = cell1->next;\n                  free(cell1);\n                  cell1 = tmp1;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist2_16.h\n#ifndef sortedlist2_16\n#define sortedlist2_16\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 8141198\n    - Instructions: 13929882\n    - Cache References: 105641\n    - Cache Misses: 49681\n    - Branch Instructions: 2084206\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array13_12.c\n#include \"array13_12.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array13_12.h\n#ifndef array13_12\n#define array13_12\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array13_12.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: rng.c\n#include \"array13_12.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 9244931\n    - Instructions: 15275921\n    - Cache References: 128528\n    - Cache Misses: 36700\n    - Branch Instructions: 3016869\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist2_1.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist1 = func1(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist1->id);\n      free(params0.data);\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell1 = sortedlist1->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist3;\n   if (pCounter > 0) {\n      sortedlist3 = vars->data[--pCounter];\n      sortedlist3->refC++;\n      DEBUG_COPY(sortedlist3->id);\n   } else {\n      sortedlist3 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist3->refC = 1;\n      sortedlist3->id = 3;\n      sortedlist3->n = 0;\n      sortedlist3->root = NULL;\n      DEBUG_NEW(sortedlist3->id);\n   }\n   return sortedlist3;\n}\n\n### File: func1.c\n#include \"sortedlist2_1.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist2;\n   if (pCounter > 0) {\n      sortedlist2 = vars->data[--pCounter];\n      sortedlist2->refC++;\n      DEBUG_COPY(sortedlist2->id);\n   } else {\n      sortedlist2 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist2->refC = 1;\n      sortedlist2->id = 2;\n      sortedlist2->n = 0;\n      sortedlist2->root = NULL;\n      DEBUG_NEW(sortedlist2->id);\n   }\n   unsigned int loop2 = 0;\n   unsigned int loopLimit2 = (rand()%loopsFactor)/3 + 1;\n   for(; loop2 < loopLimit2; loop2++) {\n      if(sortedlist2 != NULL && sortedlist2->n > 0)\n      {\n          cell_t* cell0 = sortedlist2->root;\n          if(cell0->val == 86)\n          {\n              cell0 = cell0->next;\n              sortedlist2->n--;\n          }else{\n              while(cell0->next != NULL && cell0->next->val != 86) cell0 = cell0->next;\n              if(cell0->next != NULL)\n              {\n                  cell0 = cell0->next->next;\n                  sortedlist2->n--;\n              }\n           }\n      }\n   }\n   return sortedlist2;\n}\n\n### File: rng.c\n#include \"sortedlist2_1.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist2_1.c\n#include \"sortedlist2_1.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist0->id);\n      free(params0.data);\n      sortedlist0->refC--;\n      if(sortedlist0->refC == 0){\n           cell_t* cell2 = sortedlist0->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist0);\n           DEBUG_FREE(sortedlist0->id);\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist2_1.h\n#ifndef sortedlist2_1\n#define sortedlist2_1\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 15739046\n    - Instructions: 32994038\n    - Cache References: 124648\n    - Cache Misses: 29983\n    - Branch Instructions: 6352647\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: func0.c\n#include \"sortedlist11_6.h\" \nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      sortedlist_t* sortedlist1;\n      if (pCounter > 0) {\n         sortedlist1 = vars->data[--pCounter];\n         sortedlist1->refC++;\n         DEBUG_COPY(sortedlist1->id);\n      } else {\n         sortedlist1 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n         sortedlist1->refC = 1;\n         sortedlist1->id = 1;\n         sortedlist1->n = 0;\n         sortedlist1->root = NULL;\n         DEBUG_NEW(sortedlist1->id);\n      }\n      sortedlist_t_param params0;\n      params0.size = 1;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      params0.data[0] = sortedlist1;\n      sortedlist_t* sortedlist2 = func5(&params0, rng(), loopsFactor);\n      DEBUG_RETURN(sortedlist2->id);\n      free(params0.data);\n      sortedlist2->refC--;\n      if(sortedlist2->refC == 0){\n           cell_t* cell2 = sortedlist2->root;\n           cell_t* tmp2  = NULL;\n           while(cell2 != NULL) {\n               tmp2 = cell2->next;\n               free(cell2);\n               cell2 = tmp2;\n           }\n           free(sortedlist2);\n           DEBUG_FREE(sortedlist2->id);\n      }\n      sortedlist1->refC--;\n      if(sortedlist1->refC == 0){\n           cell_t* cell3 = sortedlist1->root;\n           cell_t* tmp3  = NULL;\n           while(cell3 != NULL) {\n               tmp3 = cell3->next;\n               free(cell3);\n               cell3 = tmp3;\n           }\n           free(sortedlist1);\n           DEBUG_FREE(sortedlist1->id);\n      }\n   }\n   sortedlist_t* sortedlist8;\n   if (pCounter > 0) {\n      sortedlist8 = vars->data[--pCounter];\n      sortedlist8->refC++;\n      DEBUG_COPY(sortedlist8->id);\n   } else {\n      sortedlist8 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist8->refC = 1;\n      sortedlist8->id = 8;\n      sortedlist8->n = 0;\n      sortedlist8->root = NULL;\n      DEBUG_NEW(sortedlist8->id);\n   }\n   return sortedlist8;\n}\n\n### File: func1.c\n#include \"sortedlist11_6.h\" \nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t_param params0;\n   params0.size = 0;\n   params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n   sortedlist_t* sortedlist10 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(sortedlist10->id);\n   free(params0.data);\n   return sortedlist10;\n}\n\n### File: func2.c\n#include \"sortedlist11_6.h\" \nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist11 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist11->id);\n      free(params0.data);\n      sortedlist11->refC--;\n      if(sortedlist11->refC == 0){\n           cell_t* cell5 = sortedlist11->root;\n           cell_t* tmp5  = NULL;\n           while(cell5 != NULL) {\n               tmp5 = cell5->next;\n               free(cell5);\n               cell5 = tmp5;\n           }\n           free(sortedlist11);\n           DEBUG_FREE(sortedlist11->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist13 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist13->id);\n      free(params0.data);\n      sortedlist13->refC--;\n      if(sortedlist13->refC == 0){\n           cell_t* cell6 = sortedlist13->root;\n           cell_t* tmp6  = NULL;\n           while(cell6 != NULL) {\n               tmp6 = cell6->next;\n               free(cell6);\n               cell6 = tmp6;\n           }\n           free(sortedlist13);\n           DEBUG_FREE(sortedlist13->id);\n      }\n   }\n   sortedlist_t* sortedlist15;\n   if (pCounter > 0) {\n      sortedlist15 = vars->data[--pCounter];\n      sortedlist15->refC++;\n      DEBUG_COPY(sortedlist15->id);\n   } else {\n      sortedlist15 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist15->refC = 1;\n      sortedlist15->id = 15;\n      sortedlist15->n = 0;\n      sortedlist15->root = NULL;\n      DEBUG_NEW(sortedlist15->id);\n   }\n   return sortedlist15;\n}\n\n### File: func3.c\n#include \"sortedlist11_6.h\" \nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist12;\n   if (pCounter > 0) {\n      sortedlist12 = vars->data[--pCounter];\n      sortedlist12->refC++;\n      DEBUG_COPY(sortedlist12->id);\n   } else {\n      sortedlist12 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist12->refC = 1;\n      sortedlist12->id = 12;\n      sortedlist12->n = 0;\n      sortedlist12->root = NULL;\n      DEBUG_NEW(sortedlist12->id);\n   }\n   return sortedlist12;\n}\n\n### File: func4.c\n#include \"sortedlist11_6.h\" \nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist14;\n   if (pCounter > 0) {\n      sortedlist14 = vars->data[--pCounter];\n      sortedlist14->refC++;\n      DEBUG_COPY(sortedlist14->id);\n   } else {\n      sortedlist14 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist14->refC = 1;\n      sortedlist14->id = 14;\n      sortedlist14->n = 0;\n      sortedlist14->root = NULL;\n      DEBUG_NEW(sortedlist14->id);\n   }\n   return sortedlist14;\n}\n\n### File: func5.c\n#include \"sortedlist11_6.h\" \nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist3 = func6(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist3->id);\n      free(params0.data);\n      sortedlist3->refC--;\n      if(sortedlist3->refC == 0){\n           cell_t* cell0 = sortedlist3->root;\n           cell_t* tmp0  = NULL;\n           while(cell0 != NULL) {\n               tmp0 = cell0->next;\n               free(cell0);\n               cell0 = tmp0;\n           }\n           free(sortedlist3);\n           DEBUG_FREE(sortedlist3->id);\n      }\n   }\n   else {\n      sortedlist_t_param params0;\n      params0.size = 0;\n      params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n      sortedlist_t* sortedlist5 = func7(&params0, loopsFactor);\n      DEBUG_RETURN(sortedlist5->id);\n      free(params0.data);\n      sortedlist5->refC--;\n      if(sortedlist5->refC == 0){\n           cell_t* cell1 = sortedlist5->root;\n           cell_t* tmp1  = NULL;\n           while(cell1 != NULL) {\n               tmp1 = cell1->next;\n               free(cell1);\n               cell1 = tmp1;\n           }\n           free(sortedlist5);\n           DEBUG_FREE(sortedlist5->id);\n      }\n   }\n   sortedlist_t* sortedlist7;\n   if (pCounter > 0) {\n      sortedlist7 = vars->data[--pCounter];\n      sortedlist7->refC++;\n      DEBUG_COPY(sortedlist7->id);\n   } else {\n      sortedlist7 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist7->refC = 1;\n      sortedlist7->id = 7;\n      sortedlist7->n = 0;\n      sortedlist7->root = NULL;\n      DEBUG_NEW(sortedlist7->id);\n   }\n   return sortedlist7;\n}\n\n### File: func6.c\n#include \"sortedlist11_6.h\" \nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist4;\n   if (pCounter > 0) {\n      sortedlist4 = vars->data[--pCounter];\n      sortedlist4->refC++;\n      DEBUG_COPY(sortedlist4->id);\n   } else {\n      sortedlist4 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist4->refC = 1;\n      sortedlist4->id = 4;\n      sortedlist4->n = 0;\n      sortedlist4->root = NULL;\n      DEBUG_NEW(sortedlist4->id);\n   }\n   return sortedlist4;\n}\n\n### File: func7.c\n#include \"sortedlist11_6.h\" \nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   sortedlist_t* sortedlist6;\n   if (pCounter > 0) {\n      sortedlist6 = vars->data[--pCounter];\n      sortedlist6->refC++;\n      DEBUG_COPY(sortedlist6->id);\n   } else {\n      sortedlist6 = (sortedlist_t*)malloc(sizeof(sortedlist_t));\n      sortedlist6->refC = 1;\n      sortedlist6->id = 6;\n      sortedlist6->n = 0;\n      sortedlist6->root = NULL;\n      DEBUG_NEW(sortedlist6->id);\n   }\n   return sortedlist6;\n}\n\n### File: rng.c\n#include \"sortedlist11_6.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n### File: sortedlist11_6.c\n#include \"sortedlist11_6.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      if(rng() & 1) {\n         sortedlist_t_param params0;\n         params0.size = 0;\n         params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n         sortedlist_t* sortedlist0 = func0(&params0, loopsFactor);\n         DEBUG_RETURN(sortedlist0->id);\n         free(params0.data);\n         sortedlist0->refC--;\n         if(sortedlist0->refC == 0){\n              cell_t* cell4 = sortedlist0->root;\n              cell_t* tmp4  = NULL;\n              while(cell4 != NULL) {\n                  tmp4 = cell4->next;\n                  free(cell4);\n                  cell4 = tmp4;\n              }\n              free(sortedlist0);\n              DEBUG_FREE(sortedlist0->id);\n         }\n      }\n      else {\n         unsigned int loop2 = 0;\n         unsigned int loopLimit2 = (rand()%loopsFactor)/2 + 1;\n         for(; loop2 < loopLimit2; loop2++) {\n            sortedlist_t_param params0;\n            params0.size = 0;\n            params0.data = (sortedlist_t**)malloc(params0.size*sizeof(sortedlist_t*));\n            sortedlist_t* sortedlist9 = func1(&params0, loopsFactor);\n            DEBUG_RETURN(sortedlist9->id);\n            free(params0.data);\n            sortedlist9->refC--;\n            if(sortedlist9->refC == 0){\n                 cell_t* cell7 = sortedlist9->root;\n                 cell_t* tmp7  = NULL;\n                 while(cell7 != NULL) {\n                     tmp7 = cell7->next;\n                     free(cell7);\n                     cell7 = tmp7;\n                 }\n                 free(sortedlist9);\n                 DEBUG_FREE(sortedlist9->id);\n            }\n         }\n      }\n   }\n   return 0;\n}\n\n### File: sortedlist11_6.h\n#ifndef sortedlist11_6\n#define sortedlist11_6\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include <stdbool.h>\n#include \"Dalloc.h\"\ntypedef struct cell_t {\n     struct cell_t* next;\n     unsigned int val;\n} cell_t;\ntypedef struct sortedlist_t {\n     cell_t* root;\n     size_t refC;\n     int id;\n     unsigned int n;\n} sortedlist_t;\ntypedef struct {\n   sortedlist_t** data;\n   size_t size;\n} sortedlist_t_param;\n\nunsigned long rng();\nsortedlist_t* func0(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func5(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func6(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func7(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func1(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func2(sortedlist_t_param* vars, const unsigned long PATH0, int loopsFactor);\nsortedlist_t* func3(sortedlist_t_param* vars, int loopsFactor);\nsortedlist_t* func4(sortedlist_t_param* vars, int loopsFactor);\n#endif\n\n</Program>\n    </Program>"}
{"text": "Generate a C program optimized for the following Linux `perf` statistics:\n- CPU Cycles: 8314334\n    - Instructions: 16453241\n    - Cache References: 81352\n    - Cache Misses: 29485\n    - Branch Instructions: 2540585\n\n- **Requirements**:\n    1. The program must contain a main function that receives the data and invokes the processing logic.\n    2. Address performance bottlenecks (e.g., cache misses, branch mispredictions) using:\n    - Loop unrolling, SIMD intrinsics (AVX/SSE), memory alignment.\n    - Data structure optimizations (e.g., cache-friendly layouts).\n    3. **Fuzzer-Specific Constraints**:\n    - Process raw bytes from `const uint8_t* data` and `size_t size` as input.\n    - Avoid undefined behavior: validate buffer bounds, sanitize inputs.\n    - Exclude I/O operations (e.g., `printf`, file access).\n    4. Code Style:\n    - Zero comments or explanations.\n    - Use preprocessor directives only when critical (e.g., `#include <stdint.h>`).\n    5. Enclose the code between <Program> tags.\n    6. If modularized, include a ### File: <filename> tag before each code snippet.\n\n- **Output**:\n    <Program>\n    <Program>\n### File: array7_15.c\n#include \"array7_15.h\"\n\nint main(int argc, char** argv) {\n   int loopsFactor = 100;\n   srand(0);\n   for (int i = 1; i < argc; i++) {\n      if (strcmp(argv[i], \"-path-seed\") == 0) {\n         i++;\n         if (i < argc) {\n            srand(atoi(argv[i]));\n         }\n      }\n      else if (strcmp(argv[i], \"-loops-factor\") == 0) {\n         i++;\n         if (i < argc) {\n            loopsFactor = atoi(argv[i]);\n         }\n      }\n   }\n   unsigned int loop0 = 0;\n   unsigned int loopLimit0 = (rand()%loopsFactor)/1 + 1;\n   for(; loop0 < loopLimit0; loop0++) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array0 = func0(&params0, loopsFactor);\n      DEBUG_RETURN(array0->id);\n      free(params0.data);\n      for (int i = 0; i < array0->size; i++) {\n         array0->data[i]--;\n      }\n      array_t_param params1;\n      params1.size = 1;\n      params1.data = (array_t**)malloc(params1.size*sizeof(array_t*));\n      params1.data[0] = array0;\n      array_t* array2 = func1(&params1, loopsFactor);\n      DEBUG_RETURN(array2->id);\n      free(params1.data);\n      array2->refC--;\n      if(array2->refC == 0) {\n         free(array2->data);\n         free(array2);\n         DEBUG_FREE(array2->id);\n      }\n      array0->refC--;\n      if(array0->refC == 0) {\n         free(array0->data);\n         free(array0);\n         DEBUG_FREE(array0->id);\n      }\n   }\n   return 0;\n}\n\n### File: array7_15.h\n#ifndef array7_15\n#define array7_15\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#ifdef DEBUG\n    #define DEBUG_NEW(id) printf(\"[NEW]\\t\\tId %d created\\n\", id)\n    #define DEBUG_COPY(id) printf(\"[COPY]\\t\\tId %d copied\\n\", id)\n    #define DEBUG_RETURN(id) printf(\"[RETURN]\\tId %d returned\\n\", id)\n    #define DEBUG_FREE(id) printf(\"[FREE]\\t\\tId %d freed\\n\", id)\n#else\n    #define DEBUG_NEW(id)\n    #define DEBUG_COPY(id)\n    #define DEBUG_RETURN(id)\n    #define DEBUG_FREE(id)\n#endif\n#include \"Dalloc.h\"\ntypedef struct {\n   unsigned int* data;\n   size_t size;\n   size_t refC;\n    int id;\n} array_t;\ntypedef struct {\n   array_t** data;\n   size_t size;\n} array_t_param;\n\nunsigned long rng();\narray_t* func0(array_t_param* vars, int loopsFactor);\narray_t* func1(array_t_param* vars, int loopsFactor);\narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor);\narray_t* func3(array_t_param* vars, int loopsFactor);\narray_t* func4(array_t_param* vars, int loopsFactor);\n#endif\n\n### File: func0.c\n#include \"array7_15.h\" \narray_t* func0(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array1;\n   if (pCounter > 0) {\n      array1 = vars->data[--pCounter];\n      array1->refC++;\n      DEBUG_COPY(array1->id);\n   } else {\n      array1 = (array_t*)malloc(sizeof(array_t));\n      array1->size = 386;\n      array1->refC = 1;\n      array1->id = 1;\n      array1->data = (unsigned int*)malloc(array1->size*sizeof(unsigned int));\n      memset(array1->data, 0, array1->size*sizeof(unsigned int));\n      DEBUG_NEW(array1->id);\n   }\n   unsigned int loop1 = 0;\n   unsigned int loopLimit1 = (rand()%loopsFactor)/2 + 1;\n   for(; loop1 < loopLimit1; loop1++) {\n      for (int i = 0; i < array1->size; i++) {\n         array1->data[i]--;\n      }\n   }\n   return array1;\n}\n\n### File: func1.c\n#include \"array7_15.h\" \narray_t* func1(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t_param params0;\n   params0.size = 0;\n   params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n   array_t* array3 = func2(&params0, rng(), loopsFactor);\n   DEBUG_RETURN(array3->id);\n   free(params0.data);\n   return array3;\n}\n\n### File: func2.c\n#include \"array7_15.h\" \narray_t* func2(array_t_param* vars, const unsigned long PATH0, int loopsFactor) {\n   size_t pCounter = vars->size;\n   if(PATH0 & 1) {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array4 = func3(&params0, loopsFactor);\n      DEBUG_RETURN(array4->id);\n      free(params0.data);\n      array4->refC--;\n      if(array4->refC == 0) {\n         free(array4->data);\n         free(array4);\n         DEBUG_FREE(array4->id);\n      }\n   }\n   else {\n      array_t_param params0;\n      params0.size = 0;\n      params0.data = (array_t**)malloc(params0.size*sizeof(array_t*));\n      array_t* array6 = func4(&params0, loopsFactor);\n      DEBUG_RETURN(array6->id);\n      free(params0.data);\n      array6->refC--;\n      if(array6->refC == 0) {\n         free(array6->data);\n         free(array6);\n         DEBUG_FREE(array6->id);\n      }\n   }\n   array_t* array8;\n   if (pCounter > 0) {\n      array8 = vars->data[--pCounter];\n      array8->refC++;\n      DEBUG_COPY(array8->id);\n   } else {\n      array8 = (array_t*)malloc(sizeof(array_t));\n      array8->size = 929;\n      array8->refC = 1;\n      array8->id = 8;\n      array8->data = (unsigned int*)malloc(array8->size*sizeof(unsigned int));\n      memset(array8->data, 0, array8->size*sizeof(unsigned int));\n      DEBUG_NEW(array8->id);\n   }\n   return array8;\n}\n\n### File: func3.c\n#include \"array7_15.h\" \narray_t* func3(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array5;\n   if (pCounter > 0) {\n      array5 = vars->data[--pCounter];\n      array5->refC++;\n      DEBUG_COPY(array5->id);\n   } else {\n      array5 = (array_t*)malloc(sizeof(array_t));\n      array5->size = 567;\n      array5->refC = 1;\n      array5->id = 5;\n      array5->data = (unsigned int*)malloc(array5->size*sizeof(unsigned int));\n      memset(array5->data, 0, array5->size*sizeof(unsigned int));\n      DEBUG_NEW(array5->id);\n   }\n   return array5;\n}\n\n### File: func4.c\n#include \"array7_15.h\" \narray_t* func4(array_t_param* vars, int loopsFactor) {\n   size_t pCounter = vars->size;\n   array_t* array7;\n   if (pCounter > 0) {\n      array7 = vars->data[--pCounter];\n      array7->refC++;\n      DEBUG_COPY(array7->id);\n   } else {\n      array7 = (array_t*)malloc(sizeof(array_t));\n      array7->size = 67;\n      array7->refC = 1;\n      array7->id = 7;\n      array7->data = (unsigned int*)malloc(array7->size*sizeof(unsigned int));\n      memset(array7->data, 0, array7->size*sizeof(unsigned int));\n      DEBUG_NEW(array7->id);\n   }\n   return array7;\n}\n\n### File: rng.c\n#include \"array7_15.h\" \nunsigned long rng() {\n   unsigned long n = rand();\n   return (n << 32) | rand();\n}\n\n</Program>\n    </Program>"}
